
==================== FINAL INTERFACE ====================
2019-02-27 09:56:09.624406048 UTC

interface wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2:BackEnd.Munch 8002
  interface hash: 1a03bf3bc754af702ffbb063517f365b
  ABI hash: aa7227f84819c8d76d912909afbc2bf2
  export-list hash: c90b4ab663b5e6f0160e00ec1f56ea2f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 02b3c746106ad76f793f89ebc1f71840
  sig of: Nothing
  used TH splices: False
  where
exports:
  BackEnd.Munch.accessPair
  BackEnd.Munch.addsubtoCalc
  BackEnd.Munch.assemPre
  BackEnd.Munch.bopToCBS
  BackEnd.Munch.call
  BackEnd.Munch.canlsl
  BackEnd.Munch.condARM
  BackEnd.Munch.condExp
  BackEnd.Munch.condIR
  BackEnd.Munch.condStm
  BackEnd.Munch.createPair
  BackEnd.Munch.deSeq
  BackEnd.Munch.genBuiltIns
  BackEnd.Munch.invert
  BackEnd.Munch.irPre
  BackEnd.Munch.justret
  BackEnd.Munch.load1b
  BackEnd.Munch.log2
  BackEnd.Munch.lslOP
  BackEnd.Munch.munch
  BackEnd.Munch.munchBuiltInFuncFrag
  BackEnd.Munch.munchDataFrag
  BackEnd.Munch.munchExp
  BackEnd.Munch.munchMem
  BackEnd.Munch.munchStm
  BackEnd.Munch.munchmany
  BackEnd.Munch.oneByte
  BackEnd.Munch.opVal
  BackEnd.Munch.optimise
  BackEnd.Munch.optimsedMunch
  BackEnd.Munch.p_check_array_bounds
  BackEnd.Munch.p_check_divide_by_zero
  BackEnd.Munch.p_check_null_pointer
  BackEnd.Munch.p_free_pair
  BackEnd.Munch.p_print_bool
  BackEnd.Munch.p_print_int
  BackEnd.Munch.p_print_ln
  BackEnd.Munch.p_print_reference
  BackEnd.Munch.p_print_string
  BackEnd.Munch.p_read
  BackEnd.Munch.p_read_char
  BackEnd.Munch.p_read_int
  BackEnd.Munch.p_throw_overflow_error
  BackEnd.Munch.p_throw_runtime_error
  BackEnd.Munch.same
  BackEnd.Munch.showExp
  BackEnd.Munch.showStm
  BackEnd.Munch.stackEqualCond
  BackEnd.Munch.store1b
  BackEnd.Munch.suffixStm
  BackEnd.Munch.GenBuiltIn
module dependencies: BackEnd.Assem BackEnd.Builtin BackEnd.Canon
                     BackEnd.Frame BackEnd.IR BackEnd.Instructions BackEnd.Temp
                     BackEnd.Translate FrontEnd.AST FrontEnd.Lexer FrontEnd.Parser
                     FrontEnd.SemanticAnalyzer
package dependencies: MissingH-1.4.0.1@MissingH-1.4.0.1-XvvfeDrBQU2lhIiDW7bjd
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      boxes-0.1.5@boxes-0.1.5-6DdHE3jJ0TwE6WTwMdCW4f
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn
                      ghc-prim-0.5.0.0
                      hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa
                      hashmap-1.3.3@hashmap-1.3.3-6F5MsgNDasO6fIeStnUOf6
                      integer-gmp-1.0.0.1 mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h
                      parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E
                      pretty-tree-0.1.0.0@pretty-tree-0.1.0.0-5ldf01HzJj05FtOtje7CSt
                      split-0.2.3.3@split-0.2.3.3-KPq5EVv6rbi8XHTA0KJd3E
                      text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn:Generics.Deriving.Instances
         hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa:Data.Hashable.Generic
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn:Generics.Deriving.Instances
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
                         wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2:BackEnd.Instructions
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 69259e29eb6a13996a202cd7b2dae772
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State.Class 353753d62a48dcd4d640d0eb74aa4d50
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State.Lazy f8e741bf4d853e8c9e1e41041ac4e6b4
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
import  -/  BackEnd.Assem 0c2dd4117304a7718bc4adf283ae5e64
  exports: 4e4b66683d488fa10cb15dfdfb0d7eda
  ILABEL 5d206a480b086065a1277d09570f1ed2
  IMOV 3e0ac68f750efe372136242554bdca96
  IOPER 0614942d7d3e268dd4216142cfc25be0
  Instr 7e9a983e644f74c95e69c7397c53736a
  assem b4276578abb049b76c552630d13c0e62
  containsDummy a854db65b99ead4e605c0750d138b23a
  dst 012515aa6f33827e26e559f8fe99f8f8
  jump 8cac39b90464c1c2e917864fce4b17ac
  lab 5e929b27e18173de745af7ad343612fb
  normAssem 896ee897304334c4456dd6ecf9752d66
  src 7743602d68b4708d8dd1ad4396041690
import  -/  BackEnd.Builtin ed9d8a61a4fe433113515ad446c366fe
  exports: 0efa3a64647a63ce77aebf0b789b849f
  add_label 153c07ca4e580aa4b7ddd038d5adfd78
  cmp_r0 da7d267edf5a34655e1faa8cb7ddb769
  end e668ea769be96a65a41782736483a720
  jump_to_label b7a5c37c331feb0e369f21cfeac3b6fc
  ld_cond_msg_toR0 c5e2a614b59e7567844c030ed44d0a4c
  ld_msg_toR0 bb498321d203cdfeffc5fd4bc68ce16d
  ljump_cond d6e09457130ae72cd31266beaf549554
  ljump_to_label 416760141121340715b746a82f6bf439
  move_to_r 06ecf2576e989356374d6185bae02685
  poppc 03660254a44cbdd15adf6335754a19b5
  pushlr 5577f894b6d9bb1d8c7998b71dd95e72
  r0_add4 c0299da2ab21d361bc7aefe2adfb9ed7
  r0_clear b2a3d6d06e5127bd9318d7f6392e6eff
import  -/  BackEnd.Canon 503efaee7e90294fb8de0b26955df2ec
  exports: d57d47cd826eaad486c36c64207b85ec
  CanonState 30bad7a15fafcd825f4c98eacdca4108
  controlLabelAlloc c2b42225d3c3421b1ac3d8240d96dde1
  tempAlloc 9874a5edf52311eec9cbe73ec009a2f6
  transform 2b20ca4d56fc1decc2f404c66aed3d45
import  -/  BackEnd.Frame 2a16ec41ca683a4c04bc531bc13d071b
  exports: ff876c8d53ae8d9cc84a5698ff7b815b
  Fragment 178f360a73d54bda48fbe76e6c7fbb4f
  PROC 2b9d17893fedaf24c09290ba6540b23d
  STRING 78217e4228088700a876037af05e9e9e
  dummy 60f190fa7b95b3b4a6dcf548b389921c
  fp 580da9e0b0080cc1e0c65032dd5bff72
  sp 606994e88545fb7a8d39f0c48e74df00
import  -/  BackEnd.IR 881b5c7113579e9e0196d2b90545a438
  exports: 6d764dfdda2ad49e5da2751723ca6e76
  AND abcf56bcaefd09fdcb417c5b1ae415cb
  BINEXP 314d5c5ea0e7abb37509298c8f219809
  BOp c232f4131e5ba3b186ce94934966b167
  CALL 3ea9e353cc093939205143f9affc94dd
  CJUMP 8a9984cdeabb0729a12d302ee976c1ae
  CONSTC d7c2d48ab024444ee1683add7101cf65
  CONSTI 1e86d692b475a9afd7eb4a380c9df20a
  DIV b750d37f3c5598fcb5acb80e406300d5
  EQ 6adbced130978fdfab51558428d57ef4
  ESEQ 7747f3b871d1a0d32a6e9524e80b12be
  EXP f4838f4c177709e7c7e70c0752435d8f
  Exp 29a6c3cd3ea133857ec2f8677caa5fe0
  GE 1fc91032b654e87de530334e697f1246
  GT 77c6d01ac4214ea6d7b1541ba4f7c65f
  JUMP eac31562bd601b25d94ceeeb566aa59e
  LABEL c97b7be2ccf356961383cd3d9288f4e4
  LE 076c5ca5320a8b54c74696edde08b9da
  LSHIFT 5160fc314d59e9605c94e6b275d2de20
  LT b4a1e62f17273a2504227d1ce6663575
  MEM b593e2a075e1ece03bfeed656ad0d462
  MINUS bd554593b3645acec0c60b3fe19827fb
  MOD 272e86bb622690fab60fe065c0d607a3
  MOV 06cbd5b3f416dbde4084d0dc86d79095
  MUL c576d2fcb0096224259caaaee70b210b
  NAME 09e0af564273846ddfc4a8df2204c47b
  NE 33058a3449a4760684783802d64a9101
  NOP b03e7ae709d42a8a9ae7021ff91d4519
  OR 1ab045d5c38128e42d089751b4fca2f8
  PLUS fbf0c26117466714144501139f520f88
  POP 6668b454a821e04401bd00ff3ba590c7
  PUSH 747fde67cb21ccf1612f512ef7204765
  ROp 2106592c3ca9d65fb59030dc1bff8b4a
  RSHIFT b1862486f43ad27b979b05863104e99b
  SEQ f05eb9a24fbe0c461a90502ed64bebc9
  Stm 29a6c3cd3ea133857ec2f8677caa5fe0
  TEMP fed6108e10e5807c38f5a398fcd57699
import  -/  BackEnd.Instructions 4d01d75e375ace81049cc56959743d7f
  exports: 05db9b415662c28923114b34233dccb8
  ADD 53d6297a8ebfbcdb3d868b4176f410af
  AL 71f0108ba9d3f4e47eaac9d6626ee746
  AND 24c68078ed6eb699098d895618093fbc
  ASR_ 5dedb77bed1ab41c8932443ea4302dec
  B b661e17f208e22a3a60a0e0c4028c5fb
  BL 98be4a2444de6dc4bcff7225e1b391a9
  BRANCH_ 21e979553c00166dade29e2b4ac52f38
  B_ eb02e1a652d90a1f079000d677a61e7c
  C2_ a317e7461a4062bb808fd8bb2dee9628
  CBS_ 92654cea7c830fb069fe0b8b0652e384
  CHR eb465fa1114b1e13a5766d08fa95770a
  CMP 17d45495abcaac183f44c8ae15fc0f5d
  CS c1742abaebc803997e3622c33c08d25c
  Calc 4df325534026f24233966f285475e832
  Cond fc4ccbb259531356b9cf64e8be88a1b5
  EOR a45485948c062a55225d089a1d16d9c9
  EQ 0461c2d2f9b377e68479e521846aed8d
  GE e36a33ea5395f11b86cec651dbc710fd
  GT 4c569c8376af495c28d2e2271d575dd1
  IMM f6471e293b63d1597e4cbf39cf655499
  Imm 02ad0ac61288393ca795cecafdb22922
  LAB 0e21587c486a54e60eb370b096720078
  LDR 94c0368f2649bfbb8ab90e3275173c70
  LE 8643d812d7415e68db808ad9bc10ccaf
  LR fafc5439dfd7faa8b9283b12d75a21b5
  LSL ebff6ac514ee7cfbb96f3665c1403cc6
  LSL_ ad8db5e1ec73d6c55f96e32de2f864ae
  LSR 9422217f77c9b0dabdb70f8be35d2077
  LT 72ff4cbcbfc67122f95fb9a05f2e12c9
  L_ 051d3563297aa675364743ae580fde1a
  M d3bbb46256c0d5cdd42ad8d76457a340
  MC_ f42c1c5adf0f173687370f9cc4271b56
  MOV 9220b70c7e9f83ae29ae465b4ad0192e
  MSG 08c82d61d700ad40001693aab99f5f4c
  NE e13e16c5d1f582f657a4a83d621faca2
  NUM e634b65dcae28d57e926746f55b03a34
  NoSuffix 8fdd08444bb0e14d9f67c55216d738d2
  ORR ca8b4ba5a0070aaa0608d30e6c601382
  PC 7746b65c8fbd1f68b9ccadd6932125f5
  POP eb4d6ea290c988876c422ae4fe31cc0d
  PRE a4c83dc855a6e0a705c880228ff63828
  PUSH 580f600e55652335bf27380bfdba585a
  R 2879389a0f42cd51af7d0cba327d4812
  R0 e6cc9e8c06e2cd562610a47a1c0a0449
  R1 96050e6dc015332d2784f21a50448d63
  R2 5303755472d310c4264fea983a197074
  RSB f5150c5973848f8c2616e5ee462e4cb2
  RTEMP 714e021c5d4ed8a746e447698c2cd6e0
  S 4f7add424c489ad65d6d539186610dfa
  SB 0e6eb8daf155803c5e5cbc337a4ab06a
  SL 6f6fe97e035a7e93e4e69839c0afac6b
  SLOP2 00ea9057b3052238334f40545c4a4949
  SLType d54ecd9ec7055e5073817c0b04b156a6
  SMULL 39f51bb5042c5448a23c03e525e96ec4
  SP b61633cc96568599a9861934fa1bff8a
  STACK_ 8e654d770bedd182411dbe263b9e3324
  STR ede43d63fe072bf5bcd55bcbbb20ddb2
  SUB 636e986aaf4bdac3fdcd14d7cfe6d17b
  S_ 97ae5f7f5040d2950cf70d231f890c96
  Suffix 709c11199a0d79d055ba0c7b30e70caf
  VS cfe434f003a5d17b02d75854cae6cfd8
  W e03587dcef19a3d775cd6afb4b5add30
import  -/  BackEnd.Temp 0c22f42d627493b2b3f13cd2a3ac5a46
  exports: ecf0e74365e1a70f2572e5197e175ea3
  Temp 14024289252e98b781eb5778cbac8848
import  -/  BackEnd.Translate f25829781727f8c89b1efb5ee803e929
  exports: d00c5cdab9fae07fbdebcdfe18de688f
  TranslateState 657e9bfe2f8caac8e8d4eff1de10e4b4
  addFragment d3f5abf931bef1bef08d195eb1f58a4e
  builtInSet d14106632b608f42621ddc79731bdd50
  controlLabelAlloc 3b9cb15a736b8f79135686a7b13dc77a
  dataFrags 8249b66ac5a5c99cb498c1dcf4b10909
  newDataLabel b72ad0a10c94dc983853d8cef1b7262c
  newTemp b96f481b9205729ec1f85e53faa5f8ec
  newTranslateState b790d14e7539c88a6dc0cd476b1ce974
  procFrags cde1c0203be86bbe761139a1400d2ea4
  tempAlloc 399b2447dad408f0d246c1b097611ff6
  translate c81bd549ed640df32bbad3b81be0eba1
import  -/  FrontEnd.Parser dc168563fd1859eeec254be3c17e78ba
  exports: 45bb2ab1df05f1264fee753899b5f469
  parseFile 929aa559965a9236f270d400e22bd9ed
import  -/  FrontEnd.SemanticAnalyzer 2f8f81b4dd9a2a3fbbaa2a032c60c1d3
  exports: 3c3524b7a455b135a3bb7a20b10bc1fa
  analyzeAST e5e0977902ab61dd8618d68f6e124446
e9744eceb421dadded08b93ab9a1329a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   BackEnd.Munch.$trModule2
                   BackEnd.Munch.$trModule1) -}
292a3257ff2724e89443bd61a33baf79
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BackEnd.Munch"#) -}
ad13ad4d30d86346881202d23b5e7669
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2"#) -}
f411aa65daa221d08bb02a5a7b4d3f71
  $wp_check_array_bounds ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 let {
                   ds2 :: BackEnd.Translate.TranslateState
                   = case w of wild { BackEnd.Translate.TranslateState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                     BackEnd.Translate.TranslateState
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7
                       (case ds of wild1 { (,) alloc label -> alloc })
                       ds9
                       ds10 }
                 } in
                 let {
                   ds3 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case ds2 of wild { BackEnd.Translate.TranslateState ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                     case ds9 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds4 :: BackEnd.Temp.Label
                   = case ds3 of wild { (,) alloc label -> label }
                 } in
                 let {
                   ds5 :: BackEnd.Translate.TranslateState
                   = case ds2 of wild { BackEnd.Translate.TranslateState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                     BackEnd.Translate.TranslateState
                       ds6
                       ds7
                       ds8
                       ds9
                       ds10
                       (case ds3 of wild1 { (,) alloc label -> alloc })
                       ds12
                       ds13 }
                 } in
                 let {
                   ds6 :: (BackEnd.Temp.TempAllocator, BackEnd.Temp.Temp)
                   = case ds5 of wild { BackEnd.Translate.TranslateState ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ->
                     case ds10 of wild1 { BackEnd.Temp.TempAllocator i ->
                     (BackEnd.Temp.TempAllocator
                        (case i of wild2 { GHC.Types.I# x ->
                         GHC.Types.I# (GHC.Prim.+# x 1#) }),
                      i) } }
                 } in
                 let {
                   ds7 :: BackEnd.Temp.Temp
                   = case ds6 of wild { (,) tempAlloc' temp -> temp }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns37
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Builtin.cmp_r0
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.genBuiltIns36
                                     BackEnd.Instructions.R0
                                     (BackEnd.Instructions.MSG ds1))
                                  BackEnd.Builtin.cmp_r1
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               (GHC.Types.:
                                  @ BackEnd.Assem.Instr
                                  BackEnd.Munch.genBuiltIns33
                                  (GHC.Types.:
                                     @ BackEnd.Assem.Instr
                                     (BackEnd.Assem.IMOV
                                        (BackEnd.Instructions.S_
                                           BackEnd.Munch.accessPair6
                                           (BackEnd.Instructions.RTEMP ds7)
                                           (BackEnd.Instructions.Imm
                                              (BackEnd.Instructions.RTEMP ds7)
                                              BackEnd.Munch.accessPair4))
                                        BackEnd.Munch.accessPair10
                                        (GHC.Types.:
                                           @ BackEnd.Temp.Temp
                                           ds7
                                           (GHC.Types.[] @ BackEnd.Temp.Temp)))
                                     (GHC.Types.:
                                        @ BackEnd.Assem.Instr
                                        BackEnd.Builtin.cmp_r0
                                        (GHC.Types.:
                                           @ BackEnd.Assem.Instr
                                           (BackEnd.Assem.IMOV
                                              (BackEnd.Instructions.S_
                                                 BackEnd.Munch.genBuiltIns32
                                                 BackEnd.Instructions.R0
                                                 (BackEnd.Instructions.MSG ds4))
                                              BackEnd.Builtin.cmp_r1
                                              (GHC.Types.[] @ BackEnd.Temp.Temp))
                                           BackEnd.Munch.genBuiltIns25))))))),
                    case ds5 of wild { BackEnd.Translate.TranslateState ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                    BackEnd.Translate.TranslateState
                      ds8
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds4 BackEnd.Munch.genBuiltIns24)
                         (GHC.Types.:
                            @ BackEnd.Frame.Fragment
                            (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns23)
                            ds9))
                      ds10
                      (case ds6 of wild1 { (,) tempAlloc' temp -> tempAlloc' })
                      ds12
                      ds13
                      ds14
                      ds15 } #)) -}
30b2bde6a6093ba2847676fefe70cfbd
  $wp_check_divide_by_zero ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.p_check_divide_by_zero7
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Munch.p_check_divide_by_zero3
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.assemPre11
                                     BackEnd.Instructions.R0
                                     (BackEnd.Instructions.MSG ds1))
                                  BackEnd.Builtin.cmp_r1
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               BackEnd.Munch.genBuiltIns118))),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.p_check_divide_by_zero2)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
c3d597c82023ee541bc18043ef2c567b
  $wp_check_null_pointer ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns119
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Builtin.cmp_r0
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.assemPre11
                                     BackEnd.Instructions.R0
                                     (BackEnd.Instructions.MSG ds1))
                                  BackEnd.Builtin.cmp_r1
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               BackEnd.Munch.genBuiltIns118))),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns41)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
5609f94c81d7469b9d4d504674e4a3b6
  $wp_free_pair ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns77
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Builtin.cmp_r0
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.assemPre11
                                     BackEnd.Instructions.R0
                                     (BackEnd.Instructions.MSG ds1))
                                  BackEnd.Builtin.cmp_r1
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               BackEnd.Munch.genBuiltIns42))),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns41)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
622bc1f16f1fcb8603f05302b18763ba
  $wp_print_bool ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 let {
                   ds2 :: BackEnd.Translate.TranslateState
                   = case w of wild { BackEnd.Translate.TranslateState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                     BackEnd.Translate.TranslateState
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7
                       (case ds of wild1 { (,) alloc label -> alloc })
                       ds9
                       ds10 }
                 } in
                 let {
                   ds3 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case ds2 of wild { BackEnd.Translate.TranslateState ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                     case ds9 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds4 :: BackEnd.Temp.Label
                   = case ds3 of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns139
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Builtin.cmp_r0
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.genBuiltIns138
                                     BackEnd.Instructions.R0
                                     (BackEnd.Instructions.MSG ds1))
                                  BackEnd.Builtin.cmp_r1
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               (GHC.Types.:
                                  @ BackEnd.Assem.Instr
                                  (BackEnd.Assem.IMOV
                                     (BackEnd.Instructions.S_
                                        BackEnd.Munch.assemPre11
                                        BackEnd.Instructions.R0
                                        (BackEnd.Instructions.MSG ds4))
                                     BackEnd.Builtin.cmp_r1
                                     (GHC.Types.[] @ BackEnd.Temp.Temp))
                                  BackEnd.Builtin.end)))),
                    case ds2 of wild { BackEnd.Translate.TranslateState ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                    BackEnd.Translate.TranslateState
                      ds5
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds4 BackEnd.Munch.genBuiltIns137)
                         (GHC.Types.:
                            @ BackEnd.Frame.Fragment
                            (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns136)
                            ds6))
                      ds7
                      ds8
                      ds9
                      (case ds3 of wild1 { (,) alloc label -> alloc })
                      ds11
                      ds12 } #)) -}
8faf17001294466ebb26af4df16e75db
  $wp_print_int ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 let {
                   ds2 :: BackEnd.Translate.TranslateState
                   = case w of wild { BackEnd.Translate.TranslateState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                     BackEnd.Translate.TranslateState
                       ds3
                       ds4
                       ds5
                       ds6
                       ds7
                       (case ds of wild1 { (,) alloc label -> alloc })
                       ds9
                       ds10 }
                 } in
                 let {
                   ds3 :: (BackEnd.Temp.TempAllocator, BackEnd.Temp.Temp)
                   = case ds2 of wild { BackEnd.Translate.TranslateState ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                     case ds7 of wild1 { BackEnd.Temp.TempAllocator i ->
                     (BackEnd.Temp.TempAllocator
                        (case i of wild2 { GHC.Types.I# x ->
                         GHC.Types.I# (GHC.Prim.+# x 1#) }),
                      i) } }
                 } in
                 let {
                   ds4 :: BackEnd.Temp.Temp
                   = case ds3 of wild { (,) tempAlloc' temp -> temp }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns142
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            (BackEnd.Assem.IMOV
                               (BackEnd.Instructions.MC_
                                  BackEnd.Builtin.r0_clear2
                                  (BackEnd.Instructions.RTEMP ds4)
                                  BackEnd.Munch.genBuiltIns92)
                               (GHC.Types.:
                                  @ BackEnd.Temp.Temp
                                  ds4
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               BackEnd.Munch.accessPair10)
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Assem.IMOV
                                  (BackEnd.Instructions.S_
                                     BackEnd.Munch.accessPair6
                                     (BackEnd.Instructions.RTEMP ds4)
                                     (BackEnd.Instructions.MSG ds1))
                                  (GHC.Types.:
                                     @ BackEnd.Temp.Temp
                                     ds4
                                     (GHC.Types.[] @ BackEnd.Temp.Temp))
                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                               BackEnd.Builtin.end))),
                    case ds2 of wild { BackEnd.Translate.TranslateState ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                    BackEnd.Translate.TranslateState
                      ds5
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns96)
                         ds6)
                      ds7
                      (case ds3 of wild1 { (,) tempAlloc' temp -> tempAlloc' })
                      ds9
                      ds10
                      ds11
                      ds12 } #)) -}
df5fc8cdbb728f39ae9ea3f9512c3a11
  $wp_print_ln ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns158
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            (BackEnd.Builtin.ld_msg_toR0 ds1)
                            BackEnd.Munch.genBuiltIns146)),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns145)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
ce088a1ae99c05dd2194906bf8a29bed
  $wp_print_reference ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns123
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Munch.genBuiltIns90
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               (BackEnd.Builtin.ld_msg_toR0 ds1)
                               BackEnd.Builtin.end))),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns122)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
4bebfdcc35a1609583724ae25b2a9c5c
  $wp_print_string ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns133
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Builtin.pushlr
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            BackEnd.Munch.genBuiltIns131
                            (GHC.Types.:
                               @ BackEnd.Assem.Instr
                               BackEnd.Munch.genBuiltIns127
                               (GHC.Types.:
                                  @ BackEnd.Assem.Instr
                                  (BackEnd.Builtin.ld_msg_toR0 ds1)
                                  BackEnd.Builtin.end)))),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns126)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
632a5a109bb6b22e702f29f9ec1d0f70
  $wp_read ::
    GHC.Base.String
    -> BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w1 of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Builtin.pushlr
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         BackEnd.Munch.genBuiltIns90
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            (BackEnd.Builtin.ld_msg_toR0 ds1)
                            BackEnd.Munch.genBuiltIns84)),
                    case w1 of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 w)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
1f59b8a79487ec8483db857ccc5eda12
  $wp_throw_overflow_error ::
    BackEnd.Translate.TranslateState
    -> (# [BackEnd.Assem.Instr], BackEnd.Translate.TranslateState #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 let {
                   ds1 :: BackEnd.Temp.Label
                   = case ds of wild { (,) alloc label -> label }
                 } in
                 (# GHC.Types.:
                      @ BackEnd.Assem.Instr
                      BackEnd.Munch.genBuiltIns19
                      (GHC.Types.:
                         @ BackEnd.Assem.Instr
                         (BackEnd.Builtin.ld_msg_toR0 ds1)
                         BackEnd.Munch.genBuiltIns14),
                    case w of wild { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                    BackEnd.Translate.TranslateState
                      ds2
                      (GHC.Types.:
                         @ BackEnd.Frame.Fragment
                         (BackEnd.Frame.STRING ds1 BackEnd.Munch.genBuiltIns13)
                         ds3)
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8
                      ds9 } #)) -}
19fc7c3cab5f023ce028ca486e074fb0
  type GenBuiltIn =
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState [BackEnd.Assem.Instr]
156f8fcf4c6061faf5ec10c1a0e82bf4
  accessPair ::
    GHC.Types.Bool
    -> GHC.Base.String
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Arity: 3, Strictness: <L,1*U><L,U><S,1*U>,
     Unfolding: (\ (isfst :: GHC.Types.Bool)
                   (typestr :: GHC.Base.String)
                   (ds :: [BackEnd.IR.Exp]) ->
                 case ds of wild {
                   [] -> BackEnd.Munch.accessPair18
                   : e ds1
                   -> case ds1 of wild1 {
                        []
                        -> let {
                             lvl86 :: GHC.Types.Int
                             = case isfst of wild2 {
                                 GHC.Types.False -> BackEnd.Munch.accessPair17
                                 GHC.Types.True -> BackEnd.Munch.accessPair4 }
                           } in
                           let {
                             one :: GHC.Types.Bool
                             = case GHC.Base.eqString
                                      typestr
                                      BackEnd.Munch.accessPair16 of wild2 {
                                 GHC.Types.False
                                 -> GHC.Base.eqString typestr BackEnd.Munch.accessPair15
                                 GHC.Types.True -> GHC.Types.True }
                           } in
                           let {
                             lvl87 :: BackEnd.Instructions.SLType
                             = case one of wild2 {
                                 GHC.Types.False -> BackEnd.Instructions.W
                                 GHC.Types.True -> BackEnd.Instructions.SB }
                           } in
                           let {
                             lvl88 :: BackEnd.Instructions.SL
                             = BackEnd.Instructions.LDR lvl87 BackEnd.Instructions.AL
                           } in
                           let {
                             lvl89 :: BackEnd.Instructions.SLType
                             = case one of wild2 {
                                 GHC.Types.False -> BackEnd.Instructions.W
                                 GHC.Types.True -> BackEnd.Instructions.B_ }
                           } in
                           let {
                             lvl90 :: BackEnd.Instructions.SL
                             = BackEnd.Instructions.STR lvl89 BackEnd.Instructions.AL
                           } in
                           let {
                             m1 :: Control.Monad.Trans.State.Lazy.StateT
                                     BackEnd.Translate.TranslateState
                                     Data.Functor.Identity.Identity
                                     ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
                             = BackEnd.Munch.munchExp e
                           } in
                           (\ (s1 :: BackEnd.Translate.TranslateState) ->
                            case (m1
                                    `cast`
                                  (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                       <BackEnd.Translate.TranslateState>_N
                                       <Data.Functor.Identity.Identity>_R
                                       <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                                    s1)
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                                        BackEnd.Translate.TranslateState)>_R) of wild2 { (,) a1 s' ->
                            case a1 of wild3 { (,) i t ->
                            ((GHC.Base.++
                                @ BackEnd.Assem.Instr
                                i
                                (GHC.Types.:
                                   @ BackEnd.Assem.Instr
                                   (BackEnd.Assem.IMOV
                                      (BackEnd.Instructions.MC_
                                         BackEnd.Builtin.r0_clear2
                                         BackEnd.Munch.accessPair14
                                         (BackEnd.Instructions.R (BackEnd.Instructions.RTEMP t)))
                                      BackEnd.Munch.accessPair10
                                      (GHC.Types.:
                                         @ BackEnd.Temp.Temp
                                         t
                                         (GHC.Types.[] @ BackEnd.Temp.Temp)))
                                   (GHC.Types.:
                                      @ BackEnd.Assem.Instr
                                      BackEnd.Munch.accessPair7
                                      (GHC.Types.:
                                         @ BackEnd.Assem.Instr
                                         (BackEnd.Assem.IMOV
                                            (BackEnd.Instructions.S_
                                               BackEnd.Munch.accessPair6
                                               (BackEnd.Instructions.RTEMP t)
                                               (BackEnd.Instructions.Imm
                                                  (BackEnd.Instructions.RTEMP t)
                                                  lvl86))
                                            (GHC.Types.:
                                               @ BackEnd.Temp.Temp
                                               t
                                               (GHC.Types.[] @ BackEnd.Temp.Temp))
                                            (GHC.Types.:
                                               @ BackEnd.Temp.Temp
                                               t
                                               (GHC.Types.[] @ BackEnd.Temp.Temp)))
                                         (GHC.Types.:
                                            @ BackEnd.Assem.Instr
                                            (BackEnd.Assem.IMOV
                                               (BackEnd.Instructions.S_
                                                  lvl88
                                                  (BackEnd.Instructions.RTEMP t)
                                                  (BackEnd.Instructions.Imm
                                                     (BackEnd.Instructions.RTEMP t)
                                                     BackEnd.Munch.accessPair4))
                                               (GHC.Types.:
                                                  @ BackEnd.Temp.Temp
                                                  t
                                                  (GHC.Types.[] @ BackEnd.Temp.Temp))
                                               (GHC.Types.:
                                                  @ BackEnd.Temp.Temp
                                                  t
                                                  (GHC.Types.[] @ BackEnd.Temp.Temp)))
                                            (GHC.Types.:
                                               @ BackEnd.Assem.Instr
                                               (BackEnd.Assem.IMOV
                                                  (BackEnd.Instructions.S_
                                                     lvl90
                                                     (BackEnd.Instructions.RTEMP t)
                                                     BackEnd.Munch.accessPair3)
                                                  (GHC.Types.[] @ BackEnd.Temp.Temp)
                                                  (GHC.Types.:
                                                     @ BackEnd.Temp.Temp
                                                     t
                                                     BackEnd.Munch.accessPair2))
                                               (GHC.Types.[] @ BackEnd.Assem.Instr)))))),
                              BackEnd.Munch.accessPair1),
                             s')
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                                        BackEnd.Translate.TranslateState)>_R)) } })
                             `cast`
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <BackEnd.Translate.TranslateState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N))
                        : ipv ipv1 -> BackEnd.Munch.accessPair18 } }) -}
f21b4a30c3d7181d6f93831ccc0f943c
  accessPair1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 13#) -}
21317640691756ba3a6406a2aa2622c1
  accessPair10 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Munch.accessPair4
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
323b550528dfa7a0d4135bb0ffec90e4
  accessPair11 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.accessPair12) -}
9a67c6137b9d246df55ee2b2831af719
  accessPair12 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_ BackEnd.Munch.accessPair9) -}
63f2f918e618cb651c7271e2afbc193c
  accessPair13 :: BackEnd.Instructions.Branch
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.BL BackEnd.Instructions.AL) -}
043093bac660c3ee3b189d7d1a406417
  accessPair14 :: BackEnd.Instructions.REG
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.RTEMP
                   BackEnd.Munch.accessPair4) -}
62ca76acebd468424a0cd548752b5254
  accessPair15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TChar"#) -}
4dddb9fe91ddbbdd600f9f3d9c429e78
  accessPair16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TBool"#) -}
e83d8354f3feef6b8eedcc21720ed28c
  accessPair17 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
3fae47f8e03945077c36bb26aa92b256
  accessPair18 ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState
      ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Strictness: x -}
e5810b85b8b3cfff285d9955bbcd82f7
  accessPair2 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Munch.accessPair1
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
2a754ee5065151683c26833b91d3b964
  accessPair3 :: BackEnd.Instructions.SLOP2
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Instructions.Imm
                   BackEnd.Munch.accessPair5
                   BackEnd.Munch.accessPair4) -}
ed56c78f6b4e4f63a6b3db506f1400b1
  accessPair4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
8aef62328b19b8e7f627fe4fc894f636
  accessPair5 :: BackEnd.Instructions.REG
  {- HasNoCafRefs, Strictness: m17,
     Unfolding: (BackEnd.Instructions.RTEMP
                   BackEnd.Munch.accessPair1) -}
954064894f7cef3b302405c1572b6bb6
  accessPair6 :: BackEnd.Instructions.SL
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.LDR
                   BackEnd.Instructions.W
                   BackEnd.Instructions.AL) -}
62921a74f88357cbb90af36fce321b24
  accessPair7 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.accessPair11
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Munch.accessPair10
                   BackEnd.Munch.accessPair8) -}
c732108e8d8777f28a9312805a673a91
  accessPair8 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.accessPair9
                   (GHC.Types.[] @ GHC.Base.String)) -}
16c6ac29100b9c0dcedd5e75f5031139
  accessPair9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "p_check_null_pointer"#) -}
3e19b59d59cba6b2308c7b499fcdbbbd
  addsubtoCalc ::
    BackEnd.IR.BOp
    -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: BackEnd.IR.BOp) (eta :: BackEnd.Instructions.Cond) ->
                 case ds of wild {
                   DEFAULT
                   -> case BackEnd.Munch.addsubtoCalc1
                      ret_ty BackEnd.Instructions.Calc
                      of {}
                   BackEnd.IR.PLUS
                   -> BackEnd.Instructions.ADD BackEnd.Instructions.NoSuffix eta
                   BackEnd.IR.MINUS
                   -> BackEnd.Instructions.SUB BackEnd.Instructions.NoSuffix eta }) -}
d5a2fb6db2af71e6e5cadfec525aacd3
  addsubtoCalc1 ::
    BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc
  {- Strictness: x -}
a68490512d60c216064d791bc2cec933
  assemPre :: [BackEnd.Assem.Instr]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.assemPre12
                   BackEnd.Munch.assemPre1) -}
f0ece93c02c72af2ee33e73304b3fdab
  assemPre1 :: [BackEnd.Assem.Instr]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.assemPre2
                   (GHC.Types.[] @ BackEnd.Assem.Instr)) -}
602eff0d279bf51fecf3151f509c1675
  assemPre10 :: BackEnd.Instructions.REG
  {- HasNoCafRefs, Strictness: m17,
     Unfolding: (BackEnd.Instructions.RTEMP BackEnd.Munch.assemPre4) -}
1de54391d676d6519583b5b49a6d4aa6
  assemPre11 :: BackEnd.Instructions.SL
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.LDR
                   BackEnd.Instructions.W
                   BackEnd.Instructions.EQ) -}
a8d8e558d5eb88c0285f4d55fe45e3db
  assemPre12 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.assemPre13
                   BackEnd.Munch.assemPre5
                   BackEnd.Munch.assemPre5
                   (GHC.Types.[] @ GHC.Base.String)) -}
eea08064d457b6507b236ba91eb0368e
  assemPre13 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.CBS_
                   BackEnd.Munch.assemPre15
                   BackEnd.Munch.assemPre9
                   BackEnd.Munch.assemPre9
                   BackEnd.Munch.assemPre14) -}
9e056a2b6ed5fcd09552a7b44a9eb03b
  assemPre14 :: BackEnd.Instructions.OP
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.IMM BackEnd.Munch.assemPre4) -}
563738ae5ed0b6d5a5adb2319ef16b9e
  assemPre15 :: BackEnd.Instructions.Calc
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.ADD
                   BackEnd.Instructions.NoSuffix
                   BackEnd.Instructions.EQ) -}
8238076fa3fc828cd547c5637a988fa5
  assemPre2 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.assemPre7
                   BackEnd.Munch.assemPre5
                   BackEnd.Munch.assemPre3) -}
dad6eebce24be19ada293bd307345058
  assemPre3 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Munch.assemPre4
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
dcc07280d31b502203232477228d570a
  assemPre4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
ea4b64dd5913fc48964d3b4bd0007fcd
  assemPre5 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Munch.assemPre6
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
118d80206e206451b0bcb306ebc0a55f
  assemPre6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
709b48d0839f4a418837c59cd1c25095
  assemPre7 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.Instructions.S_
                   BackEnd.Munch.assemPre11
                   BackEnd.Munch.assemPre10
                   BackEnd.Munch.assemPre8) -}
8c1d140b8e2509524ae8c66dff0cf6bf
  assemPre8 :: BackEnd.Instructions.SLOP2
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Instructions.Imm
                   BackEnd.Munch.assemPre9
                   BackEnd.Munch.accessPair4) -}
e23a08bc965f0965fa27d386587ef1ef
  assemPre9 :: BackEnd.Instructions.REG
  {- HasNoCafRefs, Strictness: m17,
     Unfolding: (BackEnd.Instructions.RTEMP BackEnd.Munch.assemPre6) -}
be484c7f7eba4b9e9a86e670b547d64f
  bopToCBS ::
    BackEnd.IR.BOp
    -> GHC.Base.Maybe
         (BackEnd.Instructions.Suffix
          -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (bop :: BackEnd.IR.BOp) ->
                 GHC.List.lookup
                   @ BackEnd.IR.BOp
                   @ (BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.IR.$fEqBOp
                   bop
                   BackEnd.Munch.bopToCBS1) -}
503da8b27a47ae3a287cf425783c9ed3
  bopToCBS1 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS12
                   BackEnd.Munch.bopToCBS2) -}
d6203bd822627628ceb9089f7acefbef
  bopToCBS10 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.OR, BackEnd.Instructions.ORR)) -}
be3b61c5050b9c40b48994d7ee016698
  bopToCBS11 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.AND, BackEnd.Instructions.AND)) -}
d348c200a0fc14995bf95db6e7839dc0
  bopToCBS12 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.PLUS, BackEnd.Instructions.ADD)) -}
9daf20cf11d7dbdeeb6d447e1560f290
  bopToCBS2 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS11
                   BackEnd.Munch.bopToCBS3) -}
6d1793c3366a062300a9941b36b58307
  bopToCBS3 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS10
                   BackEnd.Munch.bopToCBS4) -}
c0fc61fb279d9cbc57aeb4139174dbb3
  bopToCBS4 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS9
                   BackEnd.Munch.bopToCBS5) -}
bb6a2786229a982e4c80b29340f17e38
  bopToCBS5 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS8
                   BackEnd.Munch.bopToCBS6) -}
41de47312c415f238f229caeaadfa23a
  bopToCBS6 ::
    [(BackEnd.IR.BOp,
      BackEnd.Instructions.Suffix
      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (BackEnd.IR.BOp,
                      BackEnd.Instructions.Suffix
                      -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
                   BackEnd.Munch.bopToCBS7
                   (GHC.Types.[]
                      @ (BackEnd.IR.BOp,
                         BackEnd.Instructions.Suffix
                         -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc))) -}
d38ea3477cc57d646c5ec7c818cb8782
  bopToCBS7 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.MINUS, BackEnd.Instructions.SUB)) -}
89d4e6e6c7c64edc67ed1b0229925c1b
  bopToCBS8 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.RSHIFT, BackEnd.Instructions.LSR)) -}
cf9763f108ec07e91c8f1cb7049eba58
  bopToCBS9 ::
    (BackEnd.IR.BOp,
     BackEnd.Instructions.Suffix
     -> BackEnd.Instructions.Cond -> BackEnd.Instructions.Calc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.IR.LSHIFT, BackEnd.Instructions.LSL)) -}
8536816d7697d10e9fa9072402e78c9f
  call :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m7,
     Unfolding: (BackEnd.IR.CALL
                   BackEnd.Munch.call4
                   BackEnd.Munch.call1) -}
976f333b9ad62d08ebcec0faacfeeb9f
  call1 :: [BackEnd.IR.Exp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.Exp
                   BackEnd.Munch.call2
                   (GHC.Types.[] @ BackEnd.IR.Exp)) -}
dace3c5d985b0304af10687f9059c344
  call2 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.CONSTI BackEnd.Munch.call3) -}
14bc44584d11ee6404a4fdb3636b9213
  call3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
7ec709bb4240b6b9a8902657eb31d67b
  call4 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.CONSTI BackEnd.Munch.assemPre6) -}
6f604f167a7f34fdfefa5b2762c0be36
  canlsl ::
    (GHC.Num.Num a, GHC.Classes.Eq a) =>
    BackEnd.IR.BOp -> a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dEq :: GHC.Classes.Eq a)
                   (bop :: BackEnd.IR.BOp)
                   (int :: a) ->
                 case bop of wild {
                   DEFAULT
                   -> case GHC.Classes.==
                             @ a
                             $dEq
                             int
                             (GHC.Num.fromInteger @ a $dNum BackEnd.Munch.canlsl3) of wild1 {
                        GHC.Types.False
                        -> case GHC.Classes.==
                                  @ a
                                  $dEq
                                  int
                                  (GHC.Num.fromInteger @ a $dNum BackEnd.Munch.canlsl2) of wild2 {
                             GHC.Types.False
                             -> GHC.Classes.==
                                  @ a
                                  $dEq
                                  int
                                  (GHC.Num.fromInteger @ a $dNum BackEnd.Munch.canlsl1)
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   BackEnd.IR.MUL -> GHC.Types.False
                   BackEnd.IR.DIV -> GHC.Types.False
                   BackEnd.IR.AND -> GHC.Types.False
                   BackEnd.IR.OR -> GHC.Types.False
                   BackEnd.IR.LSHIFT -> GHC.Types.False
                   BackEnd.IR.RSHIFT -> GHC.Types.False
                   BackEnd.IR.MOD -> GHC.Types.False }) -}
4552d31d8fcc4bfb89843e673810d489
  canlsl1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (8) -}
f4814c88b3b0fa933a0b46019d071239
  canlsl2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
e1baaa48d2ec49f75cc808fb3b87f63a
  canlsl3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
5f07f7b5bf1ab36664003e57b05e118d
  condARM :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.EQ
                   BackEnd.Munch.condARM1) -}
77866dccd91402335ce147d23e022dba
  condARM1 :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.LT
                   BackEnd.Munch.condARM2) -}
355eb079da73ba5815be09c26bc2d20b
  condARM2 :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.LE
                   BackEnd.Munch.condARM3) -}
406a3ba84293f66b4f2ef24d0c895cfa
  condARM3 :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.GT
                   BackEnd.Munch.condARM4) -}
d0cdc8a540893970c348fe8d14a52a63
  condARM4 :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.GE
                   BackEnd.Munch.condARM5) -}
2b0b76e4209d271f4a5afe43c9b8d42b
  condARM5 :: [BackEnd.Instructions.Cond]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.Cond
                   BackEnd.Instructions.NE
                   (GHC.Types.[] @ BackEnd.Instructions.Cond)) -}
b0ea64f920418d59da07a55592677774
  condExp ::
    BackEnd.IR.Exp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         (BackEnd.Instructions.Cond
          -> ([BackEnd.Assem.Instr], BackEnd.Temp.Temp))
  {- Arity: 1, Strictness: <S,1*U> -}
7d95bcb1a8978cbc5704b08934d11b9e
  condIR :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.EQ
                   BackEnd.Munch.condIR1) -}
c813f2b5f505ae6a04293b2ff232dd95
  condIR1 :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.LT
                   BackEnd.Munch.condIR2) -}
fdecd093f97c7166f59f056a4102006c
  condIR2 :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.LE
                   BackEnd.Munch.condIR3) -}
7c397f913111b9f97340083e5398c189
  condIR3 :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.GT
                   BackEnd.Munch.condIR4) -}
bd4ca0247a130429e1a408aa1237a9c6
  condIR4 :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.GE
                   BackEnd.Munch.condIR5) -}
f8465b213092c22c4d93134de1652073
  condIR5 :: [BackEnd.IR.ROp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.ROp
                   BackEnd.IR.NE
                   (GHC.Types.[] @ BackEnd.IR.ROp)) -}
899c16dd3984d3419fae29150fa66d7d
  condStm ::
    BackEnd.IR.Stm
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         (BackEnd.Instructions.Cond -> [BackEnd.Assem.Instr])
  {- Arity: 1, Strictness: <S,1*U> -}
53a355b3d2b5653f2874b92c1082a60b
  createPair ::
    GHC.Base.String
    -> GHC.Base.String
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
deab915c83d78f4ca55fad38c4ac7d09
  deSeq :: BackEnd.IR.Stm -> (BackEnd.IR.Stm, BackEnd.IR.Stm)
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.IR.Stm) ->
                 case ds of wild {
                   DEFAULT -> BackEnd.Munch.deSeq1
                   BackEnd.IR.SEQ s1 s2 -> (s1, s2) }) -}
93acd73bca863f4b1f9b93be024dcef2
  deSeq1 :: (BackEnd.IR.Stm, BackEnd.IR.Stm)
  {- Strictness: x -}
bb4fddea66ed08dfa05693ed9fe670a6
  genBuiltIns :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns144
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns1) -}
a770118af193bb792057a8ce8fcfe614
  genBuiltIns1 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns141
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns2) -}
4ba7009cfed07e93bdf26f4d193c0dad
  genBuiltIns10 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns22
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns11) -}
9e69fe7c58bf1176ed63ba79d2d84a19
  genBuiltIns100 :: [BackEnd.Assem.Instr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns106
                   BackEnd.Munch.genBuiltIns101) -}
710fefe4fbe6ee54b3d0530cf2e1296f
  genBuiltIns101 :: [BackEnd.Assem.Instr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns102
                   (GHC.Types.[] @ BackEnd.Assem.Instr)) -}
92e04ab80f630bf6cfdd6dbea7b91e21
  genBuiltIns102 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns104
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Munch.genBuiltIns103) -}
601b3952465919abb405fc8d7efae621
  genBuiltIns103 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s7
                   (GHC.Types.[] @ GHC.Base.String)) -}
b5171f1039b55d022dca7ef09c724ab2
  genBuiltIns104 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Builtin.end9
                   BackEnd.Munch.genBuiltIns105) -}
105698d73de56cd8440a28d290763833
  genBuiltIns105 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s7) -}
40bcba4a39c095d894fe50625ab80500
  genBuiltIns106 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns107
                   BackEnd.Munch.accessPair10
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
b41f27fb382a9248365c34d524c464c3
  genBuiltIns107 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.MC_
                   BackEnd.Munch.genBuiltIns110
                   BackEnd.Instructions.R0
                   BackEnd.Munch.genBuiltIns108) -}
e8fef3bfa4dd8118852c8b7f41d9330c
  genBuiltIns108 :: BackEnd.Instructions.OP
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.IMM
                   BackEnd.Munch.genBuiltIns109) -}
1ecb9f36c8856803f69e93bea5881282
  genBuiltIns109 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# -1#) -}
8dc8d103279fef204909bac8570dd4a8
  genBuiltIns11 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns12
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   (GHC.Types.[] @ BackEnd.Munch.GenBuiltIn)) -}
fbf8fab1715eede494371c8da101999e
  genBuiltIns110 :: BackEnd.Instructions.Simple
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.MOV BackEnd.Instructions.AL) -}
ff9f196134615256bb753293dedaf09a
  genBuiltIns111 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns113
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Munch.genBuiltIns112) -}
521b50d614af1750219422ee2cdb6e9c
  genBuiltIns112 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s8
                   (GHC.Types.[] @ GHC.Base.String)) -}
a25c214341d526e403be8d8d605b862e
  genBuiltIns113 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Builtin.end9
                   BackEnd.Munch.genBuiltIns114) -}
e96d080e2ce8894d2863073423b0163d
  genBuiltIns114 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s8) -}
dce5c0817a8f7efb34d67471447a50a1
  genBuiltIns115 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns116
                   BackEnd.Munch.genBuiltIns_s1) -}
fc2dd5bf459a4a42ebd8a51d16ec74e8
  genBuiltIns116 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s1) -}
01d43399b4a9ba3b9f7795db48780a9f
  genBuiltIns117 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_check_null_pointer
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
c8e2c515637f9fc41ee670827187823d
  genBuiltIns118 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns74
                   BackEnd.Munch.genBuiltIns26) -}
801e2997b8e4204c33cb73f637d05156
  genBuiltIns119 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns120
                   BackEnd.Munch.accessPair9) -}
c739e1404e57ef5546c15c065a567fff
  genBuiltIns12 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_throw_overflow_error
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
3d0a08c2826b2789238908443a2a7401
  genBuiltIns120 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB BackEnd.Munch.accessPair9) -}
0853b529eecbcac4297c4fa6e5b95898
  genBuiltIns121 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_print_reference w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
de93b760822d48cb6f67651ef571c446
  genBuiltIns122 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# "%p\\192\\128"#) -}
cd3cb25d985c9b11fa232c949daceed6
  genBuiltIns123 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns124
                   BackEnd.Munch.genBuiltIns_s9) -}
de30c469a5d16a193074dbbe2665fbde
  genBuiltIns124 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s9) -}
56f708eba34c9f8705b3be61ea460356
  genBuiltIns125 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_print_string w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
0029c29953ae20ad158e732a94f51f62
  genBuiltIns126 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# "%.*s\\192\\128"#) -}
2368a7d8ad784c4a10567537eb658b3b
  genBuiltIns127 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns128
                   BackEnd.Munch.assemPre3
                   BackEnd.Munch.accessPair10
                   (GHC.Types.[] @ GHC.Base.String)) -}
4dbf1ac81f16e50b8d44bf8b9f3e1f19
  genBuiltIns128 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.CBS_
                   BackEnd.Munch.genBuiltIns130
                   BackEnd.Instructions.R2
                   BackEnd.Instructions.R0
                   BackEnd.Munch.genBuiltIns129) -}
1cfab59da9f90d0635e5329a12cdb246
  genBuiltIns129 :: BackEnd.Instructions.OP
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.IMM BackEnd.Munch.accessPair17) -}
7c04fecadb8b32b68199034fb9f77403
  genBuiltIns13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"#) -}
dfe245c90a9e67b142e2b013691f1bf3
  genBuiltIns130 :: BackEnd.Instructions.Calc
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.ADD
                   BackEnd.Instructions.NoSuffix
                   BackEnd.Instructions.AL) -}
37895e5bb2566d80ce5829f2c02b0974
  genBuiltIns131 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns132
                   BackEnd.Munch.assemPre5
                   BackEnd.Munch.accessPair10) -}
c649047d05ddfc7841f1a434b1269848
  genBuiltIns132 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.Instructions.S_
                   BackEnd.Munch.accessPair6
                   BackEnd.Instructions.R1
                   BackEnd.Munch.genBuiltIns70) -}
a0ce49e372fa8fea95e23a2ec7329fc9
  genBuiltIns133 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns134
                   BackEnd.Munch.genBuiltIns_s8) -}
fa7bfbb60fff79c1127a53d8dbdac0d9
  genBuiltIns134 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s8) -}
2072638cb98aa5a0ee8e1be2f48ee4ef
  genBuiltIns135 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_print_bool w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
bb6de1e726dc12a8ce434a3e803c95a7
  genBuiltIns136 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# "true\\192\\128"#) -}
06b3e6b1e26874e46e67dad74c6f7bdb
  genBuiltIns137 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "false\\192\\128"#) -}
23937d4fee6712bea20679edb17eb6a9
  genBuiltIns138 :: BackEnd.Instructions.SL
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.LDR
                   BackEnd.Instructions.W
                   BackEnd.Instructions.NE) -}
cb4ff86a9bfe21e6a7c55332b97d6f71
  genBuiltIns139 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns140
                   BackEnd.Munch.genBuiltIns_s10) -}
611f57b7d259cc78ff558b19db7a25ee
  genBuiltIns14 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns15
                   (GHC.Types.[] @ BackEnd.Assem.Instr)) -}
60237d2c31c2d5756fc79042ea958705
  genBuiltIns140 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s10) -}
4bf2dabdce0250de972a0f72bc423ea4
  genBuiltIns141 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_print_int w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
ce70773d94bad5a3982dff6b7762cb10
  genBuiltIns142 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns143
                   BackEnd.Munch.genBuiltIns_s11) -}
802c50530ef1dd7d8e84a273d8548074
  genBuiltIns143 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s11) -}
583f4c4dd44ca02e36d60386060cc331
  genBuiltIns144 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_print_ln w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
99e8b055e2a456742f4450bce03b4538
  genBuiltIns145 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# "\\192\\128"#) -}
feb058b252d67d9bc4e7bdf8125eb7ad
  genBuiltIns146 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Builtin.r0_add4
                   BackEnd.Munch.genBuiltIns147) -}
a0cfcd6f9180c15a4d17055f465b7e12
  genBuiltIns147 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns154
                   BackEnd.Munch.genBuiltIns148) -}
e2c84de9f5a297f879ad6344541d3cf5
  genBuiltIns148 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Builtin.r0_clear
                   BackEnd.Munch.genBuiltIns149) -}
d23fb5bf7b3234d37014a83f79520558
  genBuiltIns149 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns150
                   BackEnd.Munch.genBuiltIns26) -}
045852a85d916e976969b2f6508ea996
  genBuiltIns15 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns17
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns16) -}
104be23f7f922202a26db55c26642655
  genBuiltIns150 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns152
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns151) -}
d10a30da24995e4830166422d0180f9b
  genBuiltIns151 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s12
                   (GHC.Types.[] @ GHC.Base.String)) -}
ee0e2c80fff6f293d6adaceab9632083
  genBuiltIns152 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.genBuiltIns153) -}
a760348834929c33336a9a06e5311c85
  genBuiltIns153 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s12) -}
847e2dc196bfa15cff49a56c0b241adf
  genBuiltIns154 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns156
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns155) -}
c150f408a441159a744b6b804070bf03
  genBuiltIns155 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s13
                   (GHC.Types.[] @ GHC.Base.String)) -}
a9c235865abf2b12caaceadb79c156fb
  genBuiltIns156 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.genBuiltIns157) -}
7e0e255d9f405d6db2138900328d0d65
  genBuiltIns157 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s13) -}
38d3332a29d890c322812312d71e8f00
  genBuiltIns158 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns160
                   BackEnd.Munch.genBuiltIns159) -}
b2671df7129dbf19f8a3d7cefe611c9a
  genBuiltIns159 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "p_print_ln"#) -}
177388da931fde30eaeb6d14235e6e1c
  genBuiltIns16 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s
                   (GHC.Types.[] @ GHC.Base.String)) -}
e7ab15c9fe4562aafe1727a581c3cd22
  genBuiltIns160 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns159) -}
3a7fd56b2569efa785faa7486bfa2186
  genBuiltIns17 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.genBuiltIns18) -}
44df6c59be0437cc6a58ff88afa07ce2
  genBuiltIns18 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_ BackEnd.Munch.genBuiltIns_s) -}
fc3b3d854a00f65b89bdd29ee2755caa
  genBuiltIns19 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns21
                   BackEnd.Munch.genBuiltIns20) -}
17046bfec5f4f4defd0351fde3ca7736
  genBuiltIns2 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns135
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns3) -}
fd446c6f557919887ea3150ec4e838de
  genBuiltIns20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "p_throw_overflow_error"#) -}
91fc3e73d3e60b0fcf34561023cf7952
  genBuiltIns21 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns20) -}
308f173ddd9f3b34a4b8028b18565a83
  genBuiltIns22 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_check_array_bounds
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
15c088a4db0bbd08f2c4f43d8bec54fd
  genBuiltIns23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "ArrayIndexOutOfBoundsError: negative index\n\
                   \\\192\\128"#) -}
a95f4d983fa6088dd068408fc456dbcd
  genBuiltIns24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "ArrayIndexOutOfBoundsError: index too large\n\
                   \\\192\\128"#) -}
ec314d5d841bc3dda2fc0db0c1727ef9
  genBuiltIns25 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns27
                   BackEnd.Munch.genBuiltIns26) -}
a7685af342f8b50a8e3072aa31f9c74c
  genBuiltIns26 :: [BackEnd.Assem.Instr]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Builtin.poppc
                   (GHC.Types.[] @ BackEnd.Assem.Instr)) -}
a0175d5d257c66d221ed0b679d3f9835
  genBuiltIns27 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns29
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns28) -}
7216d7fd6d097200e54887989125a4c8
  genBuiltIns28 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s1
                   (GHC.Types.[] @ GHC.Base.String)) -}
4bee316114444685ae99e4b747e6ce48
  genBuiltIns29 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.genBuiltIns31
                   BackEnd.Munch.genBuiltIns30) -}
50cd47f2307c6e8a77e8cb7d54c9c304
  genBuiltIns3 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns125
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns4) -}
3e356ab24335be654da710a1a0ccc9e4
  genBuiltIns30 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s1) -}
bf7850929f2266697af13b4121571ab0
  genBuiltIns31 :: BackEnd.Instructions.Branch
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.BL BackEnd.Instructions.CS) -}
d818e41982c83e73202258d21fe0da5e
  genBuiltIns32 :: BackEnd.Instructions.SL
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.LDR
                   BackEnd.Instructions.W
                   BackEnd.Instructions.CS) -}
58fc0c091ba2371d047594972a02e241
  genBuiltIns33 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns34
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns28) -}
62b134bbc99e7582e36c315245303177
  genBuiltIns34 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.genBuiltIns35
                   BackEnd.Munch.genBuiltIns30) -}
40fd83456286583745553b13910ce695
  genBuiltIns35 :: BackEnd.Instructions.Branch
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.BL BackEnd.Instructions.LT) -}
5f3c81bafaf9f9b0434cdf5e4207ae2f
  genBuiltIns36 :: BackEnd.Instructions.SL
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.LDR
                   BackEnd.Instructions.W
                   BackEnd.Instructions.LT) -}
0e47526e9ce04277bed5d6343e7bd9fd
  genBuiltIns37 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns39
                   BackEnd.Munch.genBuiltIns38) -}
5ce59f916c2f223b1233939b9b1f0740
  genBuiltIns38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "p_check_array_bounds"#) -}
e5f8fb4c5d3e525756cca1428b143c18
  genBuiltIns39 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns38) -}
4577b789f41ca9676193605bb69862c5
  genBuiltIns4 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns121
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns5) -}
34b1051f10a573ae3bac9149cb1b7ed1
  genBuiltIns40 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_free_pair w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
bfccefff70b13c46ba07e38e250496b1
  genBuiltIns41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "NullReferenceError: dereference a null reference\n\
                   \\\192\\128"#) -}
bcefca2ea482435847f062b1c8e93e33
  genBuiltIns42 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns74
                   BackEnd.Munch.genBuiltIns43) -}
296ebbd9c4fdc901aa07d7026b8b1de1
  genBuiltIns43 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns71
                   BackEnd.Munch.genBuiltIns44) -}
2d2ede7c463ddeb33ac1f5f53eefaded
  genBuiltIns44 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns68
                   BackEnd.Munch.genBuiltIns45) -}
9622179c89be631a2cbc46c826b8ea32
  genBuiltIns45 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns51
                   BackEnd.Munch.genBuiltIns46) -}
0a0449b2f898de90aee5c8e48a2f0510
  genBuiltIns46 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns64
                   BackEnd.Munch.genBuiltIns47) -}
97ae035181297c3eb2b236642ee7abf4
  genBuiltIns47 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns61
                   BackEnd.Munch.genBuiltIns48) -}
99b6ffe43e3e95c5420f13ea0566a7d2
  genBuiltIns48 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns51
                   BackEnd.Munch.genBuiltIns49) -}
9cd933583ddbc2d454dc07247ee85a64
  genBuiltIns49 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns55
                   BackEnd.Munch.genBuiltIns50) -}
db1acf87f1940f092c5d79ed9e43f009
  genBuiltIns5 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns117
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns6) -}
420633c231c068c30784c63e61ef0867
  genBuiltIns50 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns51
                   BackEnd.Munch.genBuiltIns26) -}
f85e7f80420e78e1a8957dba0da21078
  genBuiltIns51 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns53
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns52) -}
1b204e60c117795f414638bf631e5a33
  genBuiltIns52 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s2
                   (GHC.Types.[] @ GHC.Base.String)) -}
7e0b772545e37e9169d85106b75cdf2e
  genBuiltIns53 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.genBuiltIns54) -}
bd47c0415b2d5a6922426ee265cdb41a
  genBuiltIns54 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s2) -}
52576e6c6d4b4973b26d794a6bd7851e
  genBuiltIns55 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns58
                   BackEnd.Munch.genBuiltIns57
                   BackEnd.Munch.genBuiltIns56
                   (GHC.Types.[] @ GHC.Base.String)) -}
1b40060da2632e31147b081e90b93d47
  genBuiltIns56 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Frame.fp
                   (GHC.Types.[] @ BackEnd.Temp.Temp)) -}
f6abd5f621f85af2874c43d3016b074d
  genBuiltIns57 :: [BackEnd.Temp.Temp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Temp.Temp
                   BackEnd.Frame.fp
                   BackEnd.Munch.accessPair10) -}
fd4bca4a941fbb8966650756baa965f7
  genBuiltIns58 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (BackEnd.Instructions.STACK_
                   BackEnd.Munch.genBuiltIns60
                   BackEnd.Munch.genBuiltIns59) -}
aade4f8fdf74d07467d1eade9c36d8e3
  genBuiltIns59 :: [BackEnd.Instructions.REG]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Instructions.REG
                   BackEnd.Instructions.R0
                   (GHC.Types.[] @ BackEnd.Instructions.REG)) -}
b292749fc3d380f9a124907e3f7bb55d
  genBuiltIns6 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns97
                     `cast`
                   (Trans
                        (<BackEnd.Translate.TranslateState>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <([BackEnd.Assem.Instr],
                                         BackEnd.Translate.TranslateState)>_R))
                        (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <BackEnd.Translate.TranslateState>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <[BackEnd.Assem.Instr]>_N)))
                   BackEnd.Munch.genBuiltIns7) -}
40f15b4ad4d577206fde5f5b6edb98d3
  genBuiltIns60 :: BackEnd.Instructions.StackOP
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.POP BackEnd.Instructions.AL) -}
b1d53568c6e693a328b789d1f7b02e7e
  genBuiltIns61 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns62
                   BackEnd.Munch.accessPair10
                   BackEnd.Munch.accessPair10) -}
abe9cac48ad7fd830d946decf4c7a65f
  genBuiltIns62 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.Instructions.S_
                   BackEnd.Munch.accessPair6
                   BackEnd.Instructions.R0
                   BackEnd.Munch.genBuiltIns63) -}
ef225d0fae1531f7f53cf0ca527d00a0
  genBuiltIns63 :: BackEnd.Instructions.SLOP2
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Instructions.Imm
                   BackEnd.Instructions.R0
                   BackEnd.Munch.accessPair17) -}
79fd13d16d4ac8c4580ee48123444716
  genBuiltIns64 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns65
                   BackEnd.Munch.accessPair10
                   BackEnd.Munch.genBuiltIns56) -}
e9655f55679f8a7c0fb50079f6c077e2
  genBuiltIns65 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.Instructions.S_
                   BackEnd.Munch.accessPair6
                   BackEnd.Instructions.R0
                   BackEnd.Munch.genBuiltIns66) -}
f4811698c061e17e2534d682ad5c3b78
  genBuiltIns66 :: BackEnd.Instructions.SLOP2
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Instructions.Imm
                   BackEnd.Munch.genBuiltIns67
                   BackEnd.Munch.accessPair4) -}
539a7a0fb84b1a0cf30dece695d6bdc7
  genBuiltIns67 :: BackEnd.Instructions.REG
  {- HasNoCafRefs, Strictness: m17,
     Unfolding: (BackEnd.Instructions.RTEMP BackEnd.Frame.fp) -}
13b525318439da146b7d01b82741dc0c
  genBuiltIns68 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns69
                   BackEnd.Munch.accessPair10
                   BackEnd.Munch.accessPair10) -}
b11bb1987fc9e50712ac8e08a2fb291f
  genBuiltIns69 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.Instructions.S_
                   BackEnd.Munch.accessPair6
                   BackEnd.Instructions.R0
                   BackEnd.Munch.genBuiltIns70) -}
92a42a31174ee66317df445d24adb60d
  genBuiltIns7 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns93
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns8) -}
2af33299bdc9104329f2e5ee37170c68
  genBuiltIns70 :: BackEnd.Instructions.SLOP2
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Instructions.Imm
                   BackEnd.Instructions.R0
                   BackEnd.Munch.accessPair4) -}
772d883072c5c182c3b4164220597f1a
  genBuiltIns71 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns72
                   BackEnd.Munch.genBuiltIns56
                   BackEnd.Munch.accessPair10
                   (GHC.Types.[] @ GHC.Base.String)) -}
b330ebf199221993ecac559aaf64027a
  genBuiltIns72 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (BackEnd.Instructions.STACK_
                   BackEnd.Munch.genBuiltIns73
                   BackEnd.Munch.genBuiltIns59) -}
643792cbaa84915aec763bc656f1704b
  genBuiltIns73 :: BackEnd.Instructions.StackOP
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.PUSH BackEnd.Instructions.AL) -}
ba1c6d5e72e6b5ce9504d8ac0e064f04
  genBuiltIns74 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns75
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns28) -}
ec5510f72de9dac40ab00f480829a124
  genBuiltIns75 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.genBuiltIns76
                   BackEnd.Munch.genBuiltIns30) -}
199188bde71426e618e51c6750769c0c
  genBuiltIns76 :: BackEnd.Instructions.Branch
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.BL BackEnd.Instructions.EQ) -}
4898817aabd1ad2d77374dd8ab79cd0c
  genBuiltIns77 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns78
                   BackEnd.Munch.genBuiltIns_s3) -}
7644539c1cc5debbffe961f011c2c0c6
  genBuiltIns78 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s3) -}
30e84bc97d7daf027b317abba3fc7234
  genBuiltIns79 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U(U(U)),U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
                   = BackEnd.Munch.genBuiltIns83 BackEnd.Munch.genBuiltIns82 s1
                 } in
                 (GHC.Types.:
                    @ BackEnd.Assem.Instr
                    BackEnd.Munch.genBuiltIns80
                    (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <([BackEnd.Assem.Instr],
                                 BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                     a1 }),
                  case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <([BackEnd.Assem.Instr],
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)>_R))) -}
027531d2c317e1e079268f2386f0f6e6
  genBuiltIns8 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns79
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns9) -}
7f7cb869908d1cb81ac13dd8bb32f14c
  genBuiltIns80 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns81
                   BackEnd.Munch.genBuiltIns_s4) -}
0576744bb806761825a2a7b649518ff3
  genBuiltIns81 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s4) -}
be6ac5212435f920c9baf8754a3772d8
  genBuiltIns82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# " %c\\192\\128"#) -}
717c85843c9a9d1cd002d389fe199439
  genBuiltIns83 ::
    GHC.Base.String
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_read w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
282c0c652fefdea5ffdfbeaabad810c6
  genBuiltIns84 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Builtin.r0_add4
                   BackEnd.Munch.genBuiltIns85) -}
a62bdf18e63bf91782e2a1c35c5649b1
  genBuiltIns85 :: [BackEnd.Assem.Instr]
  {- Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns86
                   BackEnd.Munch.genBuiltIns26) -}
f84407328220c1c2d0375f3d633cbd39
  genBuiltIns86 :: BackEnd.Assem.Instr
  {- Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.genBuiltIns88
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Builtin.cmp_r1
                   BackEnd.Munch.genBuiltIns87) -}
7a8de72bad8a0120ffddd9ba3bf0a92e
  genBuiltIns87 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BackEnd.Munch.genBuiltIns_s5
                   (GHC.Types.[] @ GHC.Base.String)) -}
a1dd7af24a5895697e4a73d8a7a98ecf
  genBuiltIns88 :: BackEnd.Instructions.Instr
  {- Strictness: m3,
     Unfolding: (BackEnd.Instructions.BRANCH_
                   BackEnd.Munch.accessPair13
                   BackEnd.Munch.genBuiltIns89) -}
dfa1a59554916e8eb34ee49f5c8ecd3c
  genBuiltIns89 :: BackEnd.Instructions.Lable
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.L_
                   BackEnd.Munch.genBuiltIns_s5) -}
9d02c97acfc11e0eec807bf8a1a5bbf9
  genBuiltIns9 :: [BackEnd.Munch.GenBuiltIn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Munch.GenBuiltIn
                   BackEnd.Munch.genBuiltIns40
                     `cast`
                   (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Munch.genBuiltIns10) -}
97e3801cd903d4c7f7c690bb96fe4d23
  genBuiltIns90 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (BackEnd.Assem.IMOV
                   BackEnd.Munch.genBuiltIns91
                   BackEnd.Munch.assemPre5
                   BackEnd.Munch.accessPair10) -}
e06f9e68c947a370929d6af21f3c6212
  genBuiltIns91 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.MC_
                   BackEnd.Builtin.r0_clear2
                   BackEnd.Munch.assemPre9
                   BackEnd.Munch.genBuiltIns92) -}
bd0f7a854de76ed5ff612f96cfce074a
  genBuiltIns92 :: BackEnd.Instructions.OP
  {- HasNoCafRefs,
     Unfolding: (BackEnd.Instructions.R BackEnd.Munch.accessPair14) -}
1a66d29279450a8b1877f8690a951f44
  genBuiltIns93 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U(U(U)),U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
                   = BackEnd.Munch.genBuiltIns83 BackEnd.Munch.genBuiltIns96 s1
                 } in
                 (GHC.Types.:
                    @ BackEnd.Assem.Instr
                    BackEnd.Munch.genBuiltIns94
                    (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <([BackEnd.Assem.Instr],
                                 BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                     a1 }),
                  case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <([BackEnd.Assem.Instr],
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)>_R))) -}
0c042d8c62318c987370ce7da28613fe
  genBuiltIns94 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.genBuiltIns95
                   BackEnd.Munch.genBuiltIns_s6) -}
67fb815d749afa0d42695bad052ef20c
  genBuiltIns95 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.genBuiltIns_s6) -}
5c87919afdab0dab6e12ae0a05fdca6d
  genBuiltIns96 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# "%d\\192\\128"#) -}
9458d6aa006973557dc49f152015a32e
  genBuiltIns97 ::
    BackEnd.Translate.TranslateState
    -> ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (eta1 :: BackEnd.Translate.TranslateState) ->
                 (BackEnd.Munch.genBuiltIns98, eta1)) -}
cb1273c1cef2bcb3d9ae46b77b212f37
  genBuiltIns98 :: [BackEnd.Assem.Instr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns115
                   BackEnd.Munch.genBuiltIns99) -}
558969029486f18b4c341982b061448f
  genBuiltIns99 :: [BackEnd.Assem.Instr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.Assem.Instr
                   BackEnd.Munch.genBuiltIns111
                   BackEnd.Munch.genBuiltIns100) -}
bca2050dfe787eb154bec17f50d2da10
  genBuiltIns_s :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "BL p_throw_runtime_error"#) -}
f7cd4763ef2aa4aa405e973a79cc2c2c
  genBuiltIns_s1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "p_throw_runtime_error"#) -}
1aa3aa8c357228d36343a2660efb16bc
  genBuiltIns_s10 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_print_bool"#) -}
a06821ef6f5bcf47ad7d03932b424398
  genBuiltIns_s11 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_print_int"#) -}
24ca433f5cec628ded40d8d0646c2b8c
  genBuiltIns_s12 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "fflush"#) -}
5616ac1e9c56c407229887f36fe0bb7f
  genBuiltIns_s13 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "puts"#) -}
506ccf881b29682ecc932a5332368208
  genBuiltIns_s2 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "free"#) -}
4b4b21d3230845d21e58432f36118b1e
  genBuiltIns_s3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_free_pair"#) -}
ca23e94e976dbf5bc3909ea1d81463dd
  genBuiltIns_s4 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_read_char"#) -}
255ba0181e47712b62c905e5f12c3844
  genBuiltIns_s5 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "scanf"#) -}
2e50ce0130c7ef0634ce54899872fe03
  genBuiltIns_s6 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_read_int"#) -}
64e0e021cb0091ea9024d66c9586d14e
  genBuiltIns_s7 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "exit"#) -}
20cc632d8ef5627f041bb0b1eb333b54
  genBuiltIns_s8 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_print_string"#) -}
372c47e7b422f3e7bd2c88cbe8837b77
  genBuiltIns_s9 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "p_print_reference"#) -}
daa1b976d2e1728a53e3c6b700c34919
  invert :: BackEnd.IR.ROp -> BackEnd.Instructions.Cond
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: BackEnd.IR.ROp) ->
                 case GHC.List.lookup
                        @ BackEnd.IR.ROp
                        @ BackEnd.Instructions.Cond
                        BackEnd.IR.$fEqROp
                        a
                        BackEnd.Munch.invert1 of wild {
                   GHC.Base.Nothing
                   -> Data.Maybe.fromJust1 @ BackEnd.Instructions.Cond
                   GHC.Base.Just x -> x }) -}
e3f11f5c49447ef16bc02c9a3ab55e31
  invert1 :: [(BackEnd.IR.ROp, BackEnd.Instructions.Cond)]
  {- Unfolding: (GHC.List.zip
                   @ BackEnd.IR.ROp
                   @ BackEnd.Instructions.Cond
                   BackEnd.Munch.condIR
                   BackEnd.Munch.invert2) -}
da0c7b9cf5323e8387e0d56df97b2848
  invert2 :: [BackEnd.Instructions.Cond]
  {- Unfolding: (GHC.List.reverse1
                   @ BackEnd.Instructions.Cond
                   BackEnd.Munch.condARM
                   (GHC.Types.[] @ BackEnd.Instructions.Cond)) -}
473891d8e22f8bfe9499a87b8130ca97
  irPre :: BackEnd.IR.Stm
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.MOV
                   BackEnd.Munch.irPre3
                   BackEnd.Munch.irPre1) -}
0a622396b5ce962ce5890623bb4eeb38
  irPre1 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.IR.MEM BackEnd.Munch.irPre2) -}
2d42ebe894e66afe73c08ee539e640cf
  irPre2 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Munch.assemPre4) -}
db6bdbc27215471c768eb76ad0af1d62
  irPre3 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (BackEnd.IR.BINEXP
                   BackEnd.IR.MINUS
                   BackEnd.Munch.irPre2
                   BackEnd.Munch.call4) -}
623247e77a5e8b12c616b16031bf8f2e
  justret ::
    BackEnd.IR.Exp
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (e :: BackEnd.IR.Exp) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           BackEnd.Translate.TranslateState
                           Data.Functor.Identity.Identity
                           ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
                   = BackEnd.Munch.munchExp e
                 } in
                 (\ (s1 :: BackEnd.Translate.TranslateState) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  case a1 of wild1 { (,) i t ->
                  (wild1, s')
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                              BackEnd.Translate.TranslateState)>_R)) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <BackEnd.Translate.TranslateState>_N
                           <Data.Functor.Identity.Identity>_R
                           <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N))) -}
4b7dfff295ccbc6ba76899ca268c8ae4
  load1b :: BackEnd.IR.Stm
  {- Strictness: m1,
     Unfolding: (BackEnd.IR.MOV
                   BackEnd.Munch.irPre2
                   BackEnd.Munch.load1b1) -}
b50c5df5d5c0195105ee0fdbaab5d258
  load1b1 :: BackEnd.IR.Exp
  {- Strictness: m7,
     Unfolding: (BackEnd.IR.CALL
                   BackEnd.Munch.load1b4
                   BackEnd.Munch.load1b2) -}
b1dd2a2ed13e27c70a4875a4a72aa80b
  load1b2 :: [BackEnd.IR.Exp]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ BackEnd.IR.Exp
                   BackEnd.Munch.load1b3
                   (GHC.Types.[] @ BackEnd.IR.Exp)) -}
5337762631737531e6af3b6fe497c157
  load1b3 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (BackEnd.IR.MEM BackEnd.Munch.call4) -}
c14e83cbc8351da708c4858703881f1e
  load1b4 :: BackEnd.IR.Exp
  {- Strictness: m3,
     Unfolding: (BackEnd.IR.NAME BackEnd.Munch.load1b5) -}
ecd1e1c87b7fa438aab8b5bc1d6f7d74
  load1b5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#oneByte"#) -}
ed1506ac413a1fb35f03c8c1750af65e
  log1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
4dd212a0c4d34fcec5a16e23ee99e358
  log2 :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# ds1 ->
                 case ds1 of ds2 {
                   DEFAULT -> BackEnd.Munch.log3
                   2# -> BackEnd.Munch.assemPre6
                   4# -> BackEnd.Munch.assemPre4
                   8# -> BackEnd.Munch.log1 } }) -}
c642a5985b26eaa4b809f1ea784a23df
  log3 :: GHC.Types.Int
  {- Strictness: x -}
61a8a625a0932a43ca0fd1ac8717bd1f
  lslOP ::
    BackEnd.IR.Exp
    -> BackEnd.IR.Exp
    -> BackEnd.IR.BOp
    -> GHC.Types.Int
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         (BackEnd.Instructions.Cond
          -> ([BackEnd.Assem.Instr], BackEnd.Temp.Temp))
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,1*U(1*U)>,
     Unfolding: (\ (e1 :: BackEnd.IR.Exp)
                   (e2 :: BackEnd.IR.Exp)
                   (bop :: BackEnd.IR.BOp)
                   (int :: GHC.Types.Int) ->
                 let {
                   lvl86 :: Control.Monad.Trans.State.Lazy.State
                              BackEnd.Translate.TranslateState
                              ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
                   = BackEnd.Munch.munchExp e2
                 } in
                 let {
                   lvl87 :: GHC.Types.Int
                   = case int of wild { GHC.Types.I# ds ->
                     case ds of ds1 {
                       DEFAULT -> BackEnd.Munch.log3
                       2# -> BackEnd.Munch.assemPre6
                       4# -> BackEnd.Munch.assemPre4
                       8# -> BackEnd.Munch.log1 } }
                 } in
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           BackEnd.Translate.TranslateState
                           Data.Functor.Identity.Identity
                           ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
                   = BackEnd.Munch.munchExp e1
                 } in
                 (\ (s1 :: BackEnd.Translate.TranslateState) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  case a1 of wild1 { (,) i1 t1 ->
                  case (lvl86
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <BackEnd.Translate.TranslateState>_N
                             <Data.Functor.Identity.Identity>_R
                             <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                          s')
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                              BackEnd.Translate.TranslateState)>_R) of wild2 { (,) a2 s'1 ->
                  case a2 of wild3 { (,) i2 t2 ->
                  let {
                    lvl88 :: BackEnd.Instructions.REG = BackEnd.Instructions.RTEMP t1
                  } in
                  let {
                    lvl89 :: [BackEnd.Temp.Temp]
                    = GHC.Types.:
                        @ BackEnd.Temp.Temp
                        t1
                        (GHC.Types.[] @ BackEnd.Temp.Temp)
                  } in
                  let {
                    lvl90 :: BackEnd.Instructions.REG = BackEnd.Instructions.RTEMP t2
                  } in
                  let {
                    lvl91 :: BackEnd.Instructions.OP
                    = BackEnd.Instructions.LSL_ lvl90 lvl87
                  } in
                  let {
                    lvl92 :: [BackEnd.Temp.Temp]
                    = GHC.Types.:
                        @ BackEnd.Temp.Temp
                        t2
                        (GHC.Types.[] @ BackEnd.Temp.Temp)
                  } in
                  (\ (c :: BackEnd.Instructions.Cond) ->
                   (GHC.Base.++
                      @ BackEnd.Assem.Instr
                      i1
                      (GHC.Base.++
                         @ BackEnd.Assem.Instr
                         i2
                         (GHC.Types.:
                            @ BackEnd.Assem.Instr
                            (BackEnd.Assem.IOPER
                               (BackEnd.Instructions.CBS_
                                  (case bop of wild4 {
                                     DEFAULT
                                     -> case BackEnd.Munch.addsubtoCalc1
                                        ret_ty BackEnd.Instructions.Calc
                                        of {}
                                     BackEnd.IR.PLUS
                                     -> BackEnd.Instructions.ADD BackEnd.Instructions.NoSuffix c
                                     BackEnd.IR.MINUS
                                     -> BackEnd.Instructions.SUB BackEnd.Instructions.NoSuffix c })
                                  lvl88
                                  lvl88
                                  lvl91)
                               lvl89
                               lvl92
                               (GHC.Types.[] @ GHC.Base.String))
                            (GHC.Types.[] @ BackEnd.Assem.Instr))),
                    t1),
                   s'1)
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(BackEnd.Instructions.Cond
                              -> ([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                              BackEnd.Translate.TranslateState)>_R)) } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <BackEnd.Translate.TranslateState>_N
                           <Data.Functor.Identity.Identity>_R
                           <BackEnd.Instructions.Cond
                            -> ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N))) -}
3564db838148a2b5dedf9fd91904d9ca
  munch :: GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.munch1
                  `cast`
                (<GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
716aacc24197ee21e793604aa5dbc848
  munch1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U> -}
1ba94468189fff3ef3ab8ead1a9228c9
  munchBuiltInFuncFrag ::
    BackEnd.Frame.Fragment
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState [BackEnd.Assem.Instr]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: BackEnd.Frame.Fragment) ->
                 case ds of wild {
                   BackEnd.Frame.PROC stm frame
                   -> let {
                        m1 :: Control.Monad.Trans.State.Lazy.StateT
                                BackEnd.Translate.TranslateState
                                Data.Functor.Identity.Identity
                                [BackEnd.Assem.Instr]
                        = BackEnd.Munch.munchStm stm
                      } in
                      (\ (s1 :: BackEnd.Translate.TranslateState) ->
                       let {
                         ds1 :: Data.Functor.Identity.Identity
                                  ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
                         = m1
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <BackEnd.Translate.TranslateState>_N
                                <Data.Functor.Identity.Identity>_R
                                <[BackEnd.Assem.Instr]>_N)
                             s1
                       } in
                       (GHC.Types.:
                          @ BackEnd.Assem.Instr
                          BackEnd.Builtin.pushlr
                          (case ds1
                                  `cast`
                                (Data.Functor.Identity.N:Identity[0]
                                     <([BackEnd.Assem.Instr],
                                       BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                           GHC.Base.++
                             @ BackEnd.Assem.Instr
                             a1
                             BackEnd.Munch.genBuiltIns26 }),
                        case ds1
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <([BackEnd.Assem.Instr],
                                    BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                        s' })
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)>_R)))
                        `cast`
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <BackEnd.Translate.TranslateState>_N
                                <Data.Functor.Identity.Identity>_R
                                <[BackEnd.Assem.Instr]>_N))
                   BackEnd.Frame.STRING ipv ipv1
                   -> BackEnd.Munch.munchBuiltInFuncFrag1 }) -}
fdc52c3ec53dd93f6cf79ebef35b7331
  munchBuiltInFuncFrag1 ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState [BackEnd.Assem.Instr]
  {- Strictness: x -}
1eb6a57eae538355929ed6fa1fd7fc41
  munchDataFrag :: BackEnd.Frame.Fragment -> [BackEnd.Assem.Instr]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Frame.Fragment) ->
                 case w of wild {
                   BackEnd.Frame.PROC ipv ipv1 -> BackEnd.Munch.munchDataFrag1
                   BackEnd.Frame.STRING label str
                   -> GHC.Types.:
                        @ BackEnd.Assem.Instr
                        (BackEnd.Assem.ILABEL
                           (BackEnd.Instructions.M
                              label
                              (case GHC.List.$wlenAcc @ GHC.Types.Char str 0# of ww2 { DEFAULT ->
                               GHC.Types.I# ww2 })
                              str)
                           label)
                        (GHC.Types.[] @ BackEnd.Assem.Instr) }) -}
d2a92188e25376962eb09572ba99894f
  munchDataFrag1 :: [BackEnd.Assem.Instr]
  {- Strictness: x -}
cad4e4521f6ef50ae2dfd972e4e3d824
  munchExp ::
    BackEnd.IR.Exp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Arity: 1, Strictness: <S,U> -}
76f499045c27a65cd88a09107463c2b3
  munchMem ::
    BackEnd.IR.Exp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         ([BackEnd.Assem.Instr], [GHC.Types.Int],
          BackEnd.Instructions.SLOP2)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: BackEnd.IR.Exp) ->
                 let {
                   fail2 :: GHC.Prim.Void#
                            -> Control.Monad.Trans.State.Lazy.StateT
                                 BackEnd.Translate.TranslateState
                                 Data.Functor.Identity.Identity
                                 ([BackEnd.Assem.Instr], [GHC.Types.Int],
                                  BackEnd.Instructions.SLOP2)
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       m1 :: Control.Monad.Trans.State.Lazy.StateT
                               BackEnd.Translate.TranslateState
                               Data.Functor.Identity.Identity
                               ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
                       = BackEnd.Munch.munchExp ds
                     } in
                     (\ (s1 :: BackEnd.Translate.TranslateState) ->
                      case (m1
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <BackEnd.Translate.TranslateState>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                              s1)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                                  BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                      case a1 of wild1 { (,) i t ->
                      ((i,
                        GHC.Types.:
                          @ BackEnd.Temp.Temp
                          t
                          (GHC.Types.[] @ BackEnd.Temp.Temp),
                        BackEnd.Munch.munchMem1),
                       s')
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                   BackEnd.Instructions.SLOP2),
                                  BackEnd.Translate.TranslateState)>_R)) } })
                       `cast`
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <([BackEnd.Assem.Instr], [GHC.Types.Int],
                                 BackEnd.Instructions.SLOP2)>_N))
                 } in
                 case ds of wild {
                   DEFAULT -> fail2 GHC.Prim.void#
                   BackEnd.IR.CONSTI int
                   -> let {
                        eta :: BackEnd.Instructions.SLOP2 = BackEnd.Instructions.NUM int
                      } in
                      let {
                        eta1 :: ([BackEnd.Assem.Instr], [GHC.Types.Int],
                                 BackEnd.Instructions.SLOP2)
                          {- Strictness: m -}
                        = (GHC.Types.[] @ BackEnd.Assem.Instr,
                           GHC.Types.[] @ GHC.Types.Int, eta)
                      } in
                      (\ (eta2 :: BackEnd.Translate.TranslateState) -> (eta1, eta2))
                        `cast`
                      (Trans
                           (<BackEnd.Translate.TranslateState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(([BackEnd.Assem.Instr], [GHC.Types.Int],
                                             BackEnd.Instructions.SLOP2),
                                            BackEnd.Translate.TranslateState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <BackEnd.Translate.TranslateState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <([BackEnd.Assem.Instr], [GHC.Types.Int],
                                       BackEnd.Instructions.SLOP2)>_N)))
                   BackEnd.IR.TEMP t
                   -> let {
                        eta :: [BackEnd.Temp.Temp]
                        = GHC.Types.:
                            @ BackEnd.Temp.Temp
                            t
                            (GHC.Types.[] @ BackEnd.Temp.Temp)
                      } in
                      let {
                        eta1 :: BackEnd.Instructions.REG = BackEnd.Instructions.RTEMP t
                      } in
                      let {
                        eta2 :: BackEnd.Instructions.SLOP2
                        = BackEnd.Instructions.Imm eta1 BackEnd.Munch.accessPair4
                      } in
                      let {
                        eta3 :: ([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                 BackEnd.Instructions.SLOP2)
                          {- Strictness: m -}
                        = (GHC.Types.[] @ BackEnd.Assem.Instr, eta, eta2)
                      } in
                      (\ (eta4 :: BackEnd.Translate.TranslateState) -> (eta3, eta4))
                        `cast`
                      (Trans
                           (<BackEnd.Translate.TranslateState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                             BackEnd.Instructions.SLOP2),
                                            BackEnd.Translate.TranslateState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <BackEnd.Translate.TranslateState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                       BackEnd.Instructions.SLOP2)>_N)))
                   BackEnd.IR.BINEXP ds1 ds2 ds3
                   -> case ds1 of wild1 {
                        DEFAULT -> fail2 GHC.Prim.void#
                        BackEnd.IR.PLUS
                        -> case ds2 of wild2 {
                             DEFAULT -> fail2 GHC.Prim.void#
                             BackEnd.IR.CONSTI int
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail2 GHC.Prim.void#
                                  BackEnd.IR.TEMP t
                                  -> let {
                                       eta :: [BackEnd.Temp.Temp]
                                       = GHC.Types.:
                                           @ BackEnd.Temp.Temp
                                           t
                                           (GHC.Types.[] @ BackEnd.Temp.Temp)
                                     } in
                                     let {
                                       eta1 :: BackEnd.Instructions.REG
                                       = BackEnd.Instructions.RTEMP t
                                     } in
                                     let {
                                       eta2 :: BackEnd.Instructions.SLOP2
                                       = BackEnd.Instructions.Imm eta1 int
                                     } in
                                     let {
                                       eta3 :: ([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                BackEnd.Instructions.SLOP2)
                                         {- Strictness: m -}
                                       = (GHC.Types.[] @ BackEnd.Assem.Instr, eta, eta2)
                                     } in
                                     (\ (eta4 :: BackEnd.Translate.TranslateState) -> (eta3, eta4))
                                       `cast`
                                     (Trans
                                          (<BackEnd.Translate.TranslateState>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <(([BackEnd.Assem.Instr],
                                                            [BackEnd.Temp.Temp],
                                                            BackEnd.Instructions.SLOP2),
                                                           BackEnd.Translate.TranslateState)>_R))
                                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                    <BackEnd.Translate.TranslateState>_N
                                                    <Data.Functor.Identity.Identity>_R
                                                    <([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                      BackEnd.Instructions.SLOP2)>_N))) }
                             BackEnd.IR.TEMP t
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail2 GHC.Prim.void#
                                  BackEnd.IR.CONSTI int
                                  -> let {
                                       eta :: [BackEnd.Temp.Temp]
                                       = GHC.Types.:
                                           @ BackEnd.Temp.Temp
                                           t
                                           (GHC.Types.[] @ BackEnd.Temp.Temp)
                                     } in
                                     let {
                                       eta1 :: BackEnd.Instructions.REG
                                       = BackEnd.Instructions.RTEMP t
                                     } in
                                     let {
                                       eta2 :: BackEnd.Instructions.SLOP2
                                       = BackEnd.Instructions.Imm eta1 int
                                     } in
                                     let {
                                       eta3 :: ([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                BackEnd.Instructions.SLOP2)
                                         {- Strictness: m -}
                                       = (GHC.Types.[] @ BackEnd.Assem.Instr, eta, eta2)
                                     } in
                                     (\ (eta4 :: BackEnd.Translate.TranslateState) -> (eta3, eta4))
                                       `cast`
                                     (Trans
                                          (<BackEnd.Translate.TranslateState>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <(([BackEnd.Assem.Instr],
                                                            [BackEnd.Temp.Temp],
                                                            BackEnd.Instructions.SLOP2),
                                                           BackEnd.Translate.TranslateState)>_R))
                                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                    <BackEnd.Translate.TranslateState>_N
                                                    <Data.Functor.Identity.Identity>_R
                                                    <([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                      BackEnd.Instructions.SLOP2)>_N))) } }
                        BackEnd.IR.MINUS
                        -> case ds2 of wild2 {
                             DEFAULT -> fail2 GHC.Prim.void#
                             BackEnd.IR.TEMP t
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail2 GHC.Prim.void#
                                  BackEnd.IR.CONSTI int
                                  -> let {
                                       eta :: [BackEnd.Temp.Temp]
                                       = GHC.Types.:
                                           @ BackEnd.Temp.Temp
                                           t
                                           (GHC.Types.[] @ BackEnd.Temp.Temp)
                                     } in
                                     let {
                                       eta1 :: BackEnd.Instructions.REG
                                       = BackEnd.Instructions.RTEMP t
                                     } in
                                     let {
                                       eta2 :: GHC.Types.Int
                                       = case int of wild4 { GHC.Types.I# x ->
                                         GHC.Types.I# (GHC.Prim.negateInt# x) }
                                     } in
                                     let {
                                       eta3 :: BackEnd.Instructions.SLOP2
                                       = BackEnd.Instructions.Imm eta1 eta2
                                     } in
                                     let {
                                       eta4 :: ([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                BackEnd.Instructions.SLOP2)
                                         {- Strictness: m -}
                                       = (GHC.Types.[] @ BackEnd.Assem.Instr, eta, eta3)
                                     } in
                                     (\ (eta5 :: BackEnd.Translate.TranslateState) -> (eta4, eta5))
                                       `cast`
                                     (Trans
                                          (<BackEnd.Translate.TranslateState>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <(([BackEnd.Assem.Instr],
                                                            [BackEnd.Temp.Temp],
                                                            BackEnd.Instructions.SLOP2),
                                                           BackEnd.Translate.TranslateState)>_R))
                                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                    <BackEnd.Translate.TranslateState>_N
                                                    <Data.Functor.Identity.Identity>_R
                                                    <([BackEnd.Assem.Instr], [BackEnd.Temp.Temp],
                                                      BackEnd.Instructions.SLOP2)>_N))) } } } }) -}
101606a98790436aa88df6f0488c3838
  munchMem1 :: BackEnd.Instructions.SLOP2
  {- Strictness: m1,
     Unfolding: (BackEnd.Instructions.MSG BackEnd.Munch.munchMem2) -}
061cc0ae91f3804d16574f9f7c71849e
  munchMem2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLOP2 NOT USED"#) -}
42399ac2b3a969e52417dc39a49ea2c5
  munchStm ::
    BackEnd.IR.Stm
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState [BackEnd.Assem.Instr]
  {- Arity: 1, Strictness: <S,U> -}
1d94808ecf1863d6b6be8683427d10b5
  munchmany ::
    [BackEnd.IR.Stm]
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         [BackEnd.Assem.Instr]
  {- Arity: 1, Strictness: <S,1*U> -}
14bcfff1fb2fea7bcbc4cc4a5b8b09bc
  oneByte :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case GHC.Base.eqString ds BackEnd.Munch.accessPair16 of wild {
                   GHC.Types.False -> GHC.Base.eqString ds BackEnd.Munch.accessPair15
                   GHC.Types.True -> GHC.Types.True }) -}
3e977ca09da806a8c771b6c6e7c1dd32
  opVal :: BackEnd.Instructions.Calc -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Instructions.Calc) ->
                 case ds of wild {
                   DEFAULT -> BackEnd.Munch.genBuiltIns109
                   BackEnd.Instructions.ADD ds1 ds2 -> BackEnd.Munch.assemPre6 }) -}
0a322e902d2b08c512f6263103f989ed
  optimise :: [BackEnd.Assem.Instr] -> [BackEnd.Assem.Instr]
  {- Arity: 1, Strictness: <S,1*U> -}
3378e9ed4efddb42bef9dd0c776c8e01
  optimsedMunch ::
    BackEnd.IR.Stm
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         (GHC.Types.IO [()])
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (stm :: BackEnd.IR.Stm) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           BackEnd.Translate.TranslateState
                           Data.Functor.Identity.Identity
                           [BackEnd.Assem.Instr]
                   = BackEnd.Munch.munchStm stm
                 } in
                 (\ (s1 :: BackEnd.Translate.TranslateState) ->
                  let {
                    ds :: Data.Functor.Identity.Identity
                            ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
                    = m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <BackEnd.Translate.TranslateState>_N
                           <Data.Functor.Identity.Identity>_R
                           <[BackEnd.Assem.Instr]>_N)
                        s1
                  } in
                  (BackEnd.Munch.optimsedMunch16
                     (BackEnd.Munch.optimsedMunch_go1
                        BackEnd.Munch.optimsedMunch13
                        (case ds
                                `cast`
                              (Data.Functor.Identity.N:Identity[0]
                                   <([BackEnd.Assem.Instr],
                                     BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                         BackEnd.Munch.optimsedMunch_go
                           (BackEnd.Munch.optimise
                              (BackEnd.Assem.normAssem BackEnd.Munch.optimsedMunch1 a1)) })),
                   case ds
                          `cast`
                        (Data.Functor.Identity.N:Identity[0]
                             <([BackEnd.Assem.Instr],
                               BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                   s' })
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(GHC.Types.IO [()], BackEnd.Translate.TranslateState)>_R)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <BackEnd.Translate.TranslateState>_N
                           <Data.Functor.Identity.Identity>_R
                           <GHC.Types.IO [()]>_N))) -}
a55e90e407fce3e9ace749de591b8e26
  optimsedMunch1 :: [(GHC.Types.Int, BackEnd.Instructions.REG)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, BackEnd.Instructions.REG)
                   BackEnd.Munch.optimsedMunch12
                   BackEnd.Munch.optimsedMunch2) -}
1daebf15cd42208c191155f0e07e58ed
  optimsedMunch10 :: (GHC.Types.Int, BackEnd.Instructions.REG)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.Munch.optimsedMunch11,
                  BackEnd.Instructions.LR)) -}
28124bf916f0d3eeaa326210398de894
  optimsedMunch11 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 14#) -}
9c35a9093867f33abb9dd4223f6b3ab1
  optimsedMunch12 :: (GHC.Types.Int, BackEnd.Instructions.REG)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.Munch.accessPair1,
                  BackEnd.Instructions.SP)) -}
f4c4b119c1739e14dda1805d14d0a10e
  optimsedMunch13 :: [GHC.Integer.Type.Integer]
  {- Unfolding: (case GHC.Enum.$wenumDeltaInteger
                        BackEnd.Munch.optimsedMunch15
                        BackEnd.Munch.optimsedMunch14 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Integer.Type.Integer ww1 ww2 }) -}
0f16dac56a59b976338e151ab1798e4e
  optimsedMunch14 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
2e8aca32163f004d83e62d07ad11afbb
  optimsedMunch15 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
a53594cec805128a293221d94346b551
  optimsedMunch16 :: [GHC.Base.String] -> GHC.Types.IO [()]
  {- Unfolding: (Data.Traversable.$fTraversable[]_$cmapM
                   @ GHC.Types.IO
                   @ GHC.Base.String
                   @ ()
                   GHC.Base.$fMonadIO
                   System.IO.putStrLn1
                     `cast`
                   (<GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R))) -}
5935de0279ab3bf2cb8eff78a4f20f8d
  optimsedMunch2 :: [(GHC.Types.Int, BackEnd.Instructions.REG)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, BackEnd.Instructions.REG)
                   BackEnd.Munch.optimsedMunch10
                   BackEnd.Munch.optimsedMunch3) -}
049572066b14c3661d9d08aded7e4802
  optimsedMunch3 :: [(GHC.Types.Int, BackEnd.Instructions.REG)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, BackEnd.Instructions.REG)
                   BackEnd.Munch.optimsedMunch8
                   BackEnd.Munch.optimsedMunch4) -}
f701f97862c7770eaedd0727dc6cc5be
  optimsedMunch4 :: [(GHC.Types.Int, BackEnd.Instructions.REG)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, BackEnd.Instructions.REG)
                   BackEnd.Munch.optimsedMunch7
                   BackEnd.Munch.optimsedMunch5) -}
279d50a227c9c470a9e148b61a9d18ab
  optimsedMunch5 :: [(GHC.Types.Int, BackEnd.Instructions.REG)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, BackEnd.Instructions.REG)
                   BackEnd.Munch.optimsedMunch6
                   (GHC.Types.[] @ (GHC.Types.Int, BackEnd.Instructions.REG))) -}
c53daec3d7d3b9854b0aba7d1be3254c
  optimsedMunch6 :: (GHC.Types.Int, BackEnd.Instructions.REG)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.Munch.accessPair4,
                  BackEnd.Instructions.R0)) -}
e5b03633727d1e666baf6c17d1d3afb6
  optimsedMunch7 :: (GHC.Types.Int, BackEnd.Instructions.REG)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.Munch.assemPre6, BackEnd.Instructions.R1)) -}
5aa25d020ebeb2169add8223dc8f1655
  optimsedMunch8 :: (GHC.Types.Int, BackEnd.Instructions.REG)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((BackEnd.Munch.optimsedMunch9,
                  BackEnd.Instructions.PC)) -}
7a19f2f801ed007dd8dafebb09d98af4
  optimsedMunch9 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 15#) -}
3507ba436efae66c1cb4944d8ccc5d06
  optimsedMunch_go :: [BackEnd.Assem.Instr] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
d7bb50ac8c8d634a826e0faff57d56ec
  optimsedMunch_go1 ::
    [GHC.Integer.Type.Integer]
    -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
b0b171d3e9167a6a9a1535bf0514efaa
  p_check_array_bounds :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns22
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
eab6ed5cf3d6f0ca983aac447c57912d
  p_check_divide_by_zero :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.p_check_divide_by_zero1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
5f3c3e35bcf765abf68c7548f8d05683
  p_check_divide_by_zero1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Munch.$wp_check_divide_by_zero
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([BackEnd.Assem.Instr],
                             BackEnd.Translate.TranslateState)>_R)) }) -}
7a33d45ad8e4da2de52a0ded62b5d193
  p_check_divide_by_zero2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "DivideByZeroError: divide or modulo by zero\n\
                   \\\192\\128"#) -}
52c9e5ef7b9c2419ce6f599e3fcf3520
  p_check_divide_by_zero3 :: BackEnd.Assem.Instr
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Assem.IOPER
                   BackEnd.Munch.p_check_divide_by_zero4
                   (GHC.Types.[] @ BackEnd.Temp.Temp)
                   BackEnd.Munch.assemPre5
                   (GHC.Types.[] @ GHC.Base.String)) -}
b35df3f4d0130c579b7298f597cbf8b4
  p_check_divide_by_zero4 :: BackEnd.Instructions.Instr
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.MC_
                   BackEnd.Munch.p_check_divide_by_zero6
                   BackEnd.Instructions.R1
                   BackEnd.Munch.p_check_divide_by_zero5) -}
4ab114283ddf394241c0093cac850278
  p_check_divide_by_zero5 :: BackEnd.Instructions.OP
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (BackEnd.Instructions.IMM BackEnd.Munch.accessPair4) -}
48b6dc558c556caf142e3dcf06974925
  p_check_divide_by_zero6 :: BackEnd.Instructions.Simple
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.Instructions.CMP BackEnd.Instructions.AL) -}
395334bfad8e05940a9a5c2959832d37
  p_check_divide_by_zero7 :: BackEnd.Assem.Instr
  {- Strictness: m2,
     Unfolding: (BackEnd.Assem.ILABEL
                   BackEnd.Munch.p_check_divide_by_zero9
                   BackEnd.Munch.p_check_divide_by_zero8) -}
6d8f90f4834b287f293fd6578a037ce3
  p_check_divide_by_zero8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "p_check_divide_by_zero"#) -}
3ca47364c287400f44f8d921203aed85
  p_check_divide_by_zero9 :: BackEnd.Instructions.Instr
  {- Strictness: m8,
     Unfolding: (BackEnd.Instructions.LAB
                   BackEnd.Munch.p_check_divide_by_zero8) -}
a7344f7ed16bb1fe21c2624bf5ba7dde
  p_check_null_pointer :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns117
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
a3f96f42dd917e9a02d53bfed84860a3
  p_free_pair :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns40
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
dbd8e3f2c3d7b1e54f6f66f1e3f5ce2f
  p_print_bool :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns135
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
b0f441220456e224834d4a4f847677b9
  p_print_int :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns141
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
5a4a76325f52ea86255a0e1191a1f488
  p_print_ln :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns144
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
cd7adfda63485bb8a665156ace71d451
  p_print_reference :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns121
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
aa0c38ab59fce977d172d9607978c7e0
  p_print_string :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns125
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
7d863af5ecb02475fc1ba7b5ca073aa3
  p_read :: GHC.Base.String -> BackEnd.Munch.GenBuiltIn
  {- Arity: 2, Strictness: <L,U><L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns83
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[BackEnd.Assem.Instr]>_N)) -}
cb93d9c1daea6784baee00eee775a738
  p_read_char :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns79
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
3450b597eeb2fc949827750981071eb6
  p_read_int :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns93
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
da4753ffd50a0cf0e7df43f16e612add
  p_throw_overflow_error :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns12
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <[BackEnd.Assem.Instr]>_N)) -}
e0c73672ea7d9319bce8838ae0988d9b
  p_throw_runtime_error :: BackEnd.Munch.GenBuiltIn
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.genBuiltIns97
                  `cast`
                (Trans
                     (<BackEnd.Translate.TranslateState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([BackEnd.Assem.Instr], BackEnd.Translate.TranslateState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[BackEnd.Assem.Instr]>_N))) -}
ad242c1198a92ba22b7b283f6c259dfe
  same :: BackEnd.IR.ROp -> BackEnd.Instructions.Cond
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: BackEnd.IR.ROp) ->
                 case GHC.List.lookup
                        @ BackEnd.IR.ROp
                        @ BackEnd.Instructions.Cond
                        BackEnd.IR.$fEqROp
                        a
                        BackEnd.Munch.same1 of wild {
                   GHC.Base.Nothing
                   -> Data.Maybe.fromJust1 @ BackEnd.Instructions.Cond
                   GHC.Base.Just x -> x }) -}
5fe4a0cfb879e8d7db49eb13d7fbb09f
  same1 :: [(BackEnd.IR.ROp, BackEnd.Instructions.Cond)]
  {- Unfolding: (GHC.List.zip
                   @ BackEnd.IR.ROp
                   @ BackEnd.Instructions.Cond
                   BackEnd.Munch.condIR
                   BackEnd.Munch.condARM) -}
084c7efbe265513de804bd2c0ea88de0
  showExp ::
    BackEnd.IR.Exp -> ([BackEnd.Assem.Instr], BackEnd.Temp.Temp)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (exp :: BackEnd.IR.Exp) ->
                 case ((BackEnd.Munch.munchExp exp)
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <BackEnd.Translate.TranslateState>_N
                            <Data.Functor.Identity.Identity>_R
                            <([BackEnd.Assem.Instr], BackEnd.Temp.Temp)>_N)
                         BackEnd.Translate.newTranslateState)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(([BackEnd.Assem.Instr], BackEnd.Temp.Temp),
                             BackEnd.Translate.TranslateState)>_R) of wild { (,) x ds1 ->
                 x }) -}
a7371ae39e3e0d617e077f8e5dfe8b0a
  showStm :: BackEnd.IR.Stm -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Munch.showStm1
                  `cast`
                (<BackEnd.IR.Stm>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
16d7a6696f5e3bdba90a44789c4a5eb2
  showStm1 ::
    BackEnd.IR.Stm
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (stm :: BackEnd.IR.Stm)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.Types.[] @ GHC.Types.Char)
                        GHC.Types.True
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case (BackEnd.Munch.optimsedMunch16
                         (BackEnd.Munch.optimsedMunch_go1
                            BackEnd.Munch.optimsedMunch13
                            (case ((BackEnd.Munch.munchStm stm)
                                     `cast`
                                   (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                        <BackEnd.Translate.TranslateState>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <[BackEnd.Assem.Instr]>_N)
                                     BackEnd.Translate.newTranslateState)
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <([BackEnd.Assem.Instr],
                                         BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                             BackEnd.Munch.optimsedMunch_go
                               (BackEnd.Munch.optimise
                                  (BackEnd.Assem.normAssem BackEnd.Munch.optimsedMunch1 a1)) })))
                        `cast`
                      (GHC.Types.N:IO[0] <[()]>_R)
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.Types.[] @ GHC.Types.Char)
                        GHC.Types.True
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4, GHC.Tuple.() #) } } }) -}
450d51c51424cf37840659c90d49c774
  stackEqualCond ::
    BackEnd.Instructions.Calc
    -> BackEnd.Instructions.SL -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (ds :: BackEnd.Instructions.Calc)
                   (ds1 :: BackEnd.Instructions.SL) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   BackEnd.Instructions.ADD ds2 c1
                   -> case ds1 of wild1 {
                        BackEnd.Instructions.LDR ds3 c2
                        -> BackEnd.Instructions.$fEqCond_$c== c1 c2
                        BackEnd.Instructions.STR ds3 c2
                        -> BackEnd.Instructions.$fEqCond_$c== c1 c2 }
                   BackEnd.Instructions.SUB ds2 c1
                   -> case ds1 of wild1 {
                        BackEnd.Instructions.LDR ds3 c2
                        -> BackEnd.Instructions.$fEqCond_$c== c1 c2
                        BackEnd.Instructions.STR ds3 c2
                        -> BackEnd.Instructions.$fEqCond_$c== c1 c2 } }) -}
9acd8a2370e4e52be2fd0a50ebe3b01d
  store1b :: BackEnd.IR.Stm
  {- Strictness: m1,
     Unfolding: (BackEnd.IR.MOV
                   BackEnd.Munch.load1b1
                   BackEnd.Munch.irPre2) -}
35b165b798ed770e5f2b287551842def
  suffixStm ::
    BackEnd.IR.Stm
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         (BackEnd.Instructions.Cond
          -> BackEnd.Instructions.SLType -> [BackEnd.Assem.Instr])
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

