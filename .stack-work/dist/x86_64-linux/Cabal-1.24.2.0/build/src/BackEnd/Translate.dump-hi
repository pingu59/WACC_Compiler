
==================== FINAL INTERFACE ====================
2019-02-27 09:56:06.8286039 UTC

interface wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2:BackEnd.Translate 8002
  interface hash: 592b8786884fc55b5696d5e13d821878
  ABI hash: f25829781727f8c89b1efb5ee803e929
  export-list hash: d00c5cdab9fae07fbdebcdfe18de688f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 02b3c746106ad76f793f89ebc1f71840
  sig of: Nothing
  used TH splices: False
  where
exports:
  BackEnd.Translate.accessToMem
  BackEnd.Translate.addBuiltIn
  BackEnd.Translate.addFragment
  BackEnd.Translate.addFunEntry
  BackEnd.Translate.addVarEntry
  BackEnd.Translate.adjustSP
  BackEnd.Translate.allocLocal
  BackEnd.Translate.callp
  BackEnd.Translate.escape
  BackEnd.Translate.getCurrFrame
  BackEnd.Translate.getVarEntry
  BackEnd.Translate.id_p_check_array_bounds
  BackEnd.Translate.id_p_check_null_pointer
  BackEnd.Translate.id_p_free_pair
  BackEnd.Translate.id_p_print_bool
  BackEnd.Translate.id_p_print_int
  BackEnd.Translate.id_p_print_ln
  BackEnd.Translate.id_p_print_reference
  BackEnd.Translate.id_p_print_string
  BackEnd.Translate.id_p_read_char
  BackEnd.Translate.id_p_read_int
  BackEnd.Translate.id_p_throw_overflow_error
  BackEnd.Translate.id_p_throw_runtime_error
  BackEnd.Translate.newControlLabel
  BackEnd.Translate.newDataLabel
  BackEnd.Translate.newFrameLabel
  BackEnd.Translate.newLevel
  BackEnd.Translate.newTemp
  BackEnd.Translate.newTranslateState
  BackEnd.Translate.popLevel
  BackEnd.Translate.pushLevel
  BackEnd.Translate.seq
  BackEnd.Translate.show'
  BackEnd.Translate.stripParam
  BackEnd.Translate.translate
  BackEnd.Translate.translateBuiltInFuncAppF
  BackEnd.Translate.translateExprF
  BackEnd.Translate.translateFile
  BackEnd.Translate.translateFree
  BackEnd.Translate.translateFuncAppF
  BackEnd.Translate.translateFuncF
  BackEnd.Translate.translateNewPair
  BackEnd.Translate.translatePairAccess
  BackEnd.Translate.translatePrint
  BackEnd.Translate.translatePrintln
  BackEnd.Translate.translateProgramF
  BackEnd.Translate.translateRead
  BackEnd.Translate.translateStatF
  BackEnd.Translate.translateStatListF
  BackEnd.Translate.unCx
  BackEnd.Translate.unEx
  BackEnd.Translate.unNx
  BackEnd.Translate.verifyLevels
  BackEnd.Translate.Access{BackEnd.Translate.Access}
  BackEnd.Translate.EnvEntry{BackEnd.Translate.FunEntry BackEnd.Translate.VarEntry}
  BackEnd.Translate.IExp{BackEnd.Translate.Cx BackEnd.Translate.Ex BackEnd.Translate.Nx}
  BackEnd.Translate.Level{BackEnd.Translate.Level funTable levelFrame varTable}
  BackEnd.Translate.TranslateState{BackEnd.Translate.TranslateState builtInSet controlLabelAlloc dataFrags dataLabelAlloc frameLabelAlloc levels procFrags tempAlloc}
module dependencies: BackEnd.Assem BackEnd.Builtin BackEnd.Frame
                     BackEnd.IR BackEnd.Instructions BackEnd.Temp FrontEnd.AST
                     FrontEnd.Lexer FrontEnd.Parser FrontEnd.SemanticAnalyzer
package dependencies: MissingH-1.4.0.1@MissingH-1.4.0.1-XvvfeDrBQU2lhIiDW7bjd
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      boxes-0.1.5@boxes-0.1.5-6DdHE3jJ0TwE6WTwMdCW4f
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn
                      ghc-prim-0.5.0.0
                      hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa
                      hashmap-1.3.3@hashmap-1.3.3-6F5MsgNDasO6fIeStnUOf6
                      integer-gmp-1.0.0.1 mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h
                      parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E
                      pretty-tree-0.1.0.0@pretty-tree-0.1.0.0-5ldf01HzJj05FtOtje7CSt
                      split-0.2.3.3@split-0.2.3.3-KPq5EVv6rbi8XHTA0KJd3E
                      text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn:Generics.Deriving.Instances
         hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa:Data.Hashable.Generic
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         generic-deriving-1.12.3@generic-deriving-1.12.3-HPQduUg70uzIWqANLW8iZn:Generics.Deriving.Instances
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
                         wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2:BackEnd.Instructions
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 69259e29eb6a13996a202cd7b2dae772
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  hashmap-1.3.3@hashmap-1.3.3-6F5MsgNDasO6fIeStnUOf6:Data.HashMap 21c21e30ca661fd288861556f5a56e8d
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State.Class 353753d62a48dcd4d640d0eb74aa4d50
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State.Lazy f8e741bf4d853e8c9e1e41041ac4e6b4
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
import  -/  BackEnd.Assem 0c2dd4117304a7718bc4adf283ae5e64
  exports: 4e4b66683d488fa10cb15dfdfb0d7eda
import  -/  BackEnd.Builtin ed9d8a61a4fe433113515ad446c366fe
  exports: 0efa3a64647a63ce77aebf0b789b849f
import  -/  BackEnd.Frame 2a16ec41ca683a4c04bc531bc13d071b
  exports: ff876c8d53ae8d9cc84a5698ff7b815b
  Access c360135ea7bf783632002c360507c5e6
  Fragment 178f360a73d54bda48fbe76e6c7fbb4f
  Frame 2ef4972266d072b4e7678a4819306338
  InFrame 37da2c693c950d5f7cf8c00ef4595154
  InReg 8f32acf0690792a7b57d852b287da84a
  PROC 2b9d17893fedaf24c09290ba6540b23d
  STRING 78217e4228088700a876037af05e9e9e
  allocLocal cb37e23ca45e334443bec1ea3c7ea33e
  externalCall 0718412434e71a2db004fd72ffa91585
  fp 580da9e0b0080cc1e0c65032dd5bff72
  frameSize d7217b8b4d7324d73d337d97ca38236b
  intSize 2b7b2a6297fbd835ff05c56dcd060bbc
  lr 28eccfe9e7eccd80ae5dc2a2cb3a283f
  newFrame d604ad44d8122ec717f29314cb3ef953
  pc 4b283bb9ccaeccc5f95d9b0bd3b4141d
  rv e58867315ab8d44130e0fd01a25ead82
  sp 606994e88545fb7a8d39f0c48e74df00
  typeSize 99523c9d860be452c82b91263cac7110
import  -/  BackEnd.IR 881b5c7113579e9e0196d2b90545a438
  exports: 6d764dfdda2ad49e5da2751723ca6e76
  AND abcf56bcaefd09fdcb417c5b1ae415cb
  BINEXP 314d5c5ea0e7abb37509298c8f219809
  CALL 3ea9e353cc093939205143f9affc94dd
  CJUMP 8a9984cdeabb0729a12d302ee976c1ae
  CONSTC d7c2d48ab024444ee1683add7101cf65
  CONSTI 1e86d692b475a9afd7eb4a380c9df20a
  DIV b750d37f3c5598fcb5acb80e406300d5
  EQ 6adbced130978fdfab51558428d57ef4
  ESEQ 7747f3b871d1a0d32a6e9524e80b12be
  EXP f4838f4c177709e7c7e70c0752435d8f
  Exp 29a6c3cd3ea133857ec2f8677caa5fe0
  GE 1fc91032b654e87de530334e697f1246
  GT 77c6d01ac4214ea6d7b1541ba4f7c65f
  JUMP eac31562bd601b25d94ceeeb566aa59e
  LABEL c97b7be2ccf356961383cd3d9288f4e4
  LE 076c5ca5320a8b54c74696edde08b9da
  LT b4a1e62f17273a2504227d1ce6663575
  MEM b593e2a075e1ece03bfeed656ad0d462
  MINUS bd554593b3645acec0c60b3fe19827fb
  MOD 272e86bb622690fab60fe065c0d607a3
  MOV 06cbd5b3f416dbde4084d0dc86d79095
  MUL c576d2fcb0096224259caaaee70b210b
  NAME 09e0af564273846ddfc4a8df2204c47b
  NE 33058a3449a4760684783802d64a9101
  NOP b03e7ae709d42a8a9ae7021ff91d4519
  OR 1ab045d5c38128e42d089751b4fca2f8
  PLUS fbf0c26117466714144501139f520f88
  POP 6668b454a821e04401bd00ff3ba590c7
  PUSH 747fde67cb21ccf1612f512ef7204765
  SEQ f05eb9a24fbe0c461a90502ed64bebc9
  Stm 29a6c3cd3ea133857ec2f8677caa5fe0
  TEMP fed6108e10e5807c38f5a398fcd57699
  cleanStm 5eccbb71b13e0b4437357a0ceb01a059
import  -/  BackEnd.Temp 0c22f42d627493b2b3f13cd2a3ac5a46
  exports: ecf0e74365e1a70f2572e5197e175ea3
  Label ab7a275275a088fb10914e7eda58ce46
  LabelAllocator 7133bcfcbc18cbbc113f9e0135903ce5
  Temp 14024289252e98b781eb5778cbac8848
  TempAllocator bdce2d3fdfa323e7fb6e0441a84ede78
  newControlLabel e0f1c493c743ab50763f5aab8b4da255
  newDataLabel d6246df241a890c138eef69b9eb119d6
  newFrameLabel 7941faa0a81ce9aa4bdc8f83e659c136
  newLabelAllocator e9ec3bab80f5b18e9df1fbb1e736e3e7
  newTemp 8b95d76b77154b40029113217d048b32
  newTempAllocator 1656e7b6841ac685e639c91435f4d93d
import  -/  FrontEnd.AST 13c4a14be76ce51c011789d09991ee7e
  exports: c71a8578c05d8981bdbdc0f839e79cdc
  Ann 7fb12f302cfbf6b6a9644b9022f39f91
  ArrayElem 20a9002fa5c7a880222792b8088784fd
  ArrayLiter 2c7fb705577fbe26b0c92ab9b038cf7c
  Assign c9253eba2dbcb82e200705249ffda60e
  BoolLiter f242a322ad0fedd5ecb1579d8a5e9b9e
  BracketExpr 6f2d9ec9e7eddea39de0b23fa4b1ccf6
  CharLiter 0458b4eacfafbb08f2fec10d88830282
  Declare 003063376653c1ef78a2034dd3236d7b
  Exit 6d9a13cd0053bdea62c2cd3748feae80
  ExprF 048863448071204b4f096bf54a7d962c
  Func c7dcba27b2484d7b42e2091a6e288149
  FuncApp 7c4037b27a9527827a9401cf55e9d295
  FuncAppF 048863448071204b4f096bf54a7d962c
  FuncExpr 6188e6636c92ca9df653f0f89fd5dc47
  FuncF 9340e16bce1d1e46b7de1676a36637ff
  FuncStat bbaea13021f384be4edd0ea8066c9715
  Ident d38c2816185f64eaa87a87bb4f1f284b
  IdentExpr e73e6f79f7f1ef1091078aeeed9f0804
  If 41c6a88b2ac35b6df66a31872b4fd7f0
  IntLiter 34d3efe89b2a1206d5f4c1e06ebf5c34
  Null d07e86e72331bc577ef82b35eece2bd8
  Param e121bfb0c269eb452a3f460fc6e7748c
  ParamF 79e2ac42726a3ab8f12e2556b622b353
  Program 410fd95ff8f98d31de0e476f267b415c
  ProgramF 7ad5b774cd31af8f985fa4c4cbcfa7e6
  Return dd154fd7dab4366b36f9e2bc9ebe9d95
  StatF 7a7ac6f3981aec536719f99cb3fcc916
  StatList d3a3a04ef089fd4a8715f53fb53f355e
  StatListF 7a7ac6f3981aec536719f99cb3fcc916
  StringLiter 6f1c0a78bc4d294148974465edb0afc2
  Subroutine c290bc93d96618101048c8a5ef575c59
  TArray 675264970e89d6be6a7b3e6f609b61a8
  TBool ebaf87cd8048064e60b38511bca54962
  TChar ec215f0c3082a946dbbc8dae32db4dc2
  TFunc 3f21d70d5fc155d018a3c6908184945c
  TInt 217cf96b2dda4e7a20fd48a7acdc5d45
  TPair f6c60416a1982c621b5593998f9b57e5
  TStr 1e8a03d0c8a4120669e95455e7ec9733
  Type 31b3244b67ff67ccd6b5abdfe81be110
  While bd4a4fee4ef59ee20f73dea3819ad3e2
  builtInFunc fc085426e0f1eb149b76b5af8405bd3c
  typeLen f81e94953f2b2470f04b97dc3a2afbaf
import  -/  FrontEnd.Parser dc168563fd1859eeec254be3c17e78ba
  exports: 45bb2ab1df05f1264fee753899b5f469
  parseFile 929aa559965a9236f270d400e22bd9ed
import  -/  FrontEnd.SemanticAnalyzer 2f8f81b4dd9a2a3fbbaa2a032c60c1d3
  exports: 3c3524b7a455b135a3bb7a20b10bc1fa
  analyzeAST e5e0977902ab61dd8618d68f6e124446
86da6bad0743b8f8af5eb4377d667e31
  $fEqAccess :: GHC.Classes.Eq BackEnd.Translate.Access
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.Access
                  BackEnd.Translate.$fEqAccess_$c==
                  BackEnd.Translate.$fEqAccess_$c/= -}
86da6bad0743b8f8af5eb4377d667e31
  $fEqAccess_$c/= ::
    BackEnd.Translate.Access
    -> BackEnd.Translate.Access -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,1*U(U)),1*U)><S(S(SL)L),1*U(1*U(1*U,1*U(U)),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.Access)
                   (w1 :: BackEnd.Translate.Access) ->
                 case w of ww { BackEnd.Translate.Access ww1 ww2 ->
                 case ww1 of ww3 { BackEnd.Frame.Frame ww4 ww5 ->
                 case w1 of ww6 { BackEnd.Translate.Access ww7 ww8 ->
                 case ww7 of ww9 { BackEnd.Frame.Frame ww10 ww11 ->
                 BackEnd.Translate.$w$c/= ww4 ww5 ww2 ww10 ww11 ww8 } } } }) -}
86da6bad0743b8f8af5eb4377d667e31
  $fEqAccess_$c== ::
    BackEnd.Translate.Access
    -> BackEnd.Translate.Access -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,1*U(U)),1*U)><S(S(SL)L),1*U(1*U(1*U,1*U(U)),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.Access)
                   (w1 :: BackEnd.Translate.Access) ->
                 case w of ww { BackEnd.Translate.Access ww1 ww2 ->
                 case ww1 of ww3 { BackEnd.Frame.Frame ww4 ww5 ->
                 case w1 of ww6 { BackEnd.Translate.Access ww7 ww8 ->
                 case ww7 of ww9 { BackEnd.Frame.Frame ww10 ww11 ->
                 BackEnd.Translate.$w$c== ww4 ww5 ww2 ww10 ww11 ww8 } } } }) -}
0120b873deaf0cf2fe559075fc860092
  $fEqEnvEntry :: GHC.Classes.Eq BackEnd.Translate.EnvEntry
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.EnvEntry
                  BackEnd.Translate.$fEqEnvEntry_$c==
                  BackEnd.Translate.$fEqEnvEntry_$c/= -}
0120b873deaf0cf2fe559075fc860092
  $fEqEnvEntry_$c/= ::
    BackEnd.Translate.EnvEntry
    -> BackEnd.Translate.EnvEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: BackEnd.Translate.EnvEntry)
                   (b :: BackEnd.Translate.EnvEntry) ->
                 case BackEnd.Translate.$fEqEnvEntry_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0120b873deaf0cf2fe559075fc860092
  $fEqEnvEntry_$c== ::
    BackEnd.Translate.EnvEntry
    -> BackEnd.Translate.EnvEntry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: BackEnd.Translate.EnvEntry)
                   (ds1 :: BackEnd.Translate.EnvEntry) ->
                 case ds of wild {
                   BackEnd.Translate.VarEntry a1 a2
                   -> case ds1 of wild1 {
                        BackEnd.Translate.VarEntry b1 b2
                        -> case a1 of wild2 { BackEnd.Translate.Access a4 a5 ->
                           case b1 of wild3 { BackEnd.Translate.Access b4 b5 ->
                           case a4 of ww { BackEnd.Frame.Frame ww1 ww2 ->
                           case b4 of ww3 { BackEnd.Frame.Frame ww4 ww5 ->
                           case GHC.Base.eqString ww1 ww4 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww2 of wild5 { GHC.Types.I# x ->
                                case ww5 of wild6 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild7 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case a5 of wild8 {
                                       BackEnd.Frame.InFrame a6
                                       -> case b5 of wild9 {
                                            BackEnd.Frame.InFrame b6
                                            -> case a6 of wild10 { GHC.Types.I# x1 ->
                                               case b6 of wild11 { GHC.Types.I# y1 ->
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.==# x1 y1) of wild12 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> FrontEnd.AST.$fEqParam_$c==2 a2 b2 } } }
                                            BackEnd.Frame.InReg ipv -> GHC.Types.False }
                                       BackEnd.Frame.InReg a6
                                       -> case b5 of wild9 {
                                            BackEnd.Frame.InFrame ipv -> GHC.Types.False
                                            BackEnd.Frame.InReg b6
                                            -> case a6 of wild10 { GHC.Types.I# x1 ->
                                               case b6 of wild11 { GHC.Types.I# y1 ->
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.==# x1 y1) of wild12 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> FrontEnd.AST.$fEqParam_$c==2
                                                      a2
                                                      b2 } } } } } } } } } } } } }
                        BackEnd.Translate.FunEntry ipv ipv1 ipv2 -> GHC.Types.False }
                   BackEnd.Translate.FunEntry a1 a2 a3
                   -> case ds1 of wild1 {
                        BackEnd.Translate.VarEntry ipv ipv1 -> GHC.Types.False
                        BackEnd.Translate.FunEntry b1 b2 b3
                        -> case a1 of ww { BackEnd.Frame.Frame ww1 ww2 ->
                           case b1 of ww3 { BackEnd.Frame.Frame ww4 ww5 ->
                           case GHC.Base.eqString ww1 ww4 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww2 of wild3 { GHC.Types.I# x ->
                                case ww5 of wild4 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Base.eqString a2 b2 of wild6 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> FrontEnd.AST.$fEqParam_$c==2 a3 b3 } } } } } } } } }) -}
02827ddec16ce06b553862cfc961c00c
  $fEqLevel :: GHC.Classes.Eq BackEnd.Translate.Level
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.Level
                  BackEnd.Translate.$fEqLevel_$c==
                  BackEnd.Translate.$fEqLevel_$c/= -}
041a9f59551a39d2d0b041c2e0108ce7
  $fEqLevel1 ::
    GHC.Classes.Eq
      (Data.HashMap.Some [GHC.Types.Char] BackEnd.Translate.EnvEntry)
  {- Unfolding: (Data.HashMap.$fEqSome
                   @ [GHC.Types.Char]
                   @ BackEnd.Translate.EnvEntry
                   BackEnd.Translate.$fEqEnvEntry
                   GHC.Classes.$fEq[]_$s$fEq[]1) -}
02827ddec16ce06b553862cfc961c00c
  $fEqLevel_$c/= ::
    BackEnd.Translate.Level
    -> BackEnd.Translate.Level -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(S(SL)LL),1*U(1*U(1*U,1*U(U)),1*U,1*U)><S(S(SL)LL),1*U(1*U(1*U,1*U(U)),1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: BackEnd.Translate.Level) (b :: BackEnd.Translate.Level) ->
                 case BackEnd.Translate.$fEqLevel_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
02827ddec16ce06b553862cfc961c00c
  $fEqLevel_$c== ::
    BackEnd.Translate.Level
    -> BackEnd.Translate.Level -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(S(SL)LL),1*U(1*U(1*U,1*U(U)),1*U,1*U)><S(S(SL)LL),1*U(1*U(1*U,1*U(U)),1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.Level)
                   (w1 :: BackEnd.Translate.Level) ->
                 case w of ww { BackEnd.Translate.Level ww1 ww2 ww3 ->
                 case ww1 of ww4 { BackEnd.Frame.Frame ww5 ww6 ->
                 case w1 of ww7 { BackEnd.Translate.Level ww8 ww9 ww10 ->
                 case ww8 of ww11 { BackEnd.Frame.Frame ww12 ww13 ->
                 BackEnd.Translate.$w$c==1
                   ww5
                   ww6
                   ww2
                   ww3
                   ww12
                   ww13
                   ww9
                   ww10 } } } }) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fEqTranslateState ::
    GHC.Classes.Eq BackEnd.Translate.TranslateState
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.TranslateState
                  BackEnd.Translate.$fEqTranslateState_$c==
                  BackEnd.Translate.$fEqTranslateState_$c/= -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fEqTranslateState_$c/= ::
    BackEnd.Translate.TranslateState
    -> BackEnd.Translate.TranslateState -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SLLLLLLL),1*U(1*U,1*U,1*U,1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),U)><S(SLLLLLLL),1*U(1*U,1*U,1*U,1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: BackEnd.Translate.TranslateState)
                   (b :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$fEqTranslateState_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fEqTranslateState_$c== ::
    BackEnd.Translate.TranslateState
    -> BackEnd.Translate.TranslateState -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SLLLLLLL),1*U(1*U,1*U,1*U,1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),U)><S(SLLLLLLL),1*U(1*U,1*U,1*U,1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),1*U(1*U(U)),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.TranslateState)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case w1 of ww9 { BackEnd.Translate.TranslateState ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 BackEnd.Translate.$w$c==2
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17 } }) -}
86da6bad0743b8f8af5eb4377d667e31
  $fShowAccess :: GHC.Show.Show BackEnd.Translate.Access
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.Access
                  BackEnd.Translate.$fShowAccess_$cshowsPrec
                  BackEnd.Translate.$fShowAccess_$cshow
                  BackEnd.Translate.$fShowAccess_$cshowList -}
86da6bad0743b8f8af5eb4377d667e31
  $fShowAccess1 :: BackEnd.Translate.Access -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: BackEnd.Translate.Access)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { BackEnd.Translate.Access ww1 ww2 ->
                 BackEnd.Translate.$w$cshowsPrec 0# ww1 ww2 w1 }) -}
812b912c6862434b37a76aa5779b3974
  $fShowAccess2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Access "#) -}
86da6bad0743b8f8af5eb4377d667e31
  $fShowAccess_$cshow :: BackEnd.Translate.Access -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U,1*U(U)),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: BackEnd.Translate.Access) ->
                 BackEnd.Translate.$fShowAccess_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
86da6bad0743b8f8af5eb4377d667e31
  $fShowAccess_$cshowList ::
    [BackEnd.Translate.Access] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BackEnd.Translate.Access
                   BackEnd.Translate.$fShowAccess1) -}
86da6bad0743b8f8af5eb4377d667e31
  $fShowAccess_$cshowsPrec ::
    GHC.Types.Int -> BackEnd.Translate.Access -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U(1*U,1*U(U)),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: BackEnd.Translate.Access)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { BackEnd.Translate.Access ww3 ww4 ->
                 BackEnd.Translate.$w$cshowsPrec ww1 ww3 ww4 w2 } }) -}
0120b873deaf0cf2fe559075fc860092
  $fShowEnvEntry :: GHC.Show.Show BackEnd.Translate.EnvEntry
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.EnvEntry
                  BackEnd.Translate.$fShowEnvEntry_$cshowsPrec
                  BackEnd.Translate.$fShowEnvEntry_$cshow
                  BackEnd.Translate.$fShowEnvEntry_$cshowList -}
0120b873deaf0cf2fe559075fc860092
  $fShowEnvEntry1 :: BackEnd.Translate.EnvEntry -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: BackEnd.Translate.EnvEntry)
                   (w1 :: GHC.Base.String) ->
                 BackEnd.Translate.$w$cshowsPrec1 0# w w1) -}
99509512fa05d8788ba9799924c9ffcd
  $fShowEnvEntry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FunEntry "#) -}
ee5193f84ba84ec348abec3e27011ea9
  $fShowEnvEntry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VarEntry "#) -}
0120b873deaf0cf2fe559075fc860092
  $fShowEnvEntry_$cshow ::
    BackEnd.Translate.EnvEntry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: BackEnd.Translate.EnvEntry) ->
                 BackEnd.Translate.$fShowEnvEntry_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0120b873deaf0cf2fe559075fc860092
  $fShowEnvEntry_$cshowList ::
    [BackEnd.Translate.EnvEntry] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BackEnd.Translate.EnvEntry
                   BackEnd.Translate.$fShowEnvEntry1) -}
0120b873deaf0cf2fe559075fc860092
  $fShowEnvEntry_$cshowsPrec ::
    GHC.Types.Int -> BackEnd.Translate.EnvEntry -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: BackEnd.Translate.EnvEntry)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BackEnd.Translate.$w$cshowsPrec1 ww1 w1 w2 }) -}
a20cdd6bf7f08c3bd03a952c60fbdef2
  $fShowIExp :: GHC.Show.Show BackEnd.Translate.IExp
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.IExp
                  BackEnd.Translate.$fShowIExp_$cshowsPrec
                  BackEnd.Translate.$fShowIExp_$cshow
                  BackEnd.Translate.$fShowIExp_$cshowList -}
a20cdd6bf7f08c3bd03a952c60fbdef2
  $fShowIExp1 ::
    BackEnd.Translate.IExp -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (x :: BackEnd.Translate.IExp)
                   (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (BackEnd.Translate.$fShowIExp_$cshow x)
                   s) -}
80bffe3681738f2ef4cd76c5ef4635ba
  $fShowIExp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_"#) -}
a20cdd6bf7f08c3bd03a952c60fbdef2
  $fShowIExp_$cshow :: BackEnd.Translate.IExp -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: BackEnd.Translate.IExp) ->
                 case ds of wild {
                   BackEnd.Translate.Ex e
                   -> GHC.CString.unpackAppendCString#
                        "Ex "#
                        (case BackEnd.IR.$w$ctoTree e of ww { (#,#) ww1 ww2 ->
                         Data.OldList.unlines
                           (GHC.Types.:
                              @ GHC.Base.String
                              ww1
                              (Data.Tree.drawTree_drawSubTrees ww2)) })
                   BackEnd.Translate.Nx s
                   -> GHC.CString.unpackAppendCString#
                        "Nx "#
                        (case BackEnd.IR.$w$ctoTree1 s of ww { (#,#) ww1 ww2 ->
                         Data.OldList.unlines
                           (GHC.Types.:
                              @ GHC.Base.String
                              ww1
                              (Data.Tree.drawTree_drawSubTrees ww2)) })
                   BackEnd.Translate.Cx f1
                   -> GHC.CString.unpackAppendCString#
                        "Cx "#
                        (case BackEnd.IR.$w$ctoTree1
                                (f1
                                   BackEnd.Translate.$fShowIExp2
                                   BackEnd.Translate.$fShowIExp2) of ww { (#,#) ww1 ww2 ->
                         Data.OldList.unlines
                           (GHC.Types.:
                              @ GHC.Base.String
                              ww1
                              (Data.Tree.drawTree_drawSubTrees ww2)) }) }) -}
a20cdd6bf7f08c3bd03a952c60fbdef2
  $fShowIExp_$cshowList :: [BackEnd.Translate.IExp] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [BackEnd.Translate.IExp])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ BackEnd.Translate.IExp
                   BackEnd.Translate.$fShowIExp1
                   ls
                   s) -}
a20cdd6bf7f08c3bd03a952c60fbdef2
  $fShowIExp_$cshowsPrec ::
    GHC.Types.Int -> BackEnd.Translate.IExp -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: BackEnd.Translate.IExp)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (BackEnd.Translate.$fShowIExp_$cshow x))
                   s) -}
02827ddec16ce06b553862cfc961c00c
  $fShowLevel :: GHC.Show.Show BackEnd.Translate.Level
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.Level
                  BackEnd.Translate.$fShowLevel_$cshowsPrec
                  BackEnd.Translate.$fShowLevel_$cshow
                  BackEnd.Translate.$fShowLevel_$cshowList -}
02827ddec16ce06b553862cfc961c00c
  $fShowLevel1 :: BackEnd.Translate.Level -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: BackEnd.Translate.Level) ->
                 case w of ww { BackEnd.Translate.Level ww1 ww2 ww3 ->
                 BackEnd.Translate.$w$cshowsPrec2 0# ww1 ww2 ww3 }) -}
08e4a7ce0132fbb8e6173a5c7c3d7071
  $fShowLevel2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
e5315a83de13628cbd171c5a9167f6bb
  $fShowLevel3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "funTable = "#) -}
0e2bd45d0d507a5d2e047e0f7afd50cc
  $fShowLevel4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "varTable = "#) -}
851222dec1dddc064d15536f670b386a
  $fShowLevel5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
908586cef6eb2b32b26a755ea433d8d3
  $fShowLevel6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "levelFrame = "#) -}
cf23db0e829bd312f5294e0a10333200
  $fShowLevel7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Level {"#) -}
02827ddec16ce06b553862cfc961c00c
  $fShowLevel_$cshow :: BackEnd.Translate.Level -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U,U(U)),1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: BackEnd.Translate.Level) ->
                 BackEnd.Translate.$fShowLevel_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
02827ddec16ce06b553862cfc961c00c
  $fShowLevel_$cshowList ::
    [BackEnd.Translate.Level] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BackEnd.Translate.Level
                   BackEnd.Translate.$fShowLevel1) -}
02827ddec16ce06b553862cfc961c00c
  $fShowLevel_$cshowsPrec ::
    GHC.Types.Int -> BackEnd.Translate.Level -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U(U,U(U)),1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: BackEnd.Translate.Level) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { BackEnd.Translate.Level ww3 ww4 ww5 ->
                 BackEnd.Translate.$w$cshowsPrec2 ww1 ww3 ww4 ww5 } }) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fShowTranslateState ::
    GHC.Show.Show BackEnd.Translate.TranslateState
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BackEnd.Translate.TranslateState
                  BackEnd.Translate.$fShowTranslateState_$cshowsPrec
                  BackEnd.Translate.$fShowTranslateState_$cshow
                  BackEnd.Translate.$fShowTranslateState_$cshowList -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fShowTranslateState1 ::
    BackEnd.Translate.TranslateState -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 case w of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 BackEnd.Translate.$w$cshowsPrec3
                   0#
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8 }) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fShowTranslateState_$cshow ::
    BackEnd.Translate.TranslateState -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(U,U,U,U(U(U)),U(U(U)),U(U(U)),U(U(U)),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: BackEnd.Translate.TranslateState) ->
                 BackEnd.Translate.$fShowTranslateState_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fShowTranslateState_$cshowList ::
    [BackEnd.Translate.TranslateState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BackEnd.Translate.TranslateState
                   BackEnd.Translate.$fShowTranslateState1) -}
657e9bfe2f8caac8e8d4eff1de10e4b4
  $fShowTranslateState_$cshowsPrec ::
    GHC.Types.Int -> BackEnd.Translate.TranslateState -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S(S),1*U(U)><S,1*U(U,U,U,U(U(U)),U(U(U)),U(U(U)),U(U(U)),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { BackEnd.Translate.TranslateState ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BackEnd.Translate.$w$cshowsPrec3
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 } }) -}
b07d4a855b56159ab9e357529ad05ee9
  $sinsert_$sgo5 ::
    GHC.Types.Int
    -> Data.Set.Base.Set GHC.Types.Int
    -> Data.Set.Base.Set GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Data.Set.Base.Set GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BackEnd.Translate.$w$sgo5 ww1 w1 }) -}
b6c15ce7d8cc580e1c222d35af7c8fd0
  $tc'Access :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15129126469875502023##
                   16831915540550476079##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'Access1) -}
872491b943dab62c4262ac16a3b7f5f3
  $tc'Access1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Access"#) -}
cef6cfa1306872368d32fa9fa81de023
  $tc'Cx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9238119009216641882##
                   15478640514011169257##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'Cx1) -}
d5dcb4124a413beb70d7aa4c36c86710
  $tc'Cx1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Cx"#) -}
359008b6a16ba116d6a12a5110ffe971
  $tc'Ex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18028159084097258147##
                   13603545229807252463##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'Ex1) -}
bbc6a7df104f5729c19902c6b645bdd7
  $tc'Ex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Ex"#) -}
d905c8cb29263eea73b1553d635924f7
  $tc'FunEntry :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5130500472379462170##
                   14707746121057516542##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'FunEntry1) -}
2a4c68150438a0fa90b19d604d9bc5ab
  $tc'FunEntry1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FunEntry"#) -}
e0776a8c356dcdc564592115faf1163f
  $tc'Level :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12830468959837126847##
                   12379549629602681972##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'Level1) -}
1bf1fd5cc4d641d31e6ec32390eb6b9c
  $tc'Level1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Level"#) -}
bda0883aad8e7bbb5c0447868976a9a8
  $tc'Nx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12136359662859626696##
                   13187250899047184550##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'Nx1) -}
7fa5e2e67086308a49fec497c66eaa3a
  $tc'Nx1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nx"#) -}
36f9ce8dc1f10652929305836dd4b309
  $tc'TranslateState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1261075961075835088##
                   11433494335050521808##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'TranslateState1) -}
bd4dbda42cacb4df3bcdc7c5b1eae909
  $tc'TranslateState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TranslateState"#) -}
535b492648fd3fc901f1612abb5df71a
  $tc'VarEntry :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12102249789079519417##
                   8104483052533166825##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tc'VarEntry1) -}
6870bfb712179b93fd511b1b2b550506
  $tc'VarEntry1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VarEntry"#) -}
a635d38a88ef3b496defc20e4e6b28cd
  $tcAccess :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16361470966337822389##
                   17811031552375147463##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tcAccess1) -}
33b7a3c895629f2f01b6825267e1e6e8
  $tcAccess1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Access"#) -}
f811eb0843f6bc6ddf840820f26c8d90
  $tcEnvEntry :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5970352407860733301##
                   12097128234061213781##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tcEnvEntry1) -}
586527563c0b3d76302d6f1e1acc4d6c
  $tcEnvEntry1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "EnvEntry"#) -}
2e983a2f30ed4f15cde3eddd5a8c15e0
  $tcIExp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4910961793457540053##
                   16217707818642509806##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tcIExp1) -}
fdeb6a217cb5427aba3f49fb59a20415
  $tcIExp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "IExp"#) -}
90bbab1aa7f7a7084ad39c7bb091c328
  $tcLevel :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14556233144133074646##
                   6999493067639189157##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tcLevel1) -}
42c9f52b4309cb7a3b1c2511910b4f9f
  $tcLevel1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Level"#) -}
6c3a4c227f57b289c798b06b010582f5
  $tcTranslateState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15721471221988878569##
                   11242604543805622526##
                   BackEnd.Translate.$trModule
                   BackEnd.Translate.$tcTranslateState1) -}
88caaef0195ce12f143804028eef7d74
  $tcTranslateState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TranslateState"#) -}
d359446cd1681e62709d85752d5d267c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   BackEnd.Translate.$trModule2
                   BackEnd.Translate.$trModule1) -}
4a9a1c8e6353e79020b61a0ff02abeaf
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BackEnd.Translate"#) -}
b0b458a4b541aff75ae480932ed76059
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2"#) -}
d6a38d559e7a79a46a761e7416453c05
  $w$c/= ::
    GHC.Base.String
    -> GHC.Types.Int
    -> BackEnd.Frame.Access
    -> GHC.Base.String
    -> GHC.Types.Int
    -> BackEnd.Frame.Access
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: BackEnd.Frame.Access)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: BackEnd.Frame.Access) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case ww2 of wild4 {
                             BackEnd.Frame.InFrame a1
                             -> case ww5 of wild5 {
                                  BackEnd.Frame.InFrame b1
                                  -> case a1 of wild6 { GHC.Types.I# x1 ->
                                     case b1 of wild7 { GHC.Types.I# y1 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild8 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True -> GHC.Types.False } } }
                                  BackEnd.Frame.InReg ipv -> GHC.Types.True }
                             BackEnd.Frame.InReg a1
                             -> case ww5 of wild5 {
                                  BackEnd.Frame.InFrame ipv -> GHC.Types.True
                                  BackEnd.Frame.InReg b1
                                  -> case a1 of wild6 { GHC.Types.I# x1 ->
                                     case b1 of wild7 { GHC.Types.I# y1 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild8 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True -> GHC.Types.False } } } } } } } } }) -}
bca50148cd9ca6edd60878273a0fe811
  $w$c== ::
    GHC.Base.String
    -> GHC.Types.Int
    -> BackEnd.Frame.Access
    -> GHC.Base.String
    -> GHC.Types.Int
    -> BackEnd.Frame.Access
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: BackEnd.Frame.Access)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: BackEnd.Frame.Access) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> BackEnd.Frame.$fEqAccess_$c== ww2 ww5 } } } }) -}
f0142a605372ccb9f8dbabd5f93d3b42
  $w$c==1 ::
    GHC.Base.String
    -> GHC.Types.Int
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> GHC.Base.String
    -> GHC.Types.Int
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><L,1*U><S,1*U><L,1*U(U)><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry)
                   (ww3 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry)
                   (ww4 :: GHC.Base.String)
                   (ww5 :: GHC.Types.Int)
                   (ww6 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry)
                   (ww7 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry) ->
                 case GHC.Base.eqString ww ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww5 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case Data.IntMap.Base.equal
                                  @ (Data.HashMap.Some [GHC.Types.Char] BackEnd.Translate.EnvEntry)
                                  BackEnd.Translate.$fEqLevel1
                                  ww2
                                    `cast`
                                  (Data.HashMap.N:Map[0]
                                       <[GHC.Types.Char]>_N <BackEnd.Translate.EnvEntry>_R)
                                  ww6
                                    `cast`
                                  (Data.HashMap.N:Map[0]
                                       <[GHC.Types.Char]>_N
                                       <BackEnd.Translate.EnvEntry>_R) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Data.IntMap.Base.equal
                                  @ (Data.HashMap.Some [GHC.Types.Char] BackEnd.Translate.EnvEntry)
                                  BackEnd.Translate.$fEqLevel1
                                  ww3
                                    `cast`
                                  (Data.HashMap.N:Map[0]
                                       <[GHC.Types.Char]>_N <BackEnd.Translate.EnvEntry>_R)
                                  ww7
                                    `cast`
                                  (Data.HashMap.N:Map[0]
                                       <[GHC.Types.Char]>_N
                                       <BackEnd.Translate.EnvEntry>_R) } } } } }) -}
bc196a91af2cf37e01785aa1df01935b
  $w$c==2 ::
    [BackEnd.Translate.Level]
    -> [BackEnd.Frame.Fragment]
    -> [BackEnd.Frame.Fragment]
    -> BackEnd.Temp.TempAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> Data.Set.Base.Set GHC.Types.Int
    -> [BackEnd.Translate.Level]
    -> [BackEnd.Frame.Fragment]
    -> [BackEnd.Frame.Fragment]
    -> BackEnd.Temp.TempAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> Data.Set.Base.Set GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 16,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U(1*U(U))><L,1*U(1*U(U))><L,1*U(1*U(U))><L,1*U(1*U(U))><L,U><S,1*U><L,1*U><L,1*U><L,1*U(1*U(U))><L,1*U(1*U(U))><L,1*U(1*U(U))><L,1*U(1*U(U))><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [BackEnd.Translate.Level])
                   (ww1 :: [BackEnd.Frame.Fragment])
                   (ww2 :: [BackEnd.Frame.Fragment])
                   (ww3 :: BackEnd.Temp.TempAllocator)
                   (ww4 :: BackEnd.Temp.LabelAllocator)
                   (ww5 :: BackEnd.Temp.LabelAllocator)
                   (ww6 :: BackEnd.Temp.LabelAllocator)
                   (ww7 :: Data.Set.Base.Set GHC.Types.Int)
                   (ww8 :: [BackEnd.Translate.Level])
                   (ww9 :: [BackEnd.Frame.Fragment])
                   (ww10 :: [BackEnd.Frame.Fragment])
                   (ww11 :: BackEnd.Temp.TempAllocator)
                   (ww12 :: BackEnd.Temp.LabelAllocator)
                   (ww13 :: BackEnd.Temp.LabelAllocator)
                   (ww14 :: BackEnd.Temp.LabelAllocator)
                   (ww15 :: Data.Set.Base.Set GHC.Types.Int) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ BackEnd.Translate.Level
                        BackEnd.Translate.$fEqLevel
                        ww
                        ww8 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ BackEnd.Frame.Fragment
                             BackEnd.Frame.$fEqFragment
                             ww1
                             ww9 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ BackEnd.Frame.Fragment
                                  BackEnd.Frame.$fEqFragment
                                  ww2
                                  ww10 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww3 of wild3 { BackEnd.Temp.TempAllocator a1 ->
                                case ww11 of wild4 { BackEnd.Temp.TempAllocator b1 ->
                                case a1 of wild5 { GHC.Types.I# x ->
                                case b1 of wild6 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild7 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww4 of wild8 { BackEnd.Temp.LabelAllocator a2 ->
                                     case ww12 of wild9 { BackEnd.Temp.LabelAllocator b2 ->
                                     case a2 of wild10 { GHC.Types.I# x1 ->
                                     case b2 of wild11 { GHC.Types.I# y1 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild12 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case ww5 of wild13 { BackEnd.Temp.LabelAllocator a3 ->
                                          case ww13 of wild14 { BackEnd.Temp.LabelAllocator b3 ->
                                          case a3 of wild15 { GHC.Types.I# x2 ->
                                          case b3 of wild16 { GHC.Types.I# y2 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# x2 y2) of wild17 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case ww6 of wild18 { BackEnd.Temp.LabelAllocator a4 ->
                                               case ww14 of wild19 { BackEnd.Temp.LabelAllocator b4 ->
                                               case a4 of wild20 { GHC.Types.I# x3 ->
                                               case b4 of wild21 { GHC.Types.I# y3 ->
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.==# x3 y3) of wild22 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> Data.Set.Base.$fEqSet_$c==
                                                      @ GHC.Types.Int
                                                      GHC.Classes.$fEqInt
                                                      ww7
                                                      ww15 } } } } } } } } } } } } } } } } } } } } } } }) -}
0fa4a6dfb32c3bc50ace71d133013f2d
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> BackEnd.Frame.Frame
    -> BackEnd.Frame.Access
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(1*U,1*U(U))><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: BackEnd.Frame.Frame)
                   (ww2 :: BackEnd.Frame.Access)
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     case ww1 of ww3 { BackEnd.Frame.Frame ww4 ww5 ->
                     BackEnd.Frame.$w$cshowsPrec2
                       11#
                       ww4
                       ww5
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (BackEnd.Frame.$w$cshowsPrec 11# ww2 x)) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        BackEnd.Translate.$fShowAccess2
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           BackEnd.Translate.$fShowAccess2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w))) }) -}
0120b873deaf0cf2fe559075fc860092
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> BackEnd.Translate.EnvEntry -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: BackEnd.Translate.EnvEntry)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   BackEnd.Translate.VarEntry b1 b2
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            BackEnd.Translate.$fShowEnvEntry3
                            (case b1 of ww1 { BackEnd.Translate.Access ww2 ww3 ->
                             BackEnd.Translate.$w$cshowsPrec
                               11#
                               ww2
                               ww3
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (FrontEnd.AST.$fShowFunc_$cshow b2)
                                     x)) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w1)) }
                   BackEnd.Translate.FunEntry b1 b2 b3
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            BackEnd.Translate.$fShowEnvEntry2
                            (case b1 of ww2 { BackEnd.Frame.Frame ww3 ww4 ->
                             BackEnd.Frame.$w$cshowsPrec2
                               11#
                               ww3
                               ww4
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showSpace1
                                              (GHC.Base.++
                                                 @ GHC.Types.Char
                                                 (FrontEnd.AST.$fShowFunc_$cshow b3)
                                                 x)))))) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w1)) } }) -}
3465cf5b6586db7955090f390312f355
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> BackEnd.Frame.Frame
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,U(U,U(U))><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: BackEnd.Frame.Frame)
                   (ww2 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry)
                   (ww3 :: Data.HashMap.Map
                             GHC.Base.String BackEnd.Translate.EnvEntry) ->
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = Data.HashMap.$w$cshowsPrec
                       @ [GHC.Types.Char]
                       @ BackEnd.Translate.EnvEntry
                       GHC.Show.$fShow[]_$s$fShow[]1
                       BackEnd.Translate.$fShowEnvEntry
                       0#
                       ww2
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = Data.HashMap.$w$cshowsPrec
                       @ [GHC.Types.Char]
                       @ BackEnd.Translate.EnvEntry
                       GHC.Show.$fShow[]_$s$fShow[]1
                       BackEnd.Translate.$fShowEnvEntry
                       0#
                       ww3
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BackEnd.Translate.$fShowLevel7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BackEnd.Translate.$fShowLevel6
                          (case ww1 of ww4 { BackEnd.Frame.Frame ww5 ww6 ->
                           BackEnd.Frame.$w$cshowsPrec2
                             0#
                             ww5
                             ww6
                             (GHC.Base.++
                                @ GHC.Types.Char
                                BackEnd.Translate.$fShowLevel5
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   BackEnd.Translate.$fShowLevel4
                                   (f1
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         BackEnd.Translate.$fShowLevel5
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            BackEnd.Translate.$fShowLevel3
                                            (f2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  BackEnd.Translate.$fShowLevel2
                                                  x))))))) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
468bf6eb766021cb09c9355a847477fb
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> [BackEnd.Translate.Level]
    -> [BackEnd.Frame.Fragment]
    -> [BackEnd.Frame.Fragment]
    -> BackEnd.Temp.TempAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> Data.Set.Base.Set GHC.Types.Int
    -> GHC.Show.ShowS
  {- Arity: 9,
     Strictness: <S,U><L,U><L,U><L,U><L,U(U(U))><L,U(U(U))><L,U(U(U))><L,U(U(U))><L,1*U>,
     Inline: [0] -}
fd753cd05f3d05f59b137f7224442c52
  $w$sgo5 ::
    GHC.Prim.Int#
    -> Data.Set.Base.Set GHC.Types.Int
    -> Data.Set.Base.Set GHC.Types.Int
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
9ad46472fb3d21680b02447588de05fe
  $wgetVarEntry ::
    GHC.Base.String
    -> [BackEnd.Translate.Level]
    -> [BackEnd.Frame.Fragment]
    -> [BackEnd.Frame.Fragment]
    -> BackEnd.Temp.TempAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> BackEnd.Temp.LabelAllocator
    -> Data.Set.Base.Set GHC.Types.Int
    -> (# BackEnd.IR.Exp, BackEnd.Translate.TranslateState #)
  {- Arity: 9,
     Strictness: <L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
3dcb5e0af78d9fcd308b16adde9b7332
  $wgo ::
    [FrontEnd.AST.FuncF ()]
    -> BackEnd.Translate.TranslateState
    -> (# [()], BackEnd.Translate.TranslateState #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
e98e6a18c33a30d43c222dfac08070c3
  $wgo1 ::
    [BackEnd.Translate.IExp]
    -> BackEnd.Translate.TranslateState
    -> (# [BackEnd.IR.Stm], BackEnd.Translate.TranslateState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U(U(U)),U,U,U)>,
     Inline: [0] -}
a29691eec87a74a11089f9acd854da05
  $wgo2 ::
    [BackEnd.Translate.IExp]
    -> BackEnd.Translate.TranslateState
    -> (# [BackEnd.IR.Exp], BackEnd.Translate.TranslateState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U,U,U,U)>, Inline: [0] -}
7959cde49854b36fe578a666252899e4
  $wnewLevel ::
    BackEnd.Translate.TranslateState
    -> (# BackEnd.Translate.Level, BackEnd.Translate.TranslateState #)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,1*U(U(U)),U)>, Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds7 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewFrameLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 (# BackEnd.Translate.Level
                      (BackEnd.Frame.Frame
                         (case ds of wild { (,) alloc label -> label })
                         BackEnd.Frame.rv)
                      (Data.IntMap.Base.Nil
                         @ (Data.HashMap.Some GHC.Base.String BackEnd.Translate.EnvEntry))
                        `cast`
                      (Sym (Data.HashMap.N:Map[0]
                                <GHC.Base.String>_N <BackEnd.Translate.EnvEntry>_R))
                      (Data.IntMap.Base.Nil
                         @ (Data.HashMap.Some GHC.Base.String BackEnd.Translate.EnvEntry))
                        `cast`
                      (Sym (Data.HashMap.N:Map[0]
                                <GHC.Base.String>_N <BackEnd.Translate.EnvEntry>_R)),
                    case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                    BackEnd.Translate.TranslateState
                      ds1
                      ds2
                      ds3
                      ds4
                      ds5
                      ds6
                      (case ds of wild1 { (,) alloc label -> alloc })
                      ds8 } #)) -}
1510f0e789dbf716943e89d9559bf895
  $wtranslateBuiltInFuncAppF ::
    FrontEnd.AST.Type
    -> FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ExprF ()]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <L,U><L,1*U(1*U(1*U),A)><L,1*U>,
     Inline: [0] -}
c9f3470cea1d5c83c32ec4750997d5fc
  $wtranslateExprF ::
    FrontEnd.AST.Expr ()
    -> (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type)
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 2, Strictness: <S,1*U><L,1*U(A,U)>, Inline: [0] -}
6203fed42340e0b1ddbcca5d4d7574b7
  $wtranslateFuncAppF ::
    FrontEnd.AST.Type
    -> FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ExprF ()]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <L,U><L,U(U(U),A)><L,U>, Inline: [0],
     Unfolding: (\ (ww :: FrontEnd.AST.Type)
                   (ww1 :: FrontEnd.AST.IdentF ())
                   (ww2 :: [FrontEnd.AST.ExprF ()]) ->
                 let {
                   symbol :: GHC.Base.String
                   = case ww1 of wild { FrontEnd.AST.Ann ds ds1 ->
                     case ds of wild1 { FrontEnd.AST.Ident symbol1 -> symbol1 } }
                 } in
                 case GHC.List.elem
                        @ GHC.Base.String
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        symbol
                        BackEnd.Translate.translateFuncAppF1 of wild {
                   GHC.Types.False
                   -> let {
                        lvl81 :: BackEnd.IR.Exp = BackEnd.IR.NAME symbol
                      } in
                      let {
                        m1 :: Control.Monad.Trans.State.Lazy.StateT
                                BackEnd.Translate.TranslateState
                                Data.Functor.Identity.Identity
                                [BackEnd.Translate.IExp]
                        = BackEnd.Translate.translateFuncAppF_go ww2
                      } in
                      (\ (s1 :: BackEnd.Translate.TranslateState) ->
                       let {
                         ds :: Data.Functor.Identity.Identity
                                 ([BackEnd.IR.Exp], BackEnd.Translate.TranslateState)
                         = case (m1
                                   `cast`
                                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <BackEnd.Translate.TranslateState>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <[BackEnd.Translate.IExp]>_N)
                                   s1)
                                  `cast`
                                (Data.Functor.Identity.N:Identity[0]
                                     <([BackEnd.Translate.IExp],
                                       BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                           case BackEnd.Translate.$wgo2 a1 s' of ww3 { (#,#) ww4 ww5 ->
                           (ww4, ww5)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <([BackEnd.IR.Exp], BackEnd.Translate.TranslateState)>_R)) } }
                       } in
                       (BackEnd.Translate.Ex
                          (BackEnd.IR.CALL
                             lvl81
                             (case ds
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <([BackEnd.IR.Exp],
                                          BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                              a1 })),
                        case ds
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <([BackEnd.IR.Exp],
                                    BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                        s' })
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <(BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)>_R)))
                        `cast`
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <BackEnd.Translate.TranslateState>_N
                                <Data.Functor.Identity.Identity>_R
                                <BackEnd.Translate.IExp>_N))
                   GHC.Types.True
                   -> BackEnd.Translate.$wtranslateBuiltInFuncAppF ww ww1 ww2 }) -}
02fdb7c6eaca8bc6c89a7723fe2dc824
  $wtranslateFuncF ::
    FrontEnd.AST.Type
    -> FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ParamF ()]
    -> FrontEnd.AST.StatListF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 4,
     Strictness: <L,U><L,1*U(1*U(1*U),A)><L,1*U><L,1*U(1*U(1*U),A)>,
     Inline: [0] -}
ca463d50adf762a722cef3f63ac3f4dc
  $wtranslatePrint ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> (# BackEnd.Translate.IExp, BackEnd.Translate.TranslateState #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   DEFAULT
                   -> (# BackEnd.Translate.Ex
                           (BackEnd.IR.CALL BackEnd.Translate.translatePrint10 w1),
                         case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         BackEnd.Translate.TranslateState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (BackEnd.Translate.$w$sgo5 4# ds7) } #)
                   FrontEnd.AST.TInt
                   -> (# BackEnd.Translate.Ex
                           (BackEnd.IR.CALL BackEnd.Translate.translatePrint8 w1),
                         case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         BackEnd.Translate.TranslateState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (BackEnd.Translate.$w$sgo5 1# ds7) } #)
                   FrontEnd.AST.TBool
                   -> (# BackEnd.Translate.Ex
                           (BackEnd.IR.CALL BackEnd.Translate.translatePrint6 w1),
                         case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         BackEnd.Translate.TranslateState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (BackEnd.Translate.$w$sgo5 2# ds7) } #)
                   FrontEnd.AST.TChar
                   -> (# BackEnd.Translate.Ex
                           (BackEnd.IR.CALL BackEnd.Translate.translatePrint4 w1),
                         w2 #)
                   FrontEnd.AST.TStr
                   -> (# BackEnd.Translate.Ex
                           (BackEnd.IR.CALL BackEnd.Translate.translatePrint2 w1),
                         case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                         BackEnd.Translate.TranslateState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (BackEnd.Translate.$w$sgo5 3# ds7) } #)
                   FrontEnd.AST.TArray ds
                   -> case ds of wild1 {
                        DEFAULT
                        -> (# BackEnd.Translate.Ex
                                (BackEnd.IR.CALL BackEnd.Translate.translatePrint10 w1),
                              case w2 of wild2 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                              BackEnd.Translate.TranslateState
                                ds1
                                ds2
                                ds3
                                ds4
                                ds5
                                ds6
                                ds7
                                (BackEnd.Translate.$w$sgo5 4# ds8) } #)
                        FrontEnd.AST.TChar
                        -> (# BackEnd.Translate.Ex
                                (BackEnd.IR.CALL BackEnd.Translate.translatePrint2 w1),
                              w2 #) } }) -}
7e4f03312c110d6db7430d187544ab4d
  $wtranslatePrintln ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> (# BackEnd.Translate.IExp, BackEnd.Translate.TranslateState #)
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           (BackEnd.IR.Exp, BackEnd.Translate.TranslateState)
                   = case BackEnd.Translate.$wtranslatePrint
                            w
                            w1
                            w2 of ww { (#,#) ww1 ww2 ->
                     case BackEnd.Translate.$wunEx ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                     (ww4, ww5)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <(BackEnd.IR.Exp, BackEnd.Translate.TranslateState)>_R)) } }
                 } in
                 (# BackEnd.Translate.Nx
                      (BackEnd.IR.SEQ
                         (BackEnd.IR.EXP
                            (case ds
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <(BackEnd.IR.Exp,
                                         BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                             a1 }))
                         BackEnd.Translate.translatePrintln2),
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(BackEnd.IR.Exp,
                                BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                    case s' of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                    BackEnd.Translate.TranslateState
                      ds1
                      ds2
                      ds3
                      ds4
                      ds5
                      ds6
                      ds7
                      (BackEnd.Translate.$w$sgo5 0# ds8) } } #)) -}
b7cd176f3b99881fe76c9647f7f03a16
  $wtranslateProgramF ::
    [FrontEnd.AST.FuncF ()]
    -> FrontEnd.AST.StatListF ()
    -> BackEnd.Translate.TranslateState
    -> (# BackEnd.IR.Stm, BackEnd.Translate.TranslateState #)
  {- Arity: 3,
     Strictness: <L,1*U><L,1*U(1*U(1*U),A)><L,1*U(U,U,U,U,U,U,1*U(U(U)),U)>,
     Inline: [0],
     Unfolding: (\ (ww :: [FrontEnd.AST.FuncF ()])
                   (ww1 :: FrontEnd.AST.StatListF ())
                   (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
                   = case ww1 of ww2 { FrontEnd.AST.Ann ww3 ww4 ->
                     case ww3 of ww5 { FrontEnd.AST.StatList ww6 ->
                     case ((BackEnd.Translate.$wtranslateStatListF ww6)
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <BackEnd.Translate.TranslateState>_N
                                <Data.Functor.Identity.Identity>_R
                                <BackEnd.Translate.IExp>_N)
                             (case BackEnd.Translate.$wgo
                                     ww
                                     (case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                                      let {
                                        ds9 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                                        = case ds7 of ww7 { BackEnd.Temp.LabelAllocator ww8 ->
                                          case BackEnd.Temp.$wnewFrameLabel
                                                 ww8 of ww9 { (#,#) ww10 ww11 ->
                                          (ww10, ww11) } }
                                      } in
                                      BackEnd.Translate.TranslateState
                                        (GHC.Types.:
                                           @ BackEnd.Translate.Level
                                           (BackEnd.Translate.Level
                                              (BackEnd.Frame.Frame
                                                 (case ds9 of wild1 { (,) alloc label -> label })
                                                 BackEnd.Frame.rv)
                                              (Data.IntMap.Base.Nil
                                                 @ (Data.HashMap.Some
                                                      GHC.Base.String BackEnd.Translate.EnvEntry))
                                                `cast`
                                              (Sym (Data.HashMap.N:Map[0]
                                                        <GHC.Base.String>_N
                                                        <BackEnd.Translate.EnvEntry>_R))
                                              (Data.IntMap.Base.Nil
                                                 @ (Data.HashMap.Some
                                                      GHC.Base.String BackEnd.Translate.EnvEntry))
                                                `cast`
                                              (Sym (Data.HashMap.N:Map[0]
                                                        <GHC.Base.String>_N
                                                        <BackEnd.Translate.EnvEntry>_R)))
                                           ds1)
                                        ds2
                                        ds3
                                        ds4
                                        ds5
                                        ds6
                                        (case ds9 of wild1 { (,) alloc label -> alloc })
                                        ds8 }) of ww7 { (#,#) ww8 ww9 ->
                              ww9 }))
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(BackEnd.Translate.IExp,
                                 BackEnd.Translate.TranslateState)>_R) of ww7 { (,) ww8 ww9 ->
                     case BackEnd.Translate.$wunNx ww8 ww9 of ww10 { (#,#) ww11 ww12 ->
                     (ww11, ww12)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <(BackEnd.IR.Stm, BackEnd.Translate.TranslateState)>_R)) } } } }
                 } in
                 (# BackEnd.IR.SEQ
                      BackEnd.Translate.translate11
                      (BackEnd.IR.SEQ
                         (BackEnd.IR.SEQ
                            BackEnd.Translate.translate9
                            (case ds
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <(BackEnd.IR.Stm,
                                         BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                             a1 }))
                         (BackEnd.IR.SEQ
                            (case ds
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <(BackEnd.IR.Stm,
                                         BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                             case s' of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                             case ds1 of wild2 {
                               [] -> case GHC.List.badHead ret_ty BackEnd.IR.Stm of {}
                               : x ds9
                               -> case x of wild3 { BackEnd.Translate.Level ds10 ds11 ds12 ->
                                  case ds10 of wild4 { BackEnd.Frame.Frame ds13 ds14 ->
                                  case ds14 of wild5 { GHC.Types.I# x1 ->
                                  case x1 of wild6 {
                                    DEFAULT
                                    -> BackEnd.IR.MOV
                                         BackEnd.Translate.adjustSP2
                                         (BackEnd.IR.BINEXP
                                            BackEnd.IR.PLUS
                                            BackEnd.Translate.adjustSP2
                                            (BackEnd.IR.CONSTI wild5))
                                    0# -> BackEnd.IR.NOP } } } } } } })
                            BackEnd.Translate.translate3)),
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(BackEnd.IR.Stm,
                                BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                    case s' of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                    case ds1 of wild2 {
                      []
                      -> case GHC.List.badHead
                         ret_ty BackEnd.Translate.TranslateState
                         of {}
                      : x ds9
                      -> case x of wild3 { BackEnd.Translate.Level ds10 ds11 ds12 ->
                         case ds10 of wild4 { BackEnd.Frame.Frame ds13 ds14 ->
                         case ds14 of wild5 { GHC.Types.I# x1 ->
                         BackEnd.Translate.TranslateState
                           ds9
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           ds8 } } } } } } #)) -}
d91d14523b7b139b463371da9886d1cc
  $wtranslateStatF ::
    FrontEnd.AST.Stat ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
55f74c179ad8911cd32d042958042c4b
  $wtranslateStatListF ::
    [FrontEnd.AST.StatF ()]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [FrontEnd.AST.StatF ()]) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           BackEnd.Translate.TranslateState
                           Data.Functor.Identity.Identity
                           [BackEnd.Translate.IExp]
                   = BackEnd.Translate.translate_go ww
                 } in
                 (\ (s1 :: BackEnd.Translate.TranslateState) ->
                  let {
                    ds :: Data.Functor.Identity.Identity
                            ([BackEnd.IR.Stm], BackEnd.Translate.TranslateState)
                    = case (m1
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <BackEnd.Translate.TranslateState>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <[BackEnd.Translate.IExp]>_N)
                              s1)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <([BackEnd.Translate.IExp],
                                  BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                      case BackEnd.Translate.$wgo1 a1 s' of ww1 { (#,#) ww2 ww3 ->
                      (ww2, ww3)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <([BackEnd.IR.Stm], BackEnd.Translate.TranslateState)>_R)) } }
                  } in
                  (BackEnd.Translate.Nx
                     (case ds
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <([BackEnd.IR.Stm],
                                  BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                      BackEnd.Translate.seq a1 }),
                   case ds
                          `cast`
                        (Data.Functor.Identity.N:Identity[0]
                             <([BackEnd.IR.Stm],
                               BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                   s' })
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)>_R)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <BackEnd.Translate.TranslateState>_N
                           <Data.Functor.Identity.Identity>_R
                           <BackEnd.Translate.IExp>_N))) -}
41456eb884a9f72b9a338447b0e57480
  $wunEx ::
    BackEnd.Translate.IExp
    -> BackEnd.Translate.TranslateState
    -> (# BackEnd.IR.Exp, BackEnd.Translate.TranslateState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U,U,U,U)>, Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.IExp)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   BackEnd.Translate.Ex e -> (# e, w1 #)
                   BackEnd.Translate.Nx s
                   -> (# BackEnd.IR.ESEQ s BackEnd.Translate.translate7, w1 #)
                   BackEnd.Translate.Cx genStm
                   -> let {
                        ds :: (BackEnd.Temp.TempAllocator, BackEnd.Temp.Temp)
                        = case w1 of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          case ds4 of wild2 { BackEnd.Temp.TempAllocator i ->
                          (BackEnd.Temp.TempAllocator
                             (case i of wild3 { GHC.Types.I# x ->
                              GHC.Types.I# (GHC.Prim.+# x 1#) }),
                           i) } }
                      } in
                      let {
                        ds1 :: BackEnd.Translate.TranslateState
                        = case w1 of wild1 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                          BackEnd.Translate.TranslateState
                            ds2
                            ds3
                            ds4
                            (case ds of wild2 { (,) tempAlloc' temp -> tempAlloc' })
                            ds6
                            ds7
                            ds8
                            ds9 }
                      } in
                      let {
                        ds2 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                        = case ds1 of wild1 { BackEnd.Translate.TranslateState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                          case ds7 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                          case BackEnd.Temp.$wnewControlLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                          (ww3, ww4) } } }
                      } in
                      let {
                        s1 :: BackEnd.Translate.TranslateState
                        = case ds1 of wild1 { BackEnd.Translate.TranslateState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                          BackEnd.Translate.TranslateState
                            ds3
                            ds4
                            ds5
                            ds6
                            (case ds2 of wild2 { (,) alloc label -> alloc })
                            ds8
                            ds9
                            ds10 }
                      } in
                      let {
                        ds3 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                        = case s1 of wild1 { BackEnd.Translate.TranslateState ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                          case ds8 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                          case BackEnd.Temp.$wnewControlLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                          (ww3, ww4) } } }
                      } in
                      (# let {
                           ds4 :: BackEnd.Temp.Temp
                           = case ds of wild1 { (,) tempAlloc' temp -> temp }
                         } in
                         BackEnd.IR.ESEQ
                           (BackEnd.Translate.seq
                              (GHC.Types.:
                                 @ BackEnd.IR.Stm
                                 (BackEnd.IR.MOV
                                    (BackEnd.IR.TEMP ds4)
                                    BackEnd.Translate.translatePrintln6)
                                 (let {
                                    eta5 :: BackEnd.Temp.Label
                                    = case ds2 of wild1 { (,) alloc label -> label }
                                  } in
                                  let {
                                    eta6 :: BackEnd.Temp.Label
                                    = case ds3 of wild1 { (,) alloc label -> label }
                                  } in
                                  GHC.Types.:
                                    @ BackEnd.IR.Stm
                                    (genStm eta5 eta6)
                                    (GHC.Types.:
                                       @ BackEnd.IR.Stm
                                       (BackEnd.IR.LABEL eta6)
                                       (GHC.Types.:
                                          @ BackEnd.IR.Stm
                                          (BackEnd.IR.MOV
                                             (BackEnd.IR.TEMP ds4)
                                             BackEnd.Translate.translate7)
                                          (GHC.Types.:
                                             @ BackEnd.IR.Stm
                                             (BackEnd.IR.LABEL eta5)
                                             (GHC.Types.[] @ BackEnd.IR.Stm)))))))
                           (BackEnd.IR.TEMP ds4),
                         case s1 of wild1 { BackEnd.Translate.TranslateState ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                         BackEnd.Translate.TranslateState
                           ds4
                           ds5
                           ds6
                           ds7
                           (case ds3 of wild2 { (,) alloc label -> alloc })
                           ds9
                           ds10
                           ds11 } #) }) -}
93c463ca764904e9c3b958a90c2db09d
  $wunNx ::
    BackEnd.Translate.IExp
    -> BackEnd.Translate.TranslateState
    -> (# BackEnd.IR.Stm, BackEnd.Translate.TranslateState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U(U(U)),U,U,U)>, Inline: [0],
     Unfolding: (\ (w :: BackEnd.Translate.IExp)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   BackEnd.Translate.Ex e
                   -> let {
                        ds :: (BackEnd.Temp.TempAllocator, BackEnd.Temp.Temp)
                        = case w1 of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          case ds4 of wild2 { BackEnd.Temp.TempAllocator i ->
                          (BackEnd.Temp.TempAllocator
                             (case i of wild3 { GHC.Types.I# x ->
                              GHC.Types.I# (GHC.Prim.+# x 1#) }),
                           i) } }
                      } in
                      (# BackEnd.IR.MOV
                           (BackEnd.IR.TEMP
                              (case ds of wild1 { (,) tempAlloc' temp -> temp }))
                           e,
                         case w1 of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                         BackEnd.Translate.TranslateState
                           ds1
                           ds2
                           ds3
                           (case ds of wild2 { (,) tempAlloc' temp -> tempAlloc' })
                           ds5
                           ds6
                           ds7
                           ds8 } #)
                   BackEnd.Translate.Nx stm -> (# stm, w1 #)
                   BackEnd.Translate.Cx c
                   -> let {
                        ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                        = case w1 of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          case ds5 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                          case BackEnd.Temp.$wnewControlLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                          (ww3, ww4) } } }
                      } in
                      let {
                        s1 :: BackEnd.Translate.TranslateState
                        = case w1 of wild1 { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                          BackEnd.Translate.TranslateState
                            ds1
                            ds2
                            ds3
                            ds4
                            (case ds of wild2 { (,) alloc label -> alloc })
                            ds6
                            ds7
                            ds8 }
                      } in
                      let {
                        ds1 :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                        = case s1 of wild1 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                          case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                          case BackEnd.Temp.$wnewControlLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                          (ww3, ww4) } } }
                      } in
                      (# c (case ds of wild1 { (,) alloc label -> label })
                           (case ds1 of wild1 { (,) alloc label -> label }),
                         case s1 of wild1 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                         BackEnd.Translate.TranslateState
                           ds2
                           ds3
                           ds4
                           ds5
                           (case ds1 of wild2 { (,) alloc label -> alloc })
                           ds7
                           ds8
                           ds9 } #) }) -}
86da6bad0743b8f8af5eb4377d667e31
  data Access = Access BackEnd.Frame.Frame BackEnd.Frame.Access
0120b873deaf0cf2fe559075fc860092
  data EnvEntry
    = VarEntry BackEnd.Translate.Access FrontEnd.AST.Type
    | FunEntry BackEnd.Frame.Frame BackEnd.Temp.Label FrontEnd.AST.Type
a20cdd6bf7f08c3bd03a952c60fbdef2
  data IExp
    = Ex BackEnd.IR.Exp
    | Nx BackEnd.IR.Stm
    | Cx (BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm)
02827ddec16ce06b553862cfc961c00c
  data Level
    = Level {levelFrame :: BackEnd.Frame.Frame,
             varTable :: Data.HashMap.Map
                           GHC.Base.String BackEnd.Translate.EnvEntry,
             funTable :: Data.HashMap.Map
                           GHC.Base.String BackEnd.Translate.EnvEntry}
657e9bfe2f8caac8e8d4eff1de10e4b4
  data TranslateState
    = TranslateState {levels :: [BackEnd.Translate.Level],
                      dataFrags :: [BackEnd.Frame.Fragment],
                      procFrags :: [BackEnd.Frame.Fragment],
                      tempAlloc :: BackEnd.Temp.TempAllocator,
                      controlLabelAlloc :: BackEnd.Temp.LabelAllocator,
                      dataLabelAlloc :: BackEnd.Temp.LabelAllocator,
                      frameLabelAlloc :: BackEnd.Temp.LabelAllocator,
                      builtInSet :: Data.Set.Base.Set GHC.Types.Int}
6d8d0bfb2a5d7c7e2b954335205e83a0
  accessToMem :: BackEnd.Translate.Access -> BackEnd.IR.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.Access) ->
                 case ds of wild { BackEnd.Translate.Access ds1 access ->
                 case access of wild1 {
                   BackEnd.Frame.InFrame offset
                   -> BackEnd.IR.MEM
                        (BackEnd.IR.BINEXP
                           BackEnd.IR.PLUS
                           BackEnd.Translate.accessToMem1
                           (BackEnd.IR.CONSTI offset))
                   BackEnd.Frame.InReg tmp -> BackEnd.IR.TEMP tmp } }) -}
eb26afc8dee2a88675d0d29f3b355c1d
  accessToMem1 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Frame.fp) -}
16921683e7d77ff8361b24dfe7453310
  addBuiltIn ::
    GHC.Types.Int
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U(U,U,U,U,U,U,U,1*U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.addBuiltIn1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Trans
                          (<BackEnd.Translate.TranslateState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), BackEnd.Translate.TranslateState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <BackEnd.Translate.TranslateState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_N))) -}
b9427ece69433a8e3bafb0fc47f40b0d
  addBuiltIn1 ::
    GHC.Types.Int
    -> BackEnd.Translate.TranslateState
    -> ((), BackEnd.Translate.TranslateState)
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U(U,U,U,U,U,U,U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (id :: GHC.Types.Int)
                   (eta5 :: BackEnd.Translate.TranslateState) ->
                 (GHC.Tuple.(),
                  case eta5 of wild { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  BackEnd.Translate.TranslateState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (BackEnd.Translate.$sinsert_$sgo5 id ds7) })) -}
d3f5abf931bef1bef08d195eb1f58a4e
  addFragment ::
    BackEnd.Frame.Fragment
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.addFragment1
                  `cast`
                (<BackEnd.Frame.Fragment>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
60cee823160b64b9a1f81ae8daf6b0f6
  addFragment1 ::
    BackEnd.Frame.Fragment
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ((), BackEnd.Translate.TranslateState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U,U,U,U,U,U,U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Frame.Fragment)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   BackEnd.Frame.PROC ds ds1
                   -> (GHC.Tuple.(),
                       case w1 of wild1 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                       BackEnd.Translate.TranslateState
                         ds2
                         ds3
                         (GHC.Types.: @ BackEnd.Frame.Fragment wild ds4)
                         ds5
                         ds6
                         ds7
                         ds8
                         ds9 })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), BackEnd.Translate.TranslateState)>_R))
                   BackEnd.Frame.STRING ds ds1
                   -> (GHC.Tuple.(),
                       case w1 of wild1 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                       BackEnd.Translate.TranslateState
                         ds2
                         (GHC.Types.: @ BackEnd.Frame.Fragment wild ds3)
                         ds4
                         ds5
                         ds6
                         ds7
                         ds8
                         ds9 })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), BackEnd.Translate.TranslateState)>_R)) }) -}
6f34cd3597cb4f4ac5ee564ed41b6820
  addFunEntry ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 3,
     Strictness: <L,U><L,U><S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.addFunEntry1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <FrontEnd.AST.Type>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
0ebaf9d9f117bbff082724fcbb0bb80f
  addFunEntry1 ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ((), BackEnd.Translate.TranslateState)
  {- Arity: 3,
     Strictness: <L,U><L,U><S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case w2 of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case ww1 of wild {
                   []
                   -> case GHC.Err.error
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Functor.Identity.Identity
                                  ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState))
                             GHC.Err.errorWithoutStackTrace_wild1
                               `cast`
                             (Sym (GHC.Classes.N:IP[0]
                                       <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                             BackEnd.Translate.addFunEntry_str
                      ret_ty (Data.Functor.Identity.Identity
                                ((), BackEnd.Translate.TranslateState))
                      of {}
                   : ipv ipv1
                   -> (GHC.Tuple.(),
                       BackEnd.Translate.TranslateState
                         (GHC.Types.:
                            @ BackEnd.Translate.Level
                            (case ipv of wild1 { BackEnd.Translate.Level ds ds1 ds2 ->
                             BackEnd.Translate.Level
                               ds
                               ds1
                               (Data.HashMap.fromList1
                                  @ GHC.Base.String
                                  @ BackEnd.Translate.EnvEntry
                                  Data.Hashable.Class.$fHashable[]_$s$fHashable[]
                                  GHC.Classes.$fOrd[]_$s$fOrd[]1
                                  w
                                  (BackEnd.Translate.FunEntry ds w w1)
                                  ds2)
                                 `cast`
                               (Sym (Data.HashMap.N:Map[0]
                                         <GHC.Base.String>_N <BackEnd.Translate.EnvEntry>_R)) })
                            ipv1)
                         ww2
                         ww3
                         ww4
                         ww5
                         ww6
                         ww7
                         ww8)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), BackEnd.Translate.TranslateState)>_R)) } }) -}
55c2d27bf2e1a486ec33d212ff7d880e
  addFunEntry_str :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "no frames available"#) -}
9e1552e72a1e2e35f2627f71ad28d88e
  addVarEntry ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> BackEnd.Translate.Access
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 4,
     Strictness: <L,U><L,U><L,U><S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.addVarEntry1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <FrontEnd.AST.Type>_R
                 ->_R <BackEnd.Translate.Access>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
ac269b5f4f94d165b2cea1fb8de6972a
  addVarEntry1 ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> BackEnd.Translate.Access
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ((), BackEnd.Translate.TranslateState)
  {- Arity: 4,
     Strictness: <L,U><L,U><L,U><S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: BackEnd.Translate.Access)
                   (w3 :: BackEnd.Translate.TranslateState) ->
                 case w3 of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case ww1 of wild {
                   []
                   -> case GHC.Err.error
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Functor.Identity.Identity
                                  ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState))
                             GHC.Err.errorWithoutStackTrace_wild1
                               `cast`
                             (Sym (GHC.Classes.N:IP[0]
                                       <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                             BackEnd.Translate.addFunEntry_str
                      ret_ty (Data.Functor.Identity.Identity
                                ((), BackEnd.Translate.TranslateState))
                      of {}
                   : ipv ipv1
                   -> (GHC.Tuple.(),
                       BackEnd.Translate.TranslateState
                         (GHC.Types.:
                            @ BackEnd.Translate.Level
                            (case ipv of wild1 { BackEnd.Translate.Level ds ds1 ds2 ->
                             BackEnd.Translate.Level
                               ds
                               (Data.HashMap.fromList1
                                  @ GHC.Base.String
                                  @ BackEnd.Translate.EnvEntry
                                  Data.Hashable.Class.$fHashable[]_$s$fHashable[]
                                  GHC.Classes.$fOrd[]_$s$fOrd[]1
                                  w
                                  (BackEnd.Translate.VarEntry w2 w1)
                                  ds1)
                                 `cast`
                               (Sym (Data.HashMap.N:Map[0]
                                         <GHC.Base.String>_N <BackEnd.Translate.EnvEntry>_R))
                               ds2 })
                            ipv1)
                         ww2
                         ww3
                         ww4
                         ww5
                         ww6
                         ww7
                         ww8)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), BackEnd.Translate.TranslateState)>_R)) } }) -}
df72aebac8582190dd5544bab4f4300a
  adjustSP ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.IR.Stm
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.adjustSP1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.IR.Stm>_N)) -}
05d71aa72b60e88d9cb4b67ef57a7bec
  adjustSP1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case w of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case ww1 of wild {
                   []
                   -> case GHC.List.badHead
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.IR.Stm, BackEnd.Translate.TranslateState))
                      of {}
                   : x ds1
                   -> case x of wild1 { BackEnd.Translate.Level ds ds2 ds3 ->
                      case ds of wild2 { BackEnd.Frame.Frame ds4 ds5 ->
                      case ds5 of wild3 { GHC.Types.I# x1 ->
                      case x1 of wild4 {
                        DEFAULT
                        -> (BackEnd.IR.MOV
                              BackEnd.Translate.adjustSP2
                              (BackEnd.IR.BINEXP
                                 BackEnd.IR.PLUS
                                 BackEnd.Translate.adjustSP2
                                 (BackEnd.IR.CONSTI wild3)),
                            BackEnd.Translate.TranslateState wild ww2 ww3 ww4 ww5 ww6 ww7 ww8)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(BackEnd.IR.Stm, BackEnd.Translate.TranslateState)>_R))
                        0#
                        -> (BackEnd.IR.NOP,
                            BackEnd.Translate.TranslateState wild ww2 ww3 ww4 ww5 ww6 ww7 ww8)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(BackEnd.IR.Stm,
                                       BackEnd.Translate.TranslateState)>_R)) } } } } } }) -}
51089229c28e664efe22bc0e6f5abf32
  adjustSP2 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Frame.sp) -}
ac85d4d0957b975450c0e5ceee0165d6
  allocLocal ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> GHC.Types.Bool
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.Access
  {- Arity: 4,
     Strictness: <L,A><L,1*U><L,1*U><S(SLLLLLLL),1*U(1*U,U,U,U(U(U)),U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.allocLocal1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <FrontEnd.AST.Type>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Translate.Access>_N)) -}
e872b08704a47d88fc994be5cb136c0d
  allocLocal1 ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> GHC.Types.Bool
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.Access, BackEnd.Translate.TranslateState)
  {- Arity: 4,
     Strictness: <L,A><L,1*U><L,1*U><S(SLLLLLLL),1*U(1*U,U,U,U(U(U)),U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: GHC.Types.Bool)
                   (w3 :: BackEnd.Translate.TranslateState) ->
                 case w3 of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case ww1 of wild {
                   []
                   -> case BackEnd.Translate.allocLocal2
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.Translate.Access, BackEnd.Translate.TranslateState))
                      of {}
                   : ipv ipv1
                   -> let {
                        frame :: BackEnd.Frame.Frame
                        = case ipv of wild1 { BackEnd.Translate.Level ds ds1 ds2 -> ds }
                      } in
                      let {
                        ds :: (BackEnd.Frame.Frame, BackEnd.Frame.Access,
                               BackEnd.Temp.TempAllocator)
                        = case BackEnd.Frame.$wallocLocal
                                 frame
                                 w1
                                 w2
                                 ww4 of ww9 { (#,,#) ww10 ww11 ww12 ->
                          (ww10, ww11, ww12) }
                      } in
                      (BackEnd.Translate.Access
                         frame
                         (case ds of wild1 { (,,) frame' access alloc' -> access }),
                       BackEnd.Translate.TranslateState
                         (GHC.Types.:
                            @ BackEnd.Translate.Level
                            (case ipv of wild1 { BackEnd.Translate.Level ds1 ds2 ds3 ->
                             BackEnd.Translate.Level
                               (case ds of wild2 { (,,) frame' access alloc' -> frame' })
                               ds2
                               ds3 })
                            ipv1)
                         ww2
                         ww3
                         (case ds of wild1 { (,,) frame' access alloc' -> alloc' })
                         ww5
                         ww6
                         ww7
                         ww8)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.Access,
                                  BackEnd.Translate.TranslateState)>_R)) } }) -}
b89c0a227227b2c27e1873e53e0bf0c8
  allocLocal2 ::
    Data.Functor.Identity.Identity
      ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState)
  {- Strictness: x -}
d14106632b608f42621ddc79731bdd50
  builtInSet ::
    BackEnd.Translate.TranslateState -> Data.Set.Base.Set GHC.Types.Int
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),1*U(A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds8 }) -}
86f7b194b9e55207b78bdb95a27d245c
  callp ::
    BackEnd.Temp.Label
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         BackEnd.Translate.IExp
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.callp1
                  `cast`
                (<BackEnd.Temp.Label>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R Trans
                          (<BackEnd.Translate.TranslateState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(BackEnd.Translate.IExp,
                                           BackEnd.Translate.TranslateState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <BackEnd.Translate.TranslateState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <BackEnd.Translate.IExp>_N))) -}
0176bd39d4a39907249c8219122b77b4
  callp1 ::
    BackEnd.Temp.Label
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: BackEnd.Temp.Label)
                   (exprs :: [BackEnd.IR.Exp])
                   (eta5 :: BackEnd.Translate.TranslateState) ->
                 (BackEnd.Translate.Ex (BackEnd.IR.CALL (BackEnd.IR.NAME s) exprs),
                  eta5)) -}
3b9cb15a736b8f79135686a7b13dc77a
  controlLabelAlloc ::
    BackEnd.Translate.TranslateState -> BackEnd.Temp.LabelAllocator
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),1*U(A,A,A,A,1*U(U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds5 }) -}
8249b66ac5a5c99cb498c1dcf4b10909
  dataFrags ::
    BackEnd.Translate.TranslateState -> [BackEnd.Frame.Fragment]
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),1*U(A,1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds2 }) -}
a2a2741545a81a0e3b35da071726ce2d
  dataLabelAlloc ::
    BackEnd.Translate.TranslateState -> BackEnd.Temp.LabelAllocator
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),1*U(A,A,A,A,A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds6 }) -}
d5dd2739fcc2fe30c5073f76626f2f3e
  escape :: FrontEnd.AST.Type -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: FrontEnd.AST.Type) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.True
                   FrontEnd.AST.TInt -> GHC.Types.False
                   FrontEnd.AST.TBool -> GHC.Types.False
                   FrontEnd.AST.TChar -> GHC.Types.False
                   FrontEnd.AST.TStr -> GHC.Types.False }) -}
0f0e0133f72aa61cc3237f0d9fba2c59
  frameLabelAlloc ::
    BackEnd.Translate.TranslateState -> BackEnd.Temp.LabelAllocator
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds7 }) -}
de943670d6234acf2b1de8a902c1c234
  funTable ::
    BackEnd.Translate.Level
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
  RecSel Left BackEnd.Translate.Level
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.Level) ->
                 case ds of wild { BackEnd.Translate.Level ds1 ds2 ds3 -> ds3 }) -}
b9cc91e3423ea5656edf78d5130ffbea
  getCurrFrame ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Frame.Frame
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.getCurrFrame1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Frame.Frame>_N)) -}
f754dbecf8e8a6dfabd6e5dcdcd3111a
  getCurrFrame1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Frame.Frame, BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: BackEnd.Translate.TranslateState) ->
                 case s1 of wild { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case ds of wild1 {
                   []
                   -> case GHC.Err.error
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Functor.Identity.Identity
                                  ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState))
                             GHC.Err.errorWithoutStackTrace_wild1
                               `cast`
                             (Sym (GHC.Classes.N:IP[0]
                                       <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                             BackEnd.Translate.addFunEntry_str
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.Frame.Frame, BackEnd.Translate.TranslateState))
                      of {}
                   : ipv ipv1
                   -> (case ipv of wild2 { BackEnd.Translate.Level ds8 ds9 ds10 ->
                       ds8 },
                       wild)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Frame.Frame,
                                  BackEnd.Translate.TranslateState)>_R)) } }) -}
81753cf67a4cce5d114cc4c42807d1ff
  getVarEntry ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.IR.Exp
  {- Arity: 2, Strictness: <L,U><S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.getVarEntry1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.IR.Exp>_N)) -}
06edc1176cc61df2c79787f89787a956
  getVarEntry1 ::
    GHC.Base.String
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Exp, BackEnd.Translate.TranslateState)
  {- Arity: 2, Strictness: <L,U><S(SLLLLLLL),1*U(U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w1 of ww { BackEnd.Translate.TranslateState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case BackEnd.Translate.$wgetVarEntry
                        w
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8 of ww9 { (#,#) ww10 ww11 ->
                 (ww10, ww11)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.IR.Exp, BackEnd.Translate.TranslateState)>_R)) } }) -}
c383d401e3302e4a02adafcc2db8864d
  id_p_check_array_bounds :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10) -}
4e630dd27723d0a30937d55ced953745
  id_p_check_null_pointer :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (5) -}
befff547fda267aa8d9e9b57fb6fa834
  id_p_free_pair :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (9) -}
cda77ad755f05201826e0d27dd6d1c2b
  id_p_print_bool :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
abb216ebb4e7c6de42be79ed6205d237
  id_p_print_int :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
8e336f63f311b312435bbb404910103f
  id_p_print_ln :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
a924f798986ba860aba60849d967b799
  id_p_print_reference :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
cdfc17137100dbaa762ec1199eef31b8
  id_p_print_string :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
22c30fc7ccf94af39bd25aa8d2e9cdd9
  id_p_read_char :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8#) -}
72b0c171c8db3bbbc0f97f96a6d3dce3
  id_p_read_int :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
8a6262b6ef2804e3da63f4900770eb80
  id_p_throw_overflow_error :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (11) -}
b2ad2b7f45c59044005a80087bf7286f
  id_p_throw_runtime_error :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (6) -}
6a8b32d6dfe086134aacd7bbe6bbe844
  levelFrame :: BackEnd.Translate.Level -> BackEnd.Frame.Frame
  RecSel Left BackEnd.Translate.Level
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.Level) ->
                 case ds of wild { BackEnd.Translate.Level ds1 ds2 ds3 -> ds1 }) -}
0419d2ac4461bc51d4e3c279713f40e3
  levels ::
    BackEnd.Translate.TranslateState -> [BackEnd.Translate.Level]
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLL),1*U(1*U,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds1 }) -}
a05223e6bee973a156a8c7f0dbcd707a
  newControlLabel ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Temp.Label
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,1*U(U(U)),U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.newControlLabel1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Temp.Label>_N)) -}
23453b60b2d534043327ecebe3445162
  newControlLabel1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Temp.Label, BackEnd.Translate.TranslateState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,1*U(U(U)),U,U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds5 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewControlLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 (case ds of wild { (,) alloc label -> label },
                  case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  BackEnd.Translate.TranslateState
                    ds1
                    ds2
                    ds3
                    ds4
                    (case ds of wild1 { (,) alloc label -> alloc })
                    ds6
                    ds7
                    ds8 })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Temp.Label, BackEnd.Translate.TranslateState)>_R))) -}
b72ad0a10c94dc983853d8cef1b7262c
  newDataLabel ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Temp.Label
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.newDataLabel1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Temp.Label>_N)) -}
3298f378ffacc3932dfb568bfc923dd4
  newDataLabel1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Temp.Label, BackEnd.Translate.TranslateState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,1*U(U(U)),U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds6 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewDataLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 (case ds of wild { (,) alloc label -> label },
                  case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  BackEnd.Translate.TranslateState
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    (case ds of wild1 { (,) alloc label -> alloc })
                    ds7
                    ds8 })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Temp.Label, BackEnd.Translate.TranslateState)>_R))) -}
d005fd623f85f62e2a31b7b5fba5ab05
  newFrameLabel ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Temp.Label
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.newFrameLabel1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Temp.Label>_N)) -}
f7460f55b080a9c468ca59b9c1ab1219
  newFrameLabel1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Temp.Label, BackEnd.Translate.TranslateState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,1*U(U(U)),U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.LabelAllocator, BackEnd.Temp.Label)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds7 of ww { BackEnd.Temp.LabelAllocator ww1 ->
                     case BackEnd.Temp.$wnewFrameLabel ww1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 (case ds of wild { (,) alloc label -> label },
                  case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  BackEnd.Translate.TranslateState
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (case ds of wild1 { (,) alloc label -> alloc })
                    ds8 })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Temp.Label, BackEnd.Translate.TranslateState)>_R))) -}
ab0cac9747dbbbd97b088d0e655a0ba8
  newLevel ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Translate.Level
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.newLevel1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Translate.Level>_N)) -}
7f9e5c5d10f0656c28e0379c895b8aba
  newLevel1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.Level, BackEnd.Translate.TranslateState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,1*U(U(U)),U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$wnewLevel w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Translate.Level,
                             BackEnd.Translate.TranslateState)>_R)) }) -}
b96f481b9205729ec1f85e53faa5f8ec
  newTemp ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Temp.Temp
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,1*U(U(U)),U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.newTemp1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <BackEnd.Temp.Temp>_N)) -}
c0619f58dca1a729d88a779eeb6f46a1
  newTemp1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Temp.Temp, BackEnd.Translate.TranslateState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,1*U(U(U)),U,U,U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: (BackEnd.Temp.TempAllocator, BackEnd.Temp.Temp)
                   = case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                     case ds4 of wild1 { BackEnd.Temp.TempAllocator i ->
                     (BackEnd.Temp.TempAllocator
                        (case i of wild2 { GHC.Types.I# x ->
                         GHC.Types.I# (GHC.Prim.+# x 1#) }),
                      i) } }
                 } in
                 (case ds of wild { (,) tempAlloc' temp -> temp },
                  case w of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                  BackEnd.Translate.TranslateState
                    ds1
                    ds2
                    ds3
                    (case ds of wild1 { (,) tempAlloc' temp -> tempAlloc' })
                    ds5
                    ds6
                    ds7
                    ds8 })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Temp.Temp, BackEnd.Translate.TranslateState)>_R))) -}
b790d14e7539c88a6dc0cd476b1ce974
  newTranslateState :: BackEnd.Translate.TranslateState
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (BackEnd.Translate.TranslateState
                   (GHC.Types.[] @ BackEnd.Translate.Level)
                   (GHC.Types.[] @ BackEnd.Frame.Fragment)
                   (GHC.Types.[] @ BackEnd.Frame.Fragment)
                   BackEnd.Temp.newTempAllocator
                   BackEnd.Temp.newLabelAllocator
                   BackEnd.Temp.newLabelAllocator
                   BackEnd.Temp.newLabelAllocator
                   (Data.Set.Base.Tip @ GHC.Types.Int)) -}
6d719b8c66587c728f5f336d2624a3aa
  popLevel ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState ()
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.popLevel1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <BackEnd.Translate.TranslateState>_N
                          <Data.Functor.Identity.Identity>_R
                          <()>_N)) -}
ded38c3b7965c128a972797ad8a739eb
  popLevel1 ::
    BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ((), BackEnd.Translate.TranslateState)
  {- Arity: 1, Strictness: <S(SLLLLLLL),1*U(1*U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: BackEnd.Translate.TranslateState) ->
                 case s1 of wild { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case ds of wild1 {
                   []
                   -> case GHC.Err.error
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Functor.Identity.Identity
                                  ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState))
                             GHC.Err.errorWithoutStackTrace_wild1
                               `cast`
                             (Sym (GHC.Classes.N:IP[0]
                                       <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                             BackEnd.Translate.addFunEntry_str
                      ret_ty (Data.Functor.Identity.Identity
                                ((), BackEnd.Translate.TranslateState))
                      of {}
                   : ipv ipv1
                   -> (GHC.Tuple.(),
                       BackEnd.Translate.TranslateState ipv1 ds1 ds2 ds3 ds4 ds5 ds6 ds7)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), BackEnd.Translate.TranslateState)>_R)) } }) -}
cde1c0203be86bbe761139a1400d2ea4
  procFrags ::
    BackEnd.Translate.TranslateState -> [BackEnd.Frame.Fragment]
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),1*U(A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds3 }) -}
39f6fcc64e62236755fedd80e17df49d
  pushLevel ::
    BackEnd.Translate.Level
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.pushLevel1
                  `cast`
                (<BackEnd.Translate.Level>_R
                 ->_R Trans
                          (<BackEnd.Translate.TranslateState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), BackEnd.Translate.TranslateState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <BackEnd.Translate.TranslateState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_N))) -}
f0a257490b69c8a3ac14fede5097e9fa
  pushLevel1 ::
    BackEnd.Translate.Level
    -> BackEnd.Translate.TranslateState
    -> ((), BackEnd.Translate.TranslateState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (level :: BackEnd.Translate.Level)
                   (eta5 :: BackEnd.Translate.TranslateState) ->
                 (GHC.Tuple.(),
                  case eta5 of wild { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                  BackEnd.Translate.TranslateState
                    (GHC.Types.: @ BackEnd.Translate.Level level ds)
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7 })) -}
3f4f2328c2b44eafe95ce7be8ad72f8f
  seq :: [BackEnd.IR.Stm] -> BackEnd.IR.Stm
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b3553229c1d278fef071cfa18ce79d9a
  show' :: FrontEnd.AST.Type -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: FrontEnd.AST.Type) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      (GHC.List.filterFB @ GHC.Types.Char @ b c BackEnd.Translate.show'1)
                      n
                      (FrontEnd.AST.$fShowFunc_$cshow x))) -}
cd5c77a7818f7a69590f1772715bdfdd
  show'1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.True ' '# -> GHC.Types.False } }) -}
ef126532bfb5d6f11d2be45f843bfda6
  stripParam ::
    FrontEnd.AST.ParamF () -> (FrontEnd.AST.Type, GHC.Base.String)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(SL))L),1*U(1*U(U,1*U(1*U(U),A)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: FrontEnd.AST.Ann (FrontEnd.AST.Param ())) ->
                 case ds of wild { FrontEnd.AST.Ann ds1 ds2 ->
                 case ds1 of wild1 { FrontEnd.AST.Param t ds3 ->
                 case ds3 of wild2 { FrontEnd.AST.Ann ds4 ds5 ->
                 case ds4 of wild3 { FrontEnd.AST.Ident s -> (t, s) } } } }) -}
399b2447dad408f0d246c1b097611ff6
  tempAlloc ::
    BackEnd.Translate.TranslateState -> BackEnd.Temp.TempAllocator
  RecSel Left BackEnd.Translate.TranslateState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),1*U(A,A,A,1*U(U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.TranslateState) ->
                 case ds of wild { BackEnd.Translate.TranslateState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds4 }) -}
c81bd549ed640df32bbad3b81be0eba1
  translate ::
    FrontEnd.AST.ProgramF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.IR.Stm
  {- Arity: 2,
     Strictness: <L,1*U(1*U(1*U,1*U(1*U(1*U),A)),A)><L,1*U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translate1
                  `cast`
                (<FrontEnd.AST.ProgramF ()>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.IR.Stm>_N)) -}
3456b88d6ef15f4d1b7d66480c31542c
  translate1 ::
    FrontEnd.AST.ProgramF ()
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
  {- Arity: 2,
     Strictness: <L,1*U(1*U(1*U,1*U(1*U(1*U),A)),A)><L,1*U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (program :: FrontEnd.AST.ProgramF ())
                   (eta5 :: BackEnd.Translate.TranslateState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
                   = BackEnd.Translate.translate2 program eta5
                 } in
                 (case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(BackEnd.IR.Stm,
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  BackEnd.IR.cleanStm a1 },
                  case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(BackEnd.IR.Stm,
                              BackEnd.Translate.TranslateState)>_R) of wild { (,) a1 s' ->
                  s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.IR.Stm, BackEnd.Translate.TranslateState)>_R))) -}
31105cea5c71374ebd0916a8a00b054c
  translate10 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Frame.lr) -}
33c8e3629981405cf73fe80ebfd5d1d1
  translate11 :: BackEnd.IR.Stm
  {- Strictness: m6,
     Unfolding: (BackEnd.IR.LABEL BackEnd.Translate.translate12) -}
56d1c5aba5880d32a97850402aedbbad
  translate12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "main"#) -}
cbb44c659fa6d1cddb1430b344e9516e
  translate2 ::
    FrontEnd.AST.Ann (FrontEnd.AST.Program ())
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
  {- Arity: 2,
     Strictness: <S(SL),1*U(1*U(1*U,1*U(1*U(1*U),A)),A)><L,1*U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrontEnd.AST.Ann (FrontEnd.AST.Program ()))
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Program ww4 ww5 ->
                 case BackEnd.Translate.$wtranslateProgramF
                        ww4
                        ww5
                        w1 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.IR.Stm, BackEnd.Translate.TranslateState)>_R)) } } }) -}
d9bf0e3472f273ceb2a9b382b0171459
  translate3 :: BackEnd.IR.Stm
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (BackEnd.IR.SEQ
                   BackEnd.Translate.translate6
                   BackEnd.Translate.translate4) -}
d944a5a9ca408f4fd85e6d6c9e72fc67
  translate4 :: BackEnd.IR.Stm
  {- HasNoCafRefs, Strictness: m8,
     Unfolding: (BackEnd.IR.POP BackEnd.Translate.translate5) -}
b20a4c6c4cb0ec498455e0f40669aa66
  translate5 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Frame.pc) -}
e41e4900a30b1d6d496cba4152b01ee4
  translate6 :: BackEnd.IR.Stm
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.MOV
                   BackEnd.Translate.translate8
                   BackEnd.Translate.translate7) -}
727bb0ecd979345f5155fe27b99143b7
  translate7 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.CONSTI BackEnd.Translate.id_p_print_ln) -}
63acc32e145ef0bd47680fb3f711a2a6
  translate8 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (BackEnd.IR.TEMP BackEnd.Translate.id_p_print_ln) -}
e26db52bda2ffbfa57711c3b34a76f3e
  translate9 :: BackEnd.IR.Stm
  {- HasNoCafRefs, Strictness: m7,
     Unfolding: (BackEnd.IR.PUSH BackEnd.Translate.translate10) -}
7f041dfb846f152c4ee2d1ad5abf0e6c
  translateBuiltInFuncAppF ::
    FrontEnd.AST.FuncAppF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S(SL),1*U(1*U(U,1*U(1*U(1*U),A),1*U),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.FuncAppF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.FuncApp ww4 ww5 ww6 ->
                 BackEnd.Translate.$wtranslateBuiltInFuncAppF ww4 ww5 ww6 } }) -}
d7cb4c41f898c01eec01aa5b1cd0e573
  translateExprF ::
    FrontEnd.AST.ExprF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U(A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.ExprF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 BackEnd.Translate.$wtranslateExprF ww1 ww2 }) -}
6e2201a6b745d6a40b48048b6947f703
  translateFile :: GHC.Base.String -> GHC.Types.IO BackEnd.IR.Stm
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translateFile1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <BackEnd.IR.Stm>_R)) -}
4f5bc73488b092087866dc5f8dbefe70
  translateFile1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, BackEnd.IR.Stm #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (file :: GHC.Base.String)
                   (eta5 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case FrontEnd.Parser.parseFile1
                        file
                        eta5 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Program ww4 ww5 ->
                 case ww2 of ww6 { (,) ww7 ww8 ->
                 case (FrontEnd.SemanticAnalyzer.$wanalyzeProgramF ww4 ww5 ww7 ww8)
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <FrontEnd.SemanticAnalyzer.AnalysisState>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.ProgramF ()>_N)
                        FrontEnd.SemanticAnalyzer.analyzeAST5 of wild {
                   Data.Either.Left l
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             FrontEnd.SemanticAnalyzer.analyzeAST4
                             GHC.Types.True
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case System.Exit.exitWith1
                             @ (FrontEnd.AST.ProgramF ())
                             FrontEnd.SemanticAnalyzer.analyzeAST2
                             ipv2
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, BackEnd.IR.Stm #)
                      of {} }
                   Data.Either.Right r
                   -> (# ipv,
                         let {
                           ds :: Data.Functor.Identity.Identity
                                   (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
                           = case r of wild1 { (,) a1 ds2 ->
                             case a1 of ww11 { FrontEnd.AST.Ann ww12 ww13 ->
                             case ww12 of ww14 { FrontEnd.AST.Program ww15 ww16 ->
                             case BackEnd.Translate.$wtranslateProgramF
                                    ww15
                                    ww16
                                    BackEnd.Translate.newTranslateState of ww17 { (#,#) ww18 ww19 ->
                             (ww18, ww19)
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <(BackEnd.IR.Stm,
                                         BackEnd.Translate.TranslateState)>_R)) } } } }
                         } in
                         BackEnd.IR.SEQ
                           (case ds
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(BackEnd.IR.Stm,
                                        BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                            BackEnd.IR.cleanStm a1 })
                           (case ds
                                   `cast`
                                 (Data.Functor.Identity.N:Identity[0]
                                      <(BackEnd.IR.Stm,
                                        BackEnd.Translate.TranslateState)>_R) of wild1 { (,) a1 s' ->
                            case s' of wild2 { BackEnd.Translate.TranslateState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                            case ds4 of wild3 {
                              [] -> case GHC.List.badHead ret_ty BackEnd.IR.Stm of {}
                              : x ds10
                              -> case x of wild4 {
                                   BackEnd.Frame.PROC procFrag ds11 -> procFrag
                                   BackEnd.Frame.STRING ipv2 ipv3
                                   -> case BackEnd.Translate.translateFile2
                                      ret_ty BackEnd.IR.Stm
                                      of {} } } } }) #) } } } } }) -}
8bda980ed2a403aeffaa00eab99bb4c5
  translateFile2 :: (BackEnd.IR.Stm)
  {- Strictness: x -}
751f6c3d6c4bdba49eeb68cce6466257
  translateFree ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translateFree1
                  `cast`
                (<FrontEnd.AST.Type>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Translate.IExp>_N)) -}
82180cc542bbf1bcdfde359fa0e5989e
  translateFree1 ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   DEFAULT
                   -> case BackEnd.Translate.translateFree4
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState))
                      of {}
                   FrontEnd.AST.TStr
                   -> (BackEnd.Translate.Ex
                         (BackEnd.IR.CALL
                            (BackEnd.IR.NAME BackEnd.Translate.translateFree3)
                            w1),
                       w2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)>_R))
                   FrontEnd.AST.TArray ds
                   -> (BackEnd.Translate.Ex
                         (BackEnd.IR.CALL
                            (BackEnd.IR.NAME BackEnd.Translate.translateFree3)
                            w1),
                       w2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)>_R))
                   FrontEnd.AST.TPair ds ds1
                   -> (BackEnd.Translate.Ex
                         (BackEnd.IR.CALL
                            (BackEnd.IR.NAME BackEnd.Translate.translateFree2)
                            w1),
                       w2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.IExp,
                                  BackEnd.Translate.TranslateState)>_R)) }) -}
09e99991fc7e4bcd02a22e1510384af1
  translateFree2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "p_free_pair"#) -}
c4baaa644d79786c935ce2f53097a3c5
  translateFree3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_free_array"#) -}
7b0785bf912e210bb8c085fe0aa31f16
  translateFree4 ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Strictness: x -}
607e258afa0a4c047b450248d575a78d
  translateFuncAppF ::
    FrontEnd.AST.FuncAppF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S(SL),1*U(U(U,U(U(U),A),U),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.FuncAppF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.FuncApp ww4 ww5 ww6 ->
                 BackEnd.Translate.$wtranslateFuncAppF ww4 ww5 ww6 } }) -}
4e7764e9eef3a4e645f020b10aee0277
  translateFuncAppF1 :: [[GHC.Types.Char]]
  {- Unfolding: (GHC.Base.map
                   @ (GHC.Base.String, FrontEnd.AST.Type)
                   @ [GHC.Types.Char]
                   (Data.Tuple.fst @ GHC.Base.String @ FrontEnd.AST.Type)
                   FrontEnd.AST.builtInFunc) -}
a12381cd6a726773b2bfd71061c7bee8
  translateFuncAppF_go ::
    [FrontEnd.AST.ExprF ()]
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         [BackEnd.Translate.IExp]
  {- Arity: 1, Strictness: <S,1*U> -}
0e4d093821b1969107fecc1d159f98fd
  translateFuncF ::
    FrontEnd.AST.FuncF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState ()
  {- Arity: 1,
     Strictness: <S(SL),1*U(1*U(U,1*U(1*U(1*U),A),1*U,1*U(1*U(1*U),A)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.FuncF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Func ww4 ww5 ww6 ww7 ->
                 BackEnd.Translate.$wtranslateFuncF ww4 ww5 ww6 ww7 } }) -}
16bd9876f8f2b4987720b40a32d1589d
  translateNewPair ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: FrontEnd.AST.Type)
                   (exps :: [BackEnd.IR.Exp]) ->
                 case ds of wild {
                   DEFAULT -> BackEnd.Translate.translateNewPair1
                   FrontEnd.AST.TPair t1 t2
                   -> (GHC.Tuple.(,)
                         @ BackEnd.Translate.IExp
                         @ BackEnd.Translate.TranslateState
                         (BackEnd.Translate.Ex
                            (BackEnd.IR.CALL
                               (BackEnd.IR.NAME
                                  (GHC.CString.unpackAppendCString#
                                     "#newpair "#
                                     (let {
                                        z1 :: [GHC.Types.Char]
                                        = GHC.CString.unpackAppendCString#
                                            " "#
                                            (GHC.List.filter
                                               @ GHC.Types.Char
                                               BackEnd.Translate.show'1
                                               (FrontEnd.AST.$fShowFunc_$cshow t2))
                                      } in
                                      letrec {
                                        go3 :: [GHC.Types.Char] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ (ds1 :: [GHC.Types.Char]) ->
                                          case ds1 of wild1 {
                                            [] -> z1
                                            : y ys
                                            -> case y of wild2 { GHC.Types.C# x ->
                                               case x of wild3 {
                                                 DEFAULT
                                                 -> GHC.Types.: @ GHC.Types.Char wild2 (go3 ys)
                                                 ' '# -> go3 ys } } }
                                      } in
                                      go3 (FrontEnd.AST.$fShowFunc_$cshow t1))))
                               exps)))
                        `cast`
                      (Trans
                           (<BackEnd.Translate.TranslateState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(BackEnd.Translate.IExp,
                                            BackEnd.Translate.TranslateState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <BackEnd.Translate.TranslateState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <BackEnd.Translate.IExp>_N))) }) -}
ad71d1e676192208ae31af942a6379f2
  translateNewPair1 ::
    Control.Monad.Trans.State.Lazy.StateT
      BackEnd.Translate.TranslateState
      Data.Functor.Identity.Identity
      BackEnd.Translate.IExp
  {- Strictness: x -}
845a9f3c1560d5dfb4e290daaeb07097
  translatePairAccess ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <L,1*U><L,U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translatePairAccess1
                  `cast`
                (<FrontEnd.AST.Type>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Trans
                          (<BackEnd.Translate.TranslateState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(BackEnd.Translate.IExp,
                                           BackEnd.Translate.TranslateState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <BackEnd.Translate.TranslateState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <BackEnd.Translate.IExp>_N))) -}
58feb26c97fe98d1cf28a9876987d307
  translatePairAccess1 ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> GHC.Base.String
    -> BackEnd.Translate.TranslateState
    -> (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, Strictness: <L,1*U><L,U><L,1*U>,
     Unfolding: (\ (t :: FrontEnd.AST.Type)
                   (exps :: [BackEnd.IR.Exp])
                   (str3 :: GHC.Base.String) ->
                 GHC.Tuple.(,)
                   @ BackEnd.Translate.IExp
                   @ BackEnd.Translate.TranslateState
                   (BackEnd.Translate.Ex
                      (BackEnd.IR.CALL
                         (BackEnd.IR.NAME
                            (GHC.CString.unpackAppendCString#
                               "#"#
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  str3
                                  (GHC.CString.unpackAppendCString#
                                     " "#
                                     (GHC.List.filter
                                        @ GHC.Types.Char
                                        BackEnd.Translate.show'1
                                        (FrontEnd.AST.$fShowFunc_$cshow t))))))
                         exps))) -}
b338bb175412ab30b2637425130f0ae0
  translatePrint ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translatePrint1
                  `cast`
                (<FrontEnd.AST.Type>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Translate.IExp>_N)) -}
fdd0e0367bd5c1a0fa38310799a16081
  translatePrint1 ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$wtranslatePrint
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Translate.IExp,
                             BackEnd.Translate.TranslateState)>_R)) }) -}
a049aa6af8b76a287e198ed3e1786bb9
  translatePrint10 :: BackEnd.IR.Exp
  {- Unfolding: (BackEnd.IR.NAME
                   BackEnd.Translate.translatePrint11) -}
0917cadb429e226e8a02079a93882632
  translatePrint11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_print_reference"#) -}
bc7e7e3a22e6e0f5881b9c9cecca8c00
  translatePrint2 :: BackEnd.IR.Exp
  {- Unfolding: (BackEnd.IR.NAME
                   BackEnd.Translate.translatePrint3) -}
e7b89bf68e969ee04ca13a6746767bab
  translatePrint3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_print_string"#) -}
3ccf5f051c62815ae2d12b8a878f56b5
  translatePrint4 :: BackEnd.IR.Exp
  {- Unfolding: (BackEnd.IR.NAME
                   BackEnd.Translate.translatePrint5) -}
8bff01068bf8faa0213e260ec96aca9c
  translatePrint5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_putchar"#) -}
1fa15705a0175aa82e7b61cf5a8ca5b7
  translatePrint6 :: BackEnd.IR.Exp
  {- Unfolding: (BackEnd.IR.NAME
                   BackEnd.Translate.translatePrint7) -}
f4c9b98be1e4bf53983915ab884c42a2
  translatePrint7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_print_bool"#) -}
c0a38aa7091ac1cf72725652498c6d2f
  translatePrint8 :: BackEnd.IR.Exp
  {- Unfolding: (BackEnd.IR.NAME
                   BackEnd.Translate.translatePrint9) -}
7f053a880b1a54ae1da588342e9e932c
  translatePrint9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_print_int"#) -}
7ad7fbf98e38bcbb7c41abcd01bf6fc7
  translatePrintln ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translatePrintln1
                  `cast`
                (<FrontEnd.AST.Type>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Translate.IExp>_N)) -}
ff7b3942b0db5e7c7093a972178ccdde
  translatePrintln1 ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U(U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$wtranslatePrintln
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.Translate.IExp,
                             BackEnd.Translate.TranslateState)>_R)) }) -}
8ece324aad43569c8cdfa586b36d217a
  translatePrintln2 :: BackEnd.IR.Stm
  {- Strictness: m3,
     Unfolding: (BackEnd.IR.EXP BackEnd.Translate.translatePrintln3) -}
53ab2a3846da2d60fceb4baadee237b4
  translatePrintln3 :: BackEnd.IR.Exp
  {- Strictness: m7,
     Unfolding: (BackEnd.IR.CALL
                   BackEnd.Translate.translatePrintln4
                   (GHC.Types.[] @ BackEnd.IR.Exp)) -}
a892d8cfbe1e8c326170ff84bb8173d9
  translatePrintln4 :: BackEnd.IR.Exp
  {- Strictness: m3,
     Unfolding: (BackEnd.IR.NAME BackEnd.Translate.translatePrintln5) -}
6cf6849d903e46b5d920c09cf3e6923f
  translatePrintln5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "p_print_ln"#) -}
edbf69c36a9412687b645193a61c792d
  translatePrintln6 :: BackEnd.IR.Exp
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (BackEnd.IR.CONSTI BackEnd.Translate.id_p_print_int) -}
02b68a3aa15f0d5e15e2f87a23ed7afb
  translateProgramF ::
    FrontEnd.AST.ProgramF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.IR.Stm
  {- Arity: 2,
     Strictness: <S(SL),1*U(1*U(1*U,1*U(1*U(1*U),A)),A)><L,1*U(U,U,U,U,U,U,1*U(U(U)),U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translate2
                  `cast`
                (<FrontEnd.AST.Ann (FrontEnd.AST.Program ())>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.IR.Stm>_N)) -}
bb5402ef2790cb5c98b4413fe369e9fc
  translateRead ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U(U,U,U,U,U,U,U,1*U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.translateRead1
                  `cast`
                (<FrontEnd.AST.Type>_R
                 ->_R <[BackEnd.IR.Exp]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Translate.IExp>_N)) -}
1a9e7a17fa56491140ff2d26c0db3c65
  translateRead1 ::
    FrontEnd.AST.Type
    -> [BackEnd.IR.Exp]
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U(U,U,U,U,U,U,U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: FrontEnd.AST.Type)
                   (w1 :: [BackEnd.IR.Exp])
                   (w2 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   DEFAULT
                   -> case BackEnd.Translate.translateRead4
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.Translate.IExp, BackEnd.Translate.TranslateState))
                      of {}
                   FrontEnd.AST.TInt
                   -> (BackEnd.Translate.Ex
                         (BackEnd.IR.CALL
                            (BackEnd.IR.NAME BackEnd.Translate.translateRead3)
                            w1),
                       case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       BackEnd.Translate.TranslateState
                         ds
                         ds1
                         ds2
                         ds3
                         ds4
                         ds5
                         ds6
                         (BackEnd.Translate.$w$sgo5 7# ds7) })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.IExp, BackEnd.Translate.TranslateState)>_R))
                   FrontEnd.AST.TChar
                   -> (BackEnd.Translate.Ex
                         (BackEnd.IR.CALL
                            (BackEnd.IR.NAME BackEnd.Translate.translateRead2)
                            w1),
                       case w2 of wild1 { BackEnd.Translate.TranslateState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                       BackEnd.Translate.TranslateState
                         ds
                         ds1
                         ds2
                         ds3
                         ds4
                         ds5
                         ds6
                         (BackEnd.Translate.$w$sgo5 8# ds7) })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Translate.IExp,
                                  BackEnd.Translate.TranslateState)>_R)) }) -}
600ccd4c0d25c15fa5ac3c33c30261cb
  translateRead2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_read_char"#) -}
3659874338e0821cfbe7f0eb5103238a
  translateRead3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#p_read_int"#) -}
c25b88a58c060fb7d75a336ffc4a5483
  translateRead4 ::
    Control.Monad.Trans.State.Lazy.State
      BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Strictness: x -}
a989b291f66a7611c490940f4a08e340
  translateStatF ::
    FrontEnd.AST.StatF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,A)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.StatF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 BackEnd.Translate.$wtranslateStatF ww1 }) -}
fcc10dac5728ecfb019f6bd07f66de81
  translateStatListF ::
    FrontEnd.AST.StatListF ()
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.Translate.IExp
  {- Arity: 1, Strictness: <S(SL),1*U(1*U(1*U),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.StatListF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.StatList ww4 ->
                 BackEnd.Translate.$wtranslateStatListF ww4 } }) -}
c3c02cb38ccdaa37caf3d79ed56f23f5
  translate_go ::
    [FrontEnd.AST.StatF ()]
    -> Control.Monad.Trans.State.Lazy.StateT
         BackEnd.Translate.TranslateState
         Data.Functor.Identity.Identity
         [BackEnd.Translate.IExp]
  {- Arity: 1, Strictness: <S,1*U> -}
ad750742c87744b08fcb558494afcfa8
  unCx ::
    BackEnd.Translate.IExp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState
         (BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm)
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.unCx1
                  `cast`
                (<BackEnd.Translate.IExp>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm>_N)) -}
b62bf7e6b466db200f8555d7fdb39e4a
  unCx1 ::
    BackEnd.Translate.IExp
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
          BackEnd.Translate.TranslateState)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.IExp)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case w of wild {
                   BackEnd.Translate.Ex e
                   -> case e of wild1 {
                        DEFAULT
                        -> (\ (label1 :: BackEnd.Temp.Label)
                              (label2 :: BackEnd.Temp.Label) ->
                            BackEnd.IR.CJUMP
                              BackEnd.IR.EQ
                              wild1
                              BackEnd.Translate.translatePrintln6
                              label1
                              label2,
                            w1)
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                       BackEnd.Translate.TranslateState)>_R))
                        BackEnd.IR.CONSTI ds
                        -> case ds of wild2 { GHC.Types.I# ds1 ->
                           case ds1 of ds2 {
                             DEFAULT
                             -> (\ (label1 :: BackEnd.Temp.Label)
                                   (label2 :: BackEnd.Temp.Label) ->
                                 BackEnd.IR.CJUMP
                                   BackEnd.IR.EQ
                                   wild1
                                   BackEnd.Translate.translatePrintln6
                                   label1
                                   label2,
                                 w1)
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <(BackEnd.Temp.Label
                                            -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                            BackEnd.Translate.TranslateState)>_R))
                             0#
                             -> (\ (label1 :: BackEnd.Temp.Label)
                                   (label2 :: BackEnd.Temp.Label) ->
                                 BackEnd.IR.JUMP
                                   wild1
                                   (GHC.Types.:
                                      @ BackEnd.Temp.Label
                                      label2
                                      (GHC.Types.[] @ BackEnd.Temp.Label)),
                                 w1)
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <(BackEnd.Temp.Label
                                            -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                            BackEnd.Translate.TranslateState)>_R))
                             1#
                             -> (\ (label1 :: BackEnd.Temp.Label)
                                   (label2 :: BackEnd.Temp.Label) ->
                                 BackEnd.IR.JUMP
                                   wild1
                                   (GHC.Types.:
                                      @ BackEnd.Temp.Label
                                      label1
                                      (GHC.Types.[] @ BackEnd.Temp.Label)),
                                 w1)
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <(BackEnd.Temp.Label
                                            -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                            BackEnd.Translate.TranslateState)>_R)) } } }
                   BackEnd.Translate.Nx ds
                   -> case BackEnd.Translate.unCx2
                      ret_ty (Data.Functor.Identity.Identity
                                (BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                 BackEnd.Translate.TranslateState))
                      of {}
                   BackEnd.Translate.Cx c
                   -> (c, w1)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm,
                                  BackEnd.Translate.TranslateState)>_R)) }) -}
a78811a0646956ab26ca8eefba50562a
  unCx2 ::
    Control.Monad.Trans.State.Lazy.StateT
      BackEnd.Translate.TranslateState
      Data.Functor.Identity.Identity
      (BackEnd.Temp.Label -> BackEnd.Temp.Label -> BackEnd.IR.Stm)
  {- Strictness: x -}
0209559992a549ca69ad16aa4c89217d
  unEx ::
    BackEnd.Translate.IExp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.IR.Exp
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.unEx1
                  `cast`
                (<BackEnd.Translate.IExp>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.IR.Exp>_N)) -}
b07079c38e9d934f75ead24a20244b6e
  unEx1 ::
    BackEnd.Translate.IExp
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Exp, BackEnd.Translate.TranslateState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.IExp)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$wunEx w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.IR.Exp, BackEnd.Translate.TranslateState)>_R)) }) -}
b093b45157699ea2389c6f0f75d54bbd
  unNx ::
    BackEnd.Translate.IExp
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState BackEnd.IR.Stm
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U(U(U)),U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.unNx1
                  `cast`
                (<BackEnd.Translate.IExp>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <BackEnd.IR.Stm>_N)) -}
82134ed95f70f559d6c11472586d6aa8
  unNx1 ::
    BackEnd.Translate.IExp
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         (BackEnd.IR.Stm, BackEnd.Translate.TranslateState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U,U,U,U(U(U)),U(U(U)),U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: BackEnd.Translate.IExp)
                   (w1 :: BackEnd.Translate.TranslateState) ->
                 case BackEnd.Translate.$wunNx w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(BackEnd.IR.Stm, BackEnd.Translate.TranslateState)>_R)) }) -}
770e9d75cbcd1de130aa0a096a1cb2fd
  varTable ::
    BackEnd.Translate.Level
    -> Data.HashMap.Map GHC.Base.String BackEnd.Translate.EnvEntry
  RecSel Left BackEnd.Translate.Level
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BackEnd.Translate.Level) ->
                 case ds of wild { BackEnd.Translate.Level ds1 ds2 ds3 -> ds2 }) -}
7d16a53bd3a3e4385bf5cb9c2e215e44
  verifyLevels ::
    [BackEnd.Translate.Level]
    -> Control.Monad.Trans.State.Lazy.State
         BackEnd.Translate.TranslateState [BackEnd.Translate.Level]
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                BackEnd.Translate.verifyLevels1
                  `cast`
                (<[BackEnd.Translate.Level]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <BackEnd.Translate.TranslateState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[BackEnd.Translate.Level]>_N)) -}
cb5fa78d2dfb80ba58aaefe030976fe2
  verifyLevels1 ::
    [BackEnd.Translate.Level]
    -> BackEnd.Translate.TranslateState
    -> Data.Functor.Identity.Identity
         ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState)
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: [BackEnd.Translate.Level])
                   (eta5 :: BackEnd.Translate.TranslateState) ->
                 case ds of wild {
                   []
                   -> GHC.Err.errorWithoutStackTrace
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Functor.Identity.Identity
                             ([BackEnd.Translate.Level], BackEnd.Translate.TranslateState))
                        BackEnd.Translate.addFunEntry_str
                   : ipv ipv1
                   -> (wild, eta5)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <([BackEnd.Translate.Level],
                                  BackEnd.Translate.TranslateState)>_R)) }) -}
instance [safe] GHC.Classes.Eq [BackEnd.Translate.Access]
  = BackEnd.Translate.$fEqAccess
instance [safe] GHC.Classes.Eq [BackEnd.Translate.EnvEntry]
  = BackEnd.Translate.$fEqEnvEntry
instance [safe] GHC.Classes.Eq [BackEnd.Translate.Level]
  = BackEnd.Translate.$fEqLevel
instance [safe] GHC.Classes.Eq [BackEnd.Translate.TranslateState]
  = BackEnd.Translate.$fEqTranslateState
instance [safe] GHC.Show.Show [BackEnd.Translate.Access]
  = BackEnd.Translate.$fShowAccess
instance [safe] GHC.Show.Show [BackEnd.Translate.EnvEntry]
  = BackEnd.Translate.$fShowEnvEntry
instance [safe] GHC.Show.Show [BackEnd.Translate.IExp]
  = BackEnd.Translate.$fShowIExp
instance [safe] GHC.Show.Show [BackEnd.Translate.Level]
  = BackEnd.Translate.$fShowLevel
instance [safe] GHC.Show.Show [BackEnd.Translate.TranslateState]
  = BackEnd.Translate.$fShowTranslateState
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

