
==================== FINAL INTERFACE ====================
2019-02-27 09:56:02.389181858 UTC

interface wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2:FrontEnd.SemanticAnalyzer 8002
  interface hash: 270135107e2e0c7c688c164b2523e7b9
  ABI hash: 2f8f81b4dd9a2a3fbbaa2a032c60c1d3
  export-list hash: 3c3524b7a455b135a3bb7a20b10bc1fa
  orphan hash: 816e93c3479ff7e314b4d6afed27246f
  flag hash: e7d435c966eda99babf6b9628630aff3
  sig of: Nothing
  used TH splices: False
  where
exports:
  FrontEnd.SemanticAnalyzer.addFunctionSymbol
  FrontEnd.SemanticAnalyzer.addSymbol
  FrontEnd.SemanticAnalyzer.analyzeAST
  FrontEnd.SemanticAnalyzer.analyzeExprF
  FrontEnd.SemanticAnalyzer.analyzeFile
  FrontEnd.SemanticAnalyzer.analyzeFuncAppF
  FrontEnd.SemanticAnalyzer.analyzeFuncF
  FrontEnd.SemanticAnalyzer.analyzeProgramF
  FrontEnd.SemanticAnalyzer.analyzeStatF
  FrontEnd.SemanticAnalyzer.analyzeStatListF
  FrontEnd.SemanticAnalyzer.builtInPos
  FrontEnd.SemanticAnalyzer.declaredError
  FrontEnd.SemanticAnalyzer.functionType
  FrontEnd.SemanticAnalyzer.getAllFuncType
  FrontEnd.SemanticAnalyzer.getContext
  FrontEnd.SemanticAnalyzer.getStats
  FrontEnd.SemanticAnalyzer.getT
  FrontEnd.SemanticAnalyzer.lookUpFunction
  FrontEnd.SemanticAnalyzer.lookUpSymbol
  FrontEnd.SemanticAnalyzer.lookUpSymbolCurrScope
  FrontEnd.SemanticAnalyzer.matchT
  FrontEnd.SemanticAnalyzer.notDeclaredError
  FrontEnd.SemanticAnalyzer.paramLenError
  FrontEnd.SemanticAnalyzer.popScope
  FrontEnd.SemanticAnalyzer.pushScope
  FrontEnd.SemanticAnalyzer.setContext
  FrontEnd.SemanticAnalyzer.typeError
  FrontEnd.SemanticAnalyzer.AnalysisState
  FrontEnd.SemanticAnalyzer.Analyzer
  FrontEnd.SemanticAnalyzer.Context{FrontEnd.SemanticAnalyzer.FContext FrontEnd.SemanticAnalyzer.Main}
  FrontEnd.SemanticAnalyzer.Mappable{FrontEnd.SemanticAnalyzer.fmap'}
  FrontEnd.SemanticAnalyzer.Matchable{FrontEnd.SemanticAnalyzer.match}
  FrontEnd.SemanticAnalyzer.SymbolT
module dependencies: FrontEnd.AST FrontEnd.Lexer FrontEnd.Parser
package dependencies: MissingH-1.4.0.1@MissingH-1.4.0.1-XvvfeDrBQU2lhIiDW7bjd
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa
                      hashmap-1.3.3@hashmap-1.3.3-6F5MsgNDasO6fIeStnUOf6
                      integer-gmp-1.0.0.1 mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h
                      parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E
                      text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.7.0@hashable-1.2.7.0-3Ov9NDiX2mfFTkc4fiCKfa:Data.Hashable.Generic
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text
                         text-1.2.3.1@text-1.2.3.1-FiKShuz66xXAoRKdCDhKNQ:Data.Text.Lazy
import  -/  MissingH-1.4.0.1@MissingH-1.4.0.1-XvvfeDrBQU2lhIiDW7bjd:Data.List.Utils 4b3aaf554e9c0a51ecbec57007f79107
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.IO.Exception 5064be4c355632a1d1c4f2322f56ac52
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.Exit 068ba078eb20417d7af66db8b8ab4db1
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  hashmap-1.3.3@hashmap-1.3.3-6F5MsgNDasO6fIeStnUOf6:Data.HashMap 21c21e30ca661fd288861556f5a56e8d
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.Error.Class 2664d9e2509167daf02a2d01e8ef7cba
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.Except 869f4b14ae34c6b0a79ae70cc607cb8e
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State d4f0a0054f0eb52460aaa42097d4c0c3
import  -/  mtl-2.2.2@mtl-2.2.2-IUStvhCM9Fb6Pb0KlPCV7h:Control.Monad.State.Class 353753d62a48dcd4d640d0eb74aa4d50
import  -/  parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E:Text.Parsec.Pos 9d4a34659ff1b882b10c732ea28cbeb8
import  -/  parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E:Text.Parsec.Prim 6cb5564512860d5b4760a068aca472b4
import  -/  parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E:Text.ParserCombinators.Parsec b1fa1f14f685b3aa53aea3b32e435e1f
import  -/  parsec-3.1.13.0@parsec-3.1.13.0-5jBHpMDfG914ocK3TvC2E:Text.ParserCombinators.Parsec.Pos 1692f343e5c5cc79ae7aef4277ba02d1
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
import  -/  FrontEnd.AST 13c4a14be76ce51c011789d09991ee7e
  exports: c71a8578c05d8981bdbdc0f839e79cdc
  Ann 7fb12f302cfbf6b6a9644b9022f39f91
  Ann ef7499b61979029b0f350802cd366649
  ArrayElem 20a9002fa5c7a880222792b8088784fd
  ArrayLiter 2c7fb705577fbe26b0c92ab9b038cf7c
  Assign c9253eba2dbcb82e200705249ffda60e
  BoolLiter f242a322ad0fedd5ecb1579d8a5e9b9e
  BracketExpr 6f2d9ec9e7eddea39de0b23fa4b1ccf6
  CharLiter 0458b4eacfafbb08f2fec10d88830282
  Declare 003063376653c1ef78a2034dd3236d7b
  Exit 6d9a13cd0053bdea62c2cd3748feae80
  Expr 048863448071204b4f096bf54a7d962c
  ExprF 048863448071204b4f096bf54a7d962c
  Func c7dcba27b2484d7b42e2091a6e288149
  FuncApp 7c4037b27a9527827a9401cf55e9d295
  FuncExpr 6188e6636c92ca9df653f0f89fd5dc47
  FuncF 9340e16bce1d1e46b7de1676a36637ff
  FuncStat bbaea13021f384be4edd0ea8066c9715
  Ident d38c2816185f64eaa87a87bb4f1f284b
  IdentExpr e73e6f79f7f1ef1091078aeeed9f0804
  IdentF ec2f730c7d9fd0d60995deb2a8237a07
  If 41c6a88b2ac35b6df66a31872b4fd7f0
  IntLiter 34d3efe89b2a1206d5f4c1e06ebf5c34
  None 6ed46c0b98a3264aa2588cd2b21943cd
  Null d07e86e72331bc577ef82b35eece2bd8
  Param e121bfb0c269eb452a3f460fc6e7748c
  Program 410fd95ff8f98d31de0e476f267b415c
  ProgramF 7ad5b774cd31af8f985fa4c4cbcfa7e6
  Return dd154fd7dab4366b36f9e2bc9ebe9d95
  Stat 7a7ac6f3981aec536719f99cb3fcc916
  StatF 7a7ac6f3981aec536719f99cb3fcc916
  StatList d3a3a04ef089fd4a8715f53fb53f355e
  StatListF 7a7ac6f3981aec536719f99cb3fcc916
  StringLiter 6f1c0a78bc4d294148974465edb0afc2
  Subroutine c290bc93d96618101048c8a5ef575c59
  T 84a97772dcbdae039995855eb93ebbd2
  TAny 20b6fed4f64c6ee6acb6902bd10f465f
  TArray 675264970e89d6be6a7b3e6f609b61a8
  TBool ebaf87cd8048064e60b38511bca54962
  TChar ec215f0c3082a946dbbc8dae32db4dc2
  TFunc 3f21d70d5fc155d018a3c6908184945c
  TInt 217cf96b2dda4e7a20fd48a7acdc5d45
  TPair f6c60416a1982c621b5593998f9b57e5
  TStr 1e8a03d0c8a4120669e95455e7ec9733
  Type 31b3244b67ff67ccd6b5abdfe81be110
  While bd4a4fee4ef59ee20f73dea3819ad3e2
  builtInFunc fc085426e0f1eb149b76b5af8405bd3c
  isTFunc f8bf7bb7ae78be28285dc7ccef9995fd
import  -/  FrontEnd.Parser dc168563fd1859eeec254be3c17e78ba
  exports: 45bb2ab1df05f1264fee753899b5f469
  parseProgramF 9c6aded43c9b000970ba5a6a44dea4b2
8875467209db093ff756895a8ad9b756
  $fEqContext :: GHC.Classes.Eq FrontEnd.SemanticAnalyzer.Context
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FrontEnd.SemanticAnalyzer.Context
                  FrontEnd.SemanticAnalyzer.$fEqContext_$c==
                  FrontEnd.SemanticAnalyzer.$fEqContext_$c/= -}
8875467209db093ff756895a8ad9b756
  $fEqContext_$c/= ::
    FrontEnd.SemanticAnalyzer.Context
    -> FrontEnd.SemanticAnalyzer.Context -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: FrontEnd.SemanticAnalyzer.Context)
                   (b :: FrontEnd.SemanticAnalyzer.Context) ->
                 case a of wild {
                   FrontEnd.SemanticAnalyzer.Main
                   -> case b of wild1 {
                        FrontEnd.SemanticAnalyzer.Main -> GHC.Types.False
                        FrontEnd.SemanticAnalyzer.FContext ipv -> GHC.Types.True }
                   FrontEnd.SemanticAnalyzer.FContext a1
                   -> case b of wild1 {
                        FrontEnd.SemanticAnalyzer.Main -> GHC.Types.True
                        FrontEnd.SemanticAnalyzer.FContext b1
                        -> case FrontEnd.AST.$fEqParam_$c==2 a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
8875467209db093ff756895a8ad9b756
  $fEqContext_$c== ::
    FrontEnd.SemanticAnalyzer.Context
    -> FrontEnd.SemanticAnalyzer.Context -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: FrontEnd.SemanticAnalyzer.Context)
                   (ds1 :: FrontEnd.SemanticAnalyzer.Context) ->
                 case ds of wild {
                   FrontEnd.SemanticAnalyzer.Main
                   -> case ds1 of wild1 {
                        FrontEnd.SemanticAnalyzer.Main -> GHC.Types.True
                        FrontEnd.SemanticAnalyzer.FContext ipv -> GHC.Types.False }
                   FrontEnd.SemanticAnalyzer.FContext a1
                   -> case ds1 of wild1 {
                        FrontEnd.SemanticAnalyzer.Main -> GHC.Types.False
                        FrontEnd.SemanticAnalyzer.FContext b1
                        -> FrontEnd.AST.$fEqParam_$c==2 a1 b1 } }) -}
04c2ca2a8062e741d492597782d093ac
  $fMappableType ::
    FrontEnd.SemanticAnalyzer.Mappable FrontEnd.AST.Type
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FrontEnd.SemanticAnalyzer.$fMappableType_$cfmap'
                  `cast`
                (Sym (FrontEnd.SemanticAnalyzer.N:Mappable[0]
                          <FrontEnd.AST.Type>_N)) -}
cf1838e5cbcb9d409be37882391fe112
  $fMappableType_$cfmap' ::
    (FrontEnd.AST.Type -> FrontEnd.AST.Type)
    -> FrontEnd.AST.Type -> FrontEnd.AST.Type
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ (f :: FrontEnd.AST.Type -> FrontEnd.AST.Type)
                   (ds :: FrontEnd.AST.Type) ->
                 case ds of wild {
                   DEFAULT -> f wild
                   FrontEnd.AST.TArray t -> FrontEnd.AST.TArray (f t)
                   FrontEnd.AST.TPair t1 t2 -> FrontEnd.AST.TPair (f t1) (f t2)
                   FrontEnd.AST.TFunc ds1 ds2 ds3 -> wild }) -}
f41e440c661dcb29c5af1cde9ec82495
  $fMatchableExpr ::
    FrontEnd.SemanticAnalyzer.Matchable (FrontEnd.AST.Expr ())
  DFunId
  {- Arity: 3,
     Strictness: <L,U><S(SS),1*U(1*U,1*U(1*U(1*U,U,U),U))><S,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FrontEnd.SemanticAnalyzer.$fMatchableExpr_$cmatch
                  `cast`
                (Sym (FrontEnd.SemanticAnalyzer.N:Matchable[0]
                          <FrontEnd.AST.Expr ()>_N)) -}
40aa615df505aba95680bcd0958698aa
  $fMatchableExpr_$cmatch ::
    GHC.Base.String
    -> FrontEnd.AST.Ann (FrontEnd.AST.Expr ())
    -> [FrontEnd.AST.Type]
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 3,
     Strictness: <L,U><S(SS),1*U(1*U,1*U(1*U(1*U,U,U),U))><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: FrontEnd.AST.Ann (FrontEnd.AST.Expr ()))
                   (w2 :: [FrontEnd.AST.Type]) ->
                 case w1 of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww2 of ww3 { (,) ww4 ww5 ->
                 FrontEnd.SemanticAnalyzer.$w$cmatch w ww1 ww4 ww5 w2 } }) -}
f41e440c661dcb29c5af1cde9ec82495
  $fMatchableStat ::
    FrontEnd.SemanticAnalyzer.Matchable (FrontEnd.AST.Stat ())
  DFunId
  {- Arity: 3,
     Strictness: <L,U><S(LS),1*U(A,1*U(1*U(1*U,U,U),U))><S,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FrontEnd.SemanticAnalyzer.$fMatchableStat_$cmatch
                  `cast`
                (Sym (FrontEnd.SemanticAnalyzer.N:Matchable[0]
                          <FrontEnd.AST.Stat ()>_N)) -}
05dbdaca98f1fb5ef41bf2565295f892
  $fMatchableStat_$cmatch ::
    GHC.Base.String
    -> FrontEnd.AST.Ann (FrontEnd.AST.Stat ())
    -> [FrontEnd.AST.Type]
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 3,
     Strictness: <L,U><S(LS),1*U(A,1*U(1*U(1*U,U,U),U))><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (msg :: GHC.Base.String)
                   (a :: FrontEnd.AST.Ann (FrontEnd.AST.Stat ()))
                   (expectT :: [FrontEnd.AST.Type]) ->
                 case a of wild { FrontEnd.AST.Ann x ds ->
                 case ds of wild1 { (,) pos t ->
                 FrontEnd.SemanticAnalyzer.matchT msg t expectT pos } }) -}
8875467209db093ff756895a8ad9b756
  $fShowContext :: GHC.Show.Show FrontEnd.SemanticAnalyzer.Context
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FrontEnd.SemanticAnalyzer.Context
                  FrontEnd.SemanticAnalyzer.$fShowContext_$cshowsPrec
                  FrontEnd.SemanticAnalyzer.$fShowContext_$cshow
                  FrontEnd.SemanticAnalyzer.$fShowContext_$cshowList -}
8875467209db093ff756895a8ad9b756
  $fShowContext1 ::
    FrontEnd.SemanticAnalyzer.Context -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (FrontEnd.SemanticAnalyzer.$fShowContext_$cshowsPrec
                   FrontEnd.SemanticAnalyzer.$fShowContext2) -}
875c5ac65a34e56065523a1f78aa84ba
  $fShowContext2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
b4d3eb6ae2327d84d0a9aa913eec1c02
  $fShowContext3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FContext "#) -}
1ba86fbdd6fd3c72c1c7ac8bd1a42205
  $fShowContext4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Main"#) -}
8875467209db093ff756895a8ad9b756
  $fShowContext_$cshow ::
    FrontEnd.SemanticAnalyzer.Context -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: FrontEnd.SemanticAnalyzer.Context) ->
                 case x of wild {
                   FrontEnd.SemanticAnalyzer.Main
                   -> FrontEnd.SemanticAnalyzer.$fShowContext4
                   FrontEnd.SemanticAnalyzer.FContext b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FrontEnd.SemanticAnalyzer.$fShowContext3
                        (GHC.Base.++
                           @ GHC.Types.Char
                           (FrontEnd.AST.$fShowFunc_$cshow b1)
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
8875467209db093ff756895a8ad9b756
  $fShowContext_$cshowList ::
    [FrontEnd.SemanticAnalyzer.Context] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FrontEnd.SemanticAnalyzer.Context
                   FrontEnd.SemanticAnalyzer.$fShowContext1) -}
8875467209db093ff756895a8ad9b756
  $fShowContext_$cshowsPrec ::
    GHC.Types.Int
    -> FrontEnd.SemanticAnalyzer.Context -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: FrontEnd.SemanticAnalyzer.Context)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   FrontEnd.SemanticAnalyzer.Main
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FrontEnd.SemanticAnalyzer.$fShowContext4
                        eta
                   FrontEnd.SemanticAnalyzer.FContext b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             FrontEnd.SemanticAnalyzer.$fShowContext3
                             (GHC.Base.++
                                @ GHC.Types.Char
                                (FrontEnd.AST.$fShowFunc_$cshow b1)
                                eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                FrontEnd.SemanticAnalyzer.$fShowContext3
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   (FrontEnd.AST.$fShowFunc_$cshow b1)
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 eta))) } } }) -}
aee624602467230051c60be495682271
  $s$fAlternativeEither_$s$fError[]_$cnoMsg :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, False)
                (GHC.Base.id @ [GHC.Types.Char] (GHC.Types.[] @ GHC.Types.Char)) -}
79cdc84f23044ad505e3d79429e7e1fd
  $s$fEq(,) ::
    GHC.Classes.Eq (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                  (GHC.Classes.$fEq(,)_$c==
                     @ FrontEnd.AST.Type
                     @ Text.Parsec.Pos.SourcePos
                     FrontEnd.AST.$fEqType
                     Text.Parsec.Pos.$fEqSourcePos)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ FrontEnd.AST.Type
                     @ Text.Parsec.Pos.SourcePos
                     FrontEnd.AST.$fEqType
                     Text.Parsec.Pos.$fEqSourcePos) -}
17ffe173b11665f5262f9d4d615b8a27
  $s$fEqMap ::
    GHC.Classes.Eq
      (Data.HashMap.Map
         [GHC.Types.Char] (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.HashMap.Map
                       [GHC.Types.Char] (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                  (Data.HashMap.$fEqMap_$c==
                     @ [GHC.Types.Char]
                     @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                     FrontEnd.SemanticAnalyzer.$s$fEqMap2
                     FrontEnd.SemanticAnalyzer.$s$fEqMap1)
                  (Data.HashMap.$fEqMap_$c/=
                     @ [GHC.Types.Char]
                     @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                     FrontEnd.SemanticAnalyzer.$s$fEqMap2
                     FrontEnd.SemanticAnalyzer.$s$fEqMap1) -}
6afe83806ff94439019648965cf4fdd7
  $s$fEqMap1 ::
    GHC.Classes.Eq (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.$s$fEq(,) -}
8a4b833d4c5ea71fd9de9b7115ff955e
  $s$fEqMap2 :: GHC.Classes.Eq [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
d54785ff73d43d6bbb9a7ee89065878c
  $s$fStream[]mtok ::
    Text.Parsec.Prim.Stream [tok] Data.Functor.Identity.Identity tok
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ tok.
                  @ [tok]
                  @ Data.Functor.Identity.Identity
                  @ tok
                  (FrontEnd.SemanticAnalyzer.$s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream
                     @ tok)
                  (FrontEnd.SemanticAnalyzer.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
                     @ tok) -}
9c6698e50faab8da212d0f3550397ece
  $s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream ::
    GHC.Base.Monad Data.Functor.Identity.Identity
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ tok -> Data.Functor.Identity.$fMonadIdentity) -}
327f60e240e63a3c08f494aecd0f7acf
  $s$fStream[]mtok_$s$fStream[]mtok_$cuncons ::
    [tok]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok]))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ tok (ds :: [tok]) ->
                 case ds of wild {
                   []
                   -> GHC.Base.$
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Base.Maybe (tok, [tok]))
                        @ (Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok])))
                        (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                           @ (GHC.Base.Maybe (tok, [tok])))
                        (GHC.Base.Nothing @ (tok, [tok]))
                   : t ts
                   -> GHC.Base.$
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Base.Maybe (tok, [tok]))
                        @ (Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok])))
                        (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                           @ (GHC.Base.Maybe (tok, [tok])))
                        (GHC.Base.Just @ (tok, [tok]) (t, ts)) }) -}
4b83e408203b41179ad56f57334b251f
  $tc'C:Mappable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1151411468082048261##
                   8610484665719307251##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tc'C:Mappable1) -}
a4293e177e9c186dfd1a3f9f79010325
  $tc'C:Mappable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Mappable"#) -}
d414a3f160f20c1cfed2ba5f2b3b152b
  $tc'C:Matchable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7343165171933196712##
                   2585286072583429036##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tc'C:Matchable1) -}
78ff41a97123da220985cd749bd8105c
  $tc'C:Matchable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Matchable"#) -}
d4e392a87f29957da6a65657b9e4a2aa
  $tc'FContext :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14545700107477186093##
                   5192347306333452962##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tc'FContext1) -}
c23766af5dab32cc913011af09656057
  $tc'FContext1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FContext"#) -}
e2704862cd7fb2befbf5851f3ffd26c3
  $tc'Main :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12034272523551982307##
                   9444070711923368279##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tc'Main1) -}
da194ee6c6d8070b6b1ad0df49ab82a8
  $tc'Main1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Main"#) -}
9750a5ebe49a44cb7ae1bf6c0511d5af
  $tcContext :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6903659032775048888##
                   4984682071106005957##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tcContext1) -}
f15772b9a1ea149fc7adfa8dd67c2b43
  $tcContext1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Context"#) -}
f6cea35e0baf4c7c9b49d611950d49f3
  $tcMappable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6578428194429850740##
                   14569977999524933868##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tcMappable1) -}
3c018efd73b4323bf08dfc9889ceb29a
  $tcMappable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Mappable"#) -}
0cd1b5ad3029afd67f81baca313b9828
  $tcMatchable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12072240318317731381##
                   8126537011931138046##
                   FrontEnd.SemanticAnalyzer.$trModule
                   FrontEnd.SemanticAnalyzer.$tcMatchable1) -}
b7510728e10959a476e1f2fa4af80dfe
  $tcMatchable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Matchable"#) -}
98ff591e67e062aef7673e9c27d5eeea
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   FrontEnd.SemanticAnalyzer.$trModule2
                   FrontEnd.SemanticAnalyzer.$trModule1) -}
65187cea24f1969a5e594b23a248f0da
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "FrontEnd.SemanticAnalyzer"#) -}
364a77db1d51bea5f3cc5c1fa2ebd873
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "wacc32-0.1.0.0-3oOtzXerc607YIePR0qNZ2"#) -}
497516a421c3a825a45a068509375e08
  $w$cmatch ::
    GHC.Base.String
    -> FrontEnd.AST.Expr ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.AST.Type
    -> [FrontEnd.AST.Type]
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 5, Strictness: <L,U><S,1*U><L,1*U(1*U,U,U)><L,U><S,U>,
     Inline: [0] -}
be6704c632cf5b8067152fa5eb78a612
  $waddSymbol ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.AST.Type
    -> Text.Parsec.Pos.SourcePos
    -> [FrontEnd.SemanticAnalyzer.SymbolT]
    -> FrontEnd.SemanticAnalyzer.SymbolT
    -> FrontEnd.SemanticAnalyzer.Context
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 6,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: Text.Parsec.Pos.SourcePos)
                   (ww :: [FrontEnd.SemanticAnalyzer.SymbolT])
                   (ww1 :: FrontEnd.SemanticAnalyzer.SymbolT)
                   (ww2 :: FrontEnd.SemanticAnalyzer.Context) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (Data.HashMap.Map
                             GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                        FrontEnd.SemanticAnalyzer.$s$fEqMap
                        ww
                        (GHC.Types.[]
                           @ (Data.HashMap.Map
                                GHC.Base.String
                                (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))) of wild {
                   GHC.Types.False
                   -> Data.Either.Right
                        @ [GHC.Types.Char]
                        @ ((),
                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context))
                        (GHC.Tuple.(),
                         ((GHC.Types.:
                             @ (Data.HashMap.Map
                                  GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                             (Data.HashMap.fromList1
                                @ GHC.Base.String
                                @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                Data.Hashable.Class.$fHashable[]_$s$fHashable[]
                                GHC.Classes.$fOrd[]_$s$fOrd[]1
                                (case w of wild1 { FrontEnd.AST.Ann ds ds1 ->
                                 case ds of wild2 { FrontEnd.AST.Ident symbol -> symbol } })
                                (w1, w2)
                                (GHC.List.head
                                   @ (Data.HashMap.Map
                                        GHC.Base.String
                                        (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                                   ww))
                               `cast`
                             (Sym (Data.HashMap.N:Map[0]
                                       <GHC.Base.String>_N
                                       <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))
                             (case ww of wild1 {
                                []
                                -> GHC.List.scanl2
                                     @ (Data.HashMap.Map
                                          GHC.Base.String
                                          (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                                : ds1 xs -> xs }),
                           ww1),
                          ww2))
                   GHC.Types.True -> FrontEnd.SemanticAnalyzer.addSymbol2 }) -}
3c92d22b5dbd42728b1a50af74eee7a7
  $wanalyzeAST ::
    [FrontEnd.AST.FuncF ()]
    -> FrontEnd.AST.StatListF ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.AST.Type
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          FrontEnd.AST.ProgramF () #)
  {- Arity: 5, Strictness: <L,U><L,1*U(1*U(1*U),U)><L,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [FrontEnd.AST.FuncF ()])
                   (ww1 :: FrontEnd.AST.StatListF ())
                   (ww2 :: Text.Parsec.Pos.SourcePos)
                   (ww3 :: FrontEnd.AST.Type)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (FrontEnd.SemanticAnalyzer.$wanalyzeProgramF ww ww1 ww2 ww3)
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <FrontEnd.SemanticAnalyzer.AnalysisState>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.ProgramF ()>_N)
                        FrontEnd.SemanticAnalyzer.analyzeAST5 of wild {
                   Data.Either.Left l
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             FrontEnd.SemanticAnalyzer.analyzeAST4
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      System.Exit.exitWith1
                        @ (FrontEnd.AST.ProgramF ())
                        FrontEnd.SemanticAnalyzer.analyzeAST2
                        ipv }
                   Data.Either.Right r
                   -> (# w, case r of wild1 { (,) a1 ds1 -> a1 } #) }) -}
1a9944611e00c01aedee541df370f206
  $wanalyzeExprF ::
    FrontEnd.AST.Expr ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.ExprF ())
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U)>, Inline: [0] -}
882437990470006ec3b2557d31e2fea9
  $wanalyzeFuncAppF ::
    FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ExprF ()]
    -> Text.Parsec.Pos.SourcePos
    -> Control.Monad.Trans.State.Lazy.StateT
         FrontEnd.SemanticAnalyzer.AnalysisState
         (Data.Either.Either GHC.Base.String)
         (FrontEnd.AST.Ann (FrontEnd.AST.FuncApp ()))
  {- Arity: 3,
     Strictness: <L,U(U(U),U(U(U,U,U),U))><L,1*U><L,U(U,U,U)>,
     Inline: [0] -}
3700ea22725d09eaff407d1874ab960c
  $wanalyzeFuncF ::
    FrontEnd.AST.Type
    -> FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ParamF ()]
    -> FrontEnd.AST.StatListF ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.AST.Type
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.FuncF ())
  {- Arity: 6,
     Strictness: <L,U><L,U><L,U><L,1*U(1*U(1*U),U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: FrontEnd.AST.Type)
                   (ww1 :: FrontEnd.AST.IdentF ())
                   (ww2 :: [FrontEnd.AST.ParamF ()])
                   (ww3 :: FrontEnd.AST.StatListF ())
                   (ww4 :: Text.Parsec.Pos.SourcePos)
                   (ww5 :: FrontEnd.AST.Type) ->
                 let {
                   lvl24 :: (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type)
                     {- Strictness: m -}
                   = (ww4, ww5)
                 } in
                 let {
                   m2 :: [FrontEnd.AST.Type]
                   = GHC.Base.map
                       @ (FrontEnd.AST.Ann (FrontEnd.AST.Param ()))
                       @ FrontEnd.AST.Type
                       FrontEnd.SemanticAnalyzer.analyzeFuncF2
                       ww2
                 } in
                 let {
                   m3 :: FrontEnd.AST.Type
                   = FrontEnd.AST.TFunc (GHC.Types.[] @ FrontEnd.AST.Type) m2 ww
                 } in
                 let {
                   m4 :: FrontEnd.SemanticAnalyzer.Context
                   = FrontEnd.SemanticAnalyzer.FContext m3
                 } in
                 let {
                   m5 :: Control.Monad.Trans.State.Lazy.StateT
                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)
                           (Data.Either.Either GHC.Base.String)
                           (FrontEnd.AST.StatListF ())
                   = case ww3 of ww6 { FrontEnd.AST.Ann ww7 ww8 ->
                     case ww7 of ww9 { FrontEnd.AST.StatList ww10 ->
                     let {
                       m6 :: Control.Monad.Trans.State.Lazy.StateT
                               (([FrontEnd.SemanticAnalyzer.SymbolT],
                                 FrontEnd.SemanticAnalyzer.SymbolT),
                                FrontEnd.SemanticAnalyzer.Context)
                               (Data.Either.Either GHC.Base.String)
                               [FrontEnd.AST.StatF ()]
                       = FrontEnd.SemanticAnalyzer.analyzeAST_go2 ww10
                     } in
                     (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                                 FrontEnd.SemanticAnalyzer.SymbolT),
                                FrontEnd.SemanticAnalyzer.Context)) ->
                      case m6
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context)>_N
                                <Data.Either.Either GHC.Base.String>_R
                                <[FrontEnd.AST.StatF ()]>_N)
                             s1 of wild {
                        Data.Either.Left l
                        -> Data.Either.Left
                             @ [GHC.Types.Char]
                             @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                                (([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context))
                             l
                        Data.Either.Right r
                        -> Data.Either.Right
                             @ [GHC.Types.Char]
                             @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                                (([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context))
                             (FrontEnd.AST.Ann
                                @ (FrontEnd.AST.StatList ())
                                (FrontEnd.AST.StatList @ () (case r of wild1 { (,) a1 s' -> a1 }))
                                ww8,
                              case r of wild1 { (,) a1 s' -> s' }) })
                       `cast`
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <FrontEnd.AST.Ann (FrontEnd.AST.StatList ())>_N)) } }
                 } in
                 (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)) ->
                  case s1 of wild { (,) tables ds ->
                  case tables of wild1 { (,) tables1 fTable ->
                  case FrontEnd.SemanticAnalyzer.analyzeFuncF1
                         ww2
                         ((GHC.Types.:
                             @ (Data.HashMap.Map
                                  GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                             (Data.IntMap.Base.Nil
                                @ (Data.HashMap.Some
                                     GHC.Base.String
                                     (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)))
                               `cast`
                             (Sym (Data.HashMap.N:Map[0]
                                       <GHC.Base.String>_N
                                       <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))
                             tables1,
                           fTable),
                          m4) of wild2 {
                    Data.Either.Left l
                    -> Data.Either.Left
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.FuncF (),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         l
                    Data.Either.Right r
                    -> case m5
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                    FrontEnd.SemanticAnalyzer.SymbolT),
                                   FrontEnd.SemanticAnalyzer.Context)>_N
                                 <Data.Either.Either GHC.Base.String>_R
                                 <FrontEnd.AST.StatListF ()>_N)
                              (case r of wild3 { (,) a1 s' -> s' }) of wild3 {
                         Data.Either.Left l
                         -> Data.Either.Left
                              @ [GHC.Types.Char]
                              @ (FrontEnd.AST.FuncF (),
                                 (([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context))
                              l
                         Data.Either.Right r1
                         -> case r1 of wild4 { (,) a1 s' ->
                            case s' of wild5 { (,) ds1 context ->
                            case ds1 of wild6 { (,) tables2 fTable1 ->
                            Data.Either.Right
                              @ [GHC.Types.Char]
                              @ (FrontEnd.AST.Ann (FrontEnd.AST.Func ()),
                                 (([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context))
                              (FrontEnd.AST.Ann
                                 @ (FrontEnd.AST.Func ())
                                 (FrontEnd.AST.Func @ () ww ww1 ww2 a1)
                                 lvl24,
                               ((case tables2 of wild7 {
                                   [] -> GHC.List.scanl2 @ FrontEnd.SemanticAnalyzer.SymbolT
                                   : ds2 xs -> xs },
                                 fTable1),
                                FrontEnd.SemanticAnalyzer.Main)) } } } } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <(([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context)>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.FuncF ()>_N))) -}
16d79223e127110877101695e603b6ad
  $wanalyzeProgramF ::
    [FrontEnd.AST.FuncF ()]
    -> FrontEnd.AST.StatListF ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.AST.Type
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.ProgramF ())
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U(1*U),U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [FrontEnd.AST.FuncF ()])
                   (ww1 :: FrontEnd.AST.StatListF ())
                   (ww2 :: Text.Parsec.Pos.SourcePos)
                   (ww3 :: FrontEnd.AST.Type) ->
                 let {
                   lvl24 :: FrontEnd.SemanticAnalyzer.Analyzer
                              (FrontEnd.AST.StatListF ())
                   = case ww1 of ww4 { FrontEnd.AST.Ann ww5 ww6 ->
                     case ww5 of ww7 { FrontEnd.AST.StatList ww8 ->
                     let {
                       m2 :: Control.Monad.Trans.State.Lazy.StateT
                               (([FrontEnd.SemanticAnalyzer.SymbolT],
                                 FrontEnd.SemanticAnalyzer.SymbolT),
                                FrontEnd.SemanticAnalyzer.Context)
                               (Data.Either.Either GHC.Base.String)
                               [FrontEnd.AST.StatF ()]
                       = FrontEnd.SemanticAnalyzer.analyzeAST_go2 ww8
                     } in
                     (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                                 FrontEnd.SemanticAnalyzer.SymbolT),
                                FrontEnd.SemanticAnalyzer.Context)) ->
                      case m2
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context)>_N
                                <Data.Either.Either GHC.Base.String>_R
                                <[FrontEnd.AST.StatF ()]>_N)
                             s1 of wild {
                        Data.Either.Left l
                        -> Data.Either.Left
                             @ [GHC.Types.Char]
                             @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                                (([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context))
                             l
                        Data.Either.Right r
                        -> Data.Either.Right
                             @ [GHC.Types.Char]
                             @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                                (([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context))
                             (FrontEnd.AST.Ann
                                @ (FrontEnd.AST.StatList ())
                                (FrontEnd.AST.StatList @ () (case r of wild1 { (,) a1 s' -> a1 }))
                                ww6,
                              case r of wild1 { (,) a1 s' -> s' }) })
                       `cast`
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <FrontEnd.AST.Ann (FrontEnd.AST.StatList ())>_N)) } }
                 } in
                 let {
                   m2 :: Control.Monad.Trans.State.Lazy.StateT
                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)
                           (Data.Either.Either GHC.Base.String)
                           [FrontEnd.AST.FuncF ()]
                   = FrontEnd.SemanticAnalyzer.analyzeAST_go1 ww
                 } in
                 let {
                   m3 :: Control.Monad.Trans.State.Lazy.StateT
                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)
                           (Data.Either.Either GHC.Base.String)
                           [FrontEnd.AST.FuncF ()]
                   = FrontEnd.SemanticAnalyzer.analyzeAST_go ww
                 } in
                 let {
                   wild :: (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type) = (ww2, ww3)
                 } in
                 (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)) ->
                  case s1 of wild1 { (,) ds context ->
                  case ds of wild2 { (,) tables fTable ->
                  case FrontEnd.SemanticAnalyzer.analyzeAST7
                         FrontEnd.AST.builtInFunc
                         ((GHC.Types.:
                             @ (Data.HashMap.Map
                                  GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                             (Data.IntMap.Base.Nil
                                @ (Data.HashMap.Some
                                     GHC.Base.String
                                     (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)))
                               `cast`
                             (Sym (Data.HashMap.N:Map[0]
                                       <GHC.Base.String>_N
                                       <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))
                             tables,
                           fTable),
                          context) of wild3 {
                    Data.Either.Left l
                    -> Data.Either.Left
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.ProgramF (),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         l
                    Data.Either.Right r
                    -> case m2
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                    FrontEnd.SemanticAnalyzer.SymbolT),
                                   FrontEnd.SemanticAnalyzer.Context)>_N
                                 <Data.Either.Either GHC.Base.String>_R
                                 <[FrontEnd.AST.FuncF ()]>_N)
                              (case r of wild4 { (,) a1 s' -> s' }) of wild4 {
                         Data.Either.Left l
                         -> Data.Either.Left
                              @ [GHC.Types.Char]
                              @ (FrontEnd.AST.ProgramF (),
                                 (([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context))
                              l
                         Data.Either.Right r1
                         -> case m3
                                   `cast`
                                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                         FrontEnd.SemanticAnalyzer.SymbolT),
                                        FrontEnd.SemanticAnalyzer.Context)>_N
                                      <Data.Either.Either GHC.Base.String>_R
                                      <[FrontEnd.AST.FuncF ()]>_N)
                                   (case r1 of wild5 { (,) a1 s' -> s' }) of wild5 {
                              Data.Either.Left l
                              -> Data.Either.Left
                                   @ [GHC.Types.Char]
                                   @ (FrontEnd.AST.ProgramF (),
                                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                                        FrontEnd.SemanticAnalyzer.SymbolT),
                                       FrontEnd.SemanticAnalyzer.Context))
                                   l
                              Data.Either.Right r2
                              -> case lvl24
                                        `cast`
                                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                           <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                              FrontEnd.SemanticAnalyzer.SymbolT),
                                             FrontEnd.SemanticAnalyzer.Context)>_N
                                           <Data.Either.Either GHC.Base.String>_R
                                           <FrontEnd.AST.StatListF ()>_N)
                                        (case r2 of wild6 { (,) a1 s' -> s' }) of wild6 {
                                   Data.Either.Left l
                                   -> Data.Either.Left
                                        @ [GHC.Types.Char]
                                        @ (FrontEnd.AST.ProgramF (),
                                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                                             FrontEnd.SemanticAnalyzer.SymbolT),
                                            FrontEnd.SemanticAnalyzer.Context))
                                        l
                                   Data.Either.Right r3
                                   -> case r3 of wild7 { (,) a1 s' ->
                                      case s' of wild8 { (,) ds1 context1 ->
                                      case ds1 of wild9 { (,) tables1 fTable1 ->
                                      Data.Either.Right
                                        @ [GHC.Types.Char]
                                        @ (FrontEnd.AST.Ann (FrontEnd.AST.Program ()),
                                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                                             FrontEnd.SemanticAnalyzer.SymbolT),
                                            FrontEnd.SemanticAnalyzer.Context))
                                        (FrontEnd.AST.Ann
                                           @ (FrontEnd.AST.Program ())
                                           (FrontEnd.AST.Program
                                              @ ()
                                              (case r2 of wild10 { (,) a2 s'1 -> a2 })
                                              a1)
                                           wild,
                                         ((case tables1 of wild10 {
                                             []
                                             -> GHC.List.scanl2 @ FrontEnd.SemanticAnalyzer.SymbolT
                                             : ds2 xs -> xs },
                                           fTable1),
                                          context1)) } } } } } } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <(([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context)>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.ProgramF ()>_N))) -}
419a790c2ba661bc5d6a2ab462e36558
  $wanalyzeStatF ::
    FrontEnd.AST.Stat ()
    -> (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type)
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.StatF ())
  {- Arity: 2, Strictness: <S,1*U><L,U(U(U,U,U),U)>, Inline: [0] -}
72cfb393215c494de2571c6c6e33c0b2
  $wanalyzeStatListF ::
    [FrontEnd.AST.StatF ()]
    -> (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type)
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.StatListF ())
  {- Arity: 2, Strictness: <L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [FrontEnd.AST.StatF ()])
                   (ww1 :: (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type)) ->
                 let {
                   m2 :: Control.Monad.Trans.State.Lazy.StateT
                           (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)
                           (Data.Either.Either GHC.Base.String)
                           [FrontEnd.AST.StatF ()]
                   = FrontEnd.SemanticAnalyzer.analyzeAST_go2 ww
                 } in
                 (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)) ->
                  case m2
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <(([FrontEnd.SemanticAnalyzer.SymbolT],
                               FrontEnd.SemanticAnalyzer.SymbolT),
                              FrontEnd.SemanticAnalyzer.Context)>_N
                            <Data.Either.Either GHC.Base.String>_R
                            <[FrontEnd.AST.StatF ()]>_N)
                         s1 of wild {
                    Data.Either.Left l
                    -> Data.Either.Left
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         l
                    Data.Either.Right r
                    -> Data.Either.Right
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.Ann (FrontEnd.AST.StatList ()),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         (FrontEnd.AST.Ann
                            @ (FrontEnd.AST.StatList ())
                            (FrontEnd.AST.StatList @ () (case r of wild1 { (,) a1 s' -> a1 }))
                            ww1,
                          case r of wild1 { (,) a1 s' -> s' }) })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <(([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context)>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.Ann (FrontEnd.AST.StatList ())>_N))) -}
2cd9115f39118408f7067207f530c0f2
  $wfunctionType ::
    GHC.Base.String -> Text.Parsec.Pos.SourcePos -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,1*U(1*U,U,U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: Text.Parsec.Pos.SourcePos) ->
                 case GHC.List.elem
                        @ GHC.Base.String
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        ww
                        FrontEnd.SemanticAnalyzer.functionType2 of wild {
                   GHC.Types.False
                   -> GHC.CString.unpackAppendCString#
                        "function "#
                        (GHC.CString.unpackAppendCString#
                           "\""#
                           (GHC.Base.++
                              @ GHC.Types.Char
                              ww
                              (GHC.CString.unpackAppendCString#
                                 "\""#
                                 (GHC.CString.unpackAppendCString#
                                    " defined at "#
                                    (case ww1 of ww2 { Text.Parsec.Pos.SourcePos ww3 ww4 ww5 ->
                                     Text.Parsec.Pos.$w$cshow ww3 ww4 ww5 })))))
                   GHC.Types.True
                   -> GHC.CString.unpackAppendCString#
                        "built-in function \""#
                        (GHC.Base.++
                           @ GHC.Types.Char
                           ww
                           FrontEnd.SemanticAnalyzer.functionType1) }) -}
144e943353374e816afe08361abde346
  $wgetAllFuncType ::
    FrontEnd.AST.Type
    -> FrontEnd.AST.IdentF ()
    -> [FrontEnd.AST.ParamF ()]
    -> FrontEnd.AST.StatListF ()
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.AST.Type
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.FuncF ())
  {- Arity: 6,
     Strictness: <L,U><L,U(U(U),U)><L,U><L,U><L,U(U,U,U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: FrontEnd.AST.Type)
                   (ww1 :: FrontEnd.AST.IdentF ())
                   (ww2 :: [FrontEnd.AST.ParamF ()])
                   (ww3 :: FrontEnd.AST.StatListF ())
                   (ww4 :: Text.Parsec.Pos.SourcePos)
                   (ww5 :: FrontEnd.AST.Type) ->
                 let {
                   m2 :: [FrontEnd.AST.Type]
                   = GHC.Base.map
                       @ (FrontEnd.AST.Ann (FrontEnd.AST.Param ()))
                       @ FrontEnd.AST.Type
                       FrontEnd.SemanticAnalyzer.analyzeFuncF2
                       ww2
                 } in
                 let {
                   m3 :: FrontEnd.AST.Type
                   = FrontEnd.AST.TFunc (GHC.Types.[] @ FrontEnd.AST.Type) m2 ww
                 } in
                 let {
                   lvl24 :: (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos) = (m3, ww4)
                 } in
                 let {
                   ds :: (Text.Parsec.Pos.SourcePos, FrontEnd.AST.Type) = (ww4, ww5)
                 } in
                 let {
                   ds1 :: FrontEnd.AST.Func () = FrontEnd.AST.Func @ () ww ww1 ww2 ww3
                 } in
                 let {
                   wild :: FrontEnd.AST.FuncF ()
                   = FrontEnd.AST.Ann @ (FrontEnd.AST.Func ()) ds1 ds
                 } in
                 let {
                   lvl25 :: GHC.Base.String
                   = case ww1 of wild1 { FrontEnd.AST.Ann ds2 ds3 ->
                     case ds2 of wild2 { FrontEnd.AST.Ident symbol -> symbol } }
                 } in
                 (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)) ->
                  case s1 of ww6 { (,) ww7 ww8 ->
                  case ww7 of ww9 { (,) ww10 ww11 ->
                  case FrontEnd.SemanticAnalyzer.$wlookUpFunction
                         ww1
                         ww10
                         ww11
                         ww8 of ww12 { Unit# ww13 ->
                  case ww13 of wild1 { (,) a1 s' ->
                  case a1 of wild2 {
                    GHC.Base.Nothing
                    -> case s' of ww14 { (,) ww15 ww16 ->
                       case ww15 of ww17 { (,) ww18 ww19 ->
                       Data.Either.Right
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.FuncF (),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         (wild,
                          ((ww18,
                            (Data.HashMap.fromList1
                               @ GHC.Base.String
                               @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                               Data.Hashable.Class.$fHashable[]_$s$fHashable[]
                               GHC.Classes.$fOrd[]_$s$fOrd[]1
                               lvl25
                               lvl24
                               ww19)
                              `cast`
                            (Sym (Data.HashMap.N:Map[0]
                                      <GHC.Base.String>_N
                                      <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))),
                           ww16)) } }
                    GHC.Base.Just ds2
                    -> case ds2 of wild3 { (,) ds3 pos' ->
                       Data.Either.Left
                         @ [GHC.Types.Char]
                         @ (FrontEnd.AST.FuncF (),
                            (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context))
                         (FrontEnd.SemanticAnalyzer.declaredError ww1 ww4 pos') } } } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <(([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context)>_N
                           <Data.Either.Either GHC.Base.String>_R
                           <FrontEnd.AST.FuncF ()>_N))) -}
03dd1d54007a7d9c2fc13f2098fc5147
  $wlookUpFunction ::
    FrontEnd.AST.IdentF ()
    -> [FrontEnd.SemanticAnalyzer.SymbolT]
    -> FrontEnd.SemanticAnalyzer.SymbolT
    -> FrontEnd.SemanticAnalyzer.Context
    -> (# (GHC.Base.Maybe
             (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
           (([FrontEnd.SemanticAnalyzer.SymbolT],
             FrontEnd.SemanticAnalyzer.SymbolT),
            FrontEnd.SemanticAnalyzer.Context)) #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.IdentF ())
                   (ww :: [FrontEnd.SemanticAnalyzer.SymbolT])
                   (ww1 :: FrontEnd.SemanticAnalyzer.SymbolT)
                   (ww2 :: FrontEnd.SemanticAnalyzer.Context) ->
                 (# (case w of wild { FrontEnd.AST.Ann ds ds1 ->
                     case ds of wild1 { FrontEnd.AST.Ident symbol ->
                     case Data.Hashable.Class.$w$cliftHashWithSalt
                            @ GHC.Types.Char
                            Data.Hashable.Class.$fHashableChar_$chashWithSalt
                            -2578643520546668380#
                            symbol of ww3 { DEFAULT ->
                     case Data.IntMap.Base.$wlookup
                            @ (Data.HashMap.Some
                                 GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                            ww3
                            ww1
                              `cast`
                            (Data.HashMap.N:Map[0]
                                 <GHC.Base.String>_N
                                 <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R) of wild2 {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing
                            @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                       GHC.Base.Just x
                       -> case x of wild3 {
                            Data.HashMap.Only k' x1
                            -> case GHC.Classes.$fOrd[]_$s$ccompare1 symbol k' of wild4 {
                                 DEFAULT
                                 -> GHC.Base.Nothing
                                      @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                 GHC.Types.EQ
                                 -> GHC.Base.Just
                                      @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                      x1 }
                            Data.HashMap.More s
                            -> Data.Map.Base.lookup
                                 @ GHC.Base.String
                                 @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                 GHC.Classes.$fOrd[]_$s$fOrd[]1
                                 symbol
                                 s } } } } },
                     ((ww, ww1), ww2)) #)) -}
eeedd03053f729ca1de4d77c35da1355
  $wlookUpSymbol ::
    FrontEnd.AST.IdentF ()
    -> [FrontEnd.SemanticAnalyzer.SymbolT]
    -> FrontEnd.SemanticAnalyzer.SymbolT
    -> FrontEnd.SemanticAnalyzer.Context
    -> (# (GHC.Base.Maybe
             (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
           (([FrontEnd.SemanticAnalyzer.SymbolT],
             FrontEnd.SemanticAnalyzer.SymbolT),
            FrontEnd.SemanticAnalyzer.Context)) #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.IdentF ())
                   (ww :: [FrontEnd.SemanticAnalyzer.SymbolT])
                   (ww1 :: FrontEnd.SemanticAnalyzer.SymbolT)
                   (ww2 :: FrontEnd.SemanticAnalyzer.Context) ->
                 (# (let {
                       symbol :: GHC.Base.String
                       = case w of wild { FrontEnd.AST.Ann ds ds1 ->
                         case ds of wild1 { FrontEnd.AST.Ident symbol1 -> symbol1 } }
                     } in
                     letrec {
                       go4 :: [Data.HashMap.Map
                                 GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)]
                              -> GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                              -> GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                         {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                       = \ (ds :: [Data.HashMap.Map
                                     GHC.Base.String
                                     (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)])
                           (eta :: GHC.Base.Maybe
                                     (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)) ->
                         case ds of wild {
                           [] -> eta
                           : y ys
                           -> case eta of wild1 {
                                GHC.Base.Nothing
                                -> case Data.Hashable.Class.$w$cliftHashWithSalt
                                          @ GHC.Types.Char
                                          Data.Hashable.Class.$fHashableChar_$chashWithSalt
                                          -2578643520546668380#
                                          symbol of ww3 { DEFAULT ->
                                   case Data.IntMap.Base.$wlookup
                                          @ (Data.HashMap.Some
                                               GHC.Base.String
                                               (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                                          ww3
                                          y `cast`
                                          (Data.HashMap.N:Map[0]
                                               <GHC.Base.String>_N
                                               <(FrontEnd.AST.Type,
                                                 Text.Parsec.Pos.SourcePos)>_R) of wild2 {
                                     GHC.Base.Nothing
                                     -> go4
                                          ys
                                          (GHC.Base.Nothing
                                             @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                                     GHC.Base.Just x
                                     -> case x of wild3 {
                                          Data.HashMap.Only k' x1
                                          -> case GHC.Classes.$fOrd[]_$s$ccompare1
                                                    symbol
                                                    k' of wild4 {
                                               DEFAULT
                                               -> go4
                                                    ys
                                                    (GHC.Base.Nothing
                                                       @ (FrontEnd.AST.Type,
                                                          Text.Parsec.Pos.SourcePos))
                                               GHC.Types.EQ
                                               -> go4
                                                    ys
                                                    (GHC.Base.Just
                                                       @ (FrontEnd.AST.Type,
                                                          Text.Parsec.Pos.SourcePos)
                                                       x1) }
                                          Data.HashMap.More s
                                          -> go4
                                               ys
                                               (Data.Map.Base.lookup
                                                  @ GHC.Base.String
                                                  @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                                  GHC.Classes.$fOrd[]_$s$fOrd[]1
                                                  symbol
                                                  s) } } }
                                GHC.Base.Just ipv -> go4 ys wild1 } }
                     } in
                     go4
                       ww
                       (GHC.Base.Nothing
                          @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)),
                     ((ww, ww1), ww2)) #)) -}
9f7356312b76b4264b314ad138706932
  $wlookUpSymbolCurrScope ::
    FrontEnd.AST.IdentF ()
    -> [FrontEnd.SemanticAnalyzer.SymbolT]
    -> FrontEnd.SemanticAnalyzer.SymbolT
    -> FrontEnd.SemanticAnalyzer.Context
    -> (# (GHC.Base.Maybe
             (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
           (([FrontEnd.SemanticAnalyzer.SymbolT],
             FrontEnd.SemanticAnalyzer.SymbolT),
            FrontEnd.SemanticAnalyzer.Context)) #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: FrontEnd.AST.IdentF ())
                   (ww :: [FrontEnd.SemanticAnalyzer.SymbolT])
                   (ww1 :: FrontEnd.SemanticAnalyzer.SymbolT)
                   (ww2 :: FrontEnd.SemanticAnalyzer.Context) ->
                 case ww of wild {
                   []
                   -> (# (GHC.Base.Nothing
                            @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
                          ((GHC.Types.[]
                              @ (Data.HashMap.Map
                                   GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)),
                            ww1),
                           ww2)) #)
                   : t ts
                   -> (# (case w of wild1 { FrontEnd.AST.Ann ds ds1 ->
                          case ds of wild2 { FrontEnd.AST.Ident symbol ->
                          case Data.Hashable.Class.$w$cliftHashWithSalt
                                 @ GHC.Types.Char
                                 Data.Hashable.Class.$fHashableChar_$chashWithSalt
                                 -2578643520546668380#
                                 symbol of ww3 { DEFAULT ->
                          case Data.IntMap.Base.$wlookup
                                 @ (Data.HashMap.Some
                                      GHC.Base.String
                                      (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                                 ww3
                                 t `cast`
                                 (Data.HashMap.N:Map[0]
                                      <GHC.Base.String>_N
                                      <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R) of wild3 {
                            GHC.Base.Nothing
                            -> GHC.Base.Nothing
                                 @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                            GHC.Base.Just x
                            -> case x of wild4 {
                                 Data.HashMap.Only k' x1
                                 -> case GHC.Classes.$fOrd[]_$s$ccompare1 symbol k' of wild5 {
                                      DEFAULT
                                      -> GHC.Base.Nothing
                                           @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                      GHC.Types.EQ
                                      -> GHC.Base.Just
                                           @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                           x1 }
                                 Data.HashMap.More s
                                 -> Data.Map.Base.lookup
                                      @ GHC.Base.String
                                      @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                                      GHC.Classes.$fOrd[]_$s$fOrd[]1
                                      symbol
                                      s } } } } },
                          ((wild, ww1), ww2)) #) }) -}
9d138b8b165a858fef9ede5558335926
  type AnalysisState =
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      FrontEnd.SemanticAnalyzer.SymbolT),
     FrontEnd.SemanticAnalyzer.Context)
cb6557cdc28f8ab088f9fecdebd522f6
  type Analyzer =
    Control.Monad.Trans.State.Lazy.StateT
      FrontEnd.SemanticAnalyzer.AnalysisState
      (Data.Either.Either GHC.Base.String)
    :: * -> *
8875467209db093ff756895a8ad9b756
  data Context = Main | FContext FrontEnd.AST.Type
04c2ca2a8062e741d492597782d093ac
  class Mappable a where
    fmap' :: (a -> a) -> a -> a
    {-# MINIMAL fmap' #-}
f41e440c661dcb29c5af1cde9ec82495
  class Matchable a where
    match :: GHC.Base.String
             -> FrontEnd.AST.Ann a
             -> [FrontEnd.AST.Type]
             -> FrontEnd.SemanticAnalyzer.Analyzer ()
    {-# MINIMAL match #-}
e6a6b79e685c6d255cc14c3007e9e8bf
  type SymbolT =
    Data.HashMap.Map
      GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
ae8c5f1bdbb346f609e6c373383aa198
  addFunctionSymbol ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.AST.Type
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 4,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><S(SL),1*U(1*U(U,1*U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.addFunctionSymbol1
                  `cast`
                (<FrontEnd.AST.IdentF ()>_R
                 ->_R <FrontEnd.AST.Type>_R
                 ->_R <Text.Parsec.Pos.SourcePos>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <()>_N)) -}
a460c35d9363081b2aee1447d8182809
  addFunctionSymbol1 ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.AST.Type
    -> Text.Parsec.Pos.SourcePos
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 4,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><S(SL),1*U(1*U(U,1*U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: Text.Parsec.Pos.SourcePos)
                   (w3 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 Data.Either.Right
                   @ GHC.Base.String
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (GHC.Tuple.(),
                    ((ww4,
                      (Data.HashMap.fromList1
                         @ GHC.Base.String
                         @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                         Data.Hashable.Class.$fHashable[]_$s$fHashable[]
                         GHC.Classes.$fOrd[]_$s$fOrd[]1
                         (case w of wild { FrontEnd.AST.Ann ds ds1 ->
                          case ds of wild1 { FrontEnd.AST.Ident symbol -> symbol } })
                         (w1, w2)
                         ww5)
                        `cast`
                      (Sym (Data.HashMap.N:Map[0]
                                <GHC.Base.String>_N
                                <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))),
                     ww2)) } }) -}
37fc5c8badceb670c97c7d43f2ba7f2e
  addSymbol ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.AST.Type
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 4,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><S(S(SL)L),1*U(1*U(U,U),U)>,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.addSymbol1
                  `cast`
                (<FrontEnd.AST.IdentF ()>_R
                 ->_R <FrontEnd.AST.Type>_R
                 ->_R <Text.Parsec.Pos.SourcePos>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <()>_N)) -}
a747eb74c64402a22c585496fbd4bcc0
  addSymbol1 ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.AST.Type
    -> Text.Parsec.Pos.SourcePos
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 4,
     Strictness: <L,1*U(1*U(1*U),A)><L,U><L,U><S(S(SL)L),1*U(1*U(U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: FrontEnd.AST.Type)
                   (w2 :: Text.Parsec.Pos.SourcePos)
                   (w3 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 FrontEnd.SemanticAnalyzer.$waddSymbol w w1 w2 ww4 ww5 ww2 } }) -}
247cb8359468a237b35ba7519005145f
  addSymbol2 ::
    Data.Either.Either
      [GHC.Types.Char]
      ((),
       (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context))
  {- HasNoCafRefs,
     Unfolding: (Data.Either.Left
                   @ [GHC.Types.Char]
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   FrontEnd.SemanticAnalyzer.$s$fAlternativeEither_$s$fError[]_$cnoMsg) -}
e5e0977902ab61dd8618d68f6e124446
  analyzeAST ::
    FrontEnd.AST.ProgramF () -> GHC.Types.IO (FrontEnd.AST.ProgramF ())
  {- Arity: 2,
     Strictness: <S(SS),1*U(1*U(U,1*U(1*U(1*U),U)),1*U(U,U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.analyzeAST1
                  `cast`
                (<FrontEnd.AST.ProgramF ()>_R
                 ->_R Sym (GHC.Types.N:IO[0] <FrontEnd.AST.ProgramF ()>_R)) -}
c66a0bd5002efc0af6c2979057786cdc
  analyzeAST1 ::
    FrontEnd.AST.ProgramF ()
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          FrontEnd.AST.ProgramF () #)
  {- Arity: 2,
     Strictness: <S(SS),1*U(1*U(U,1*U(1*U(1*U),U)),1*U(U,U))><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrontEnd.AST.ProgramF ())
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Program ww4 ww5 ->
                 case ww2 of ww6 { (,) ww7 ww8 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeAST ww4 ww5 ww7 ww8 w1 } } }) -}
69d0736fefedf66c419a0fccbf3d3d73
  analyzeAST2 :: GHC.IO.Exception.ExitCode
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.IO.Exception.ExitFailure
                   FrontEnd.SemanticAnalyzer.analyzeAST3) -}
cc20565899fb458c0ae11afad921197f
  analyzeAST3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 200#) -}
1ab44538820cf81e7c1c327762fddb29
  analyzeAST4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#semantic_error#"#) -}
296aab9bdb6de9f02e3ff5d693f668ef
  analyzeAST5 ::
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      Data.HashMap.Map
        GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)),
     FrontEnd.SemanticAnalyzer.Context)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((FrontEnd.SemanticAnalyzer.analyzeAST6,
                  FrontEnd.SemanticAnalyzer.Main)) -}
304148c3dbfebaa5edafa8d797c7edaf
  analyzeAST6 ::
    ([FrontEnd.SemanticAnalyzer.SymbolT],
     Data.HashMap.Map
       GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.[] @ FrontEnd.SemanticAnalyzer.SymbolT,
                  (Data.IntMap.Base.Nil
                     @ (Data.HashMap.Some
                          GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)))
                    `cast`
                  (Sym (Data.HashMap.N:Map[0]
                            <GHC.Base.String>_N
                            <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R)))) -}
5437e105127d0a5f6fa42b90691aa546
  analyzeAST7 ::
    [(GHC.Base.String, FrontEnd.AST.Type)]
    -> FrontEnd.SemanticAnalyzer.AnalysisState
    -> Data.Either.Either
         GHC.Base.String ([()], FrontEnd.SemanticAnalyzer.AnalysisState)
  {- Arity: 2, Strictness: <S,1*U><L,U(U(U,U),U)> -}
e8af9112ac3e0660d55c61b6fcce373a
  analyzeAST_go ::
    [FrontEnd.AST.FuncF ()]
    -> Control.Monad.Trans.State.Lazy.StateT
         FrontEnd.SemanticAnalyzer.AnalysisState
         (Data.Either.Either GHC.Base.String)
         [FrontEnd.AST.FuncF ()]
  {- Arity: 1, Strictness: <S,1*U> -}
6829049db57b7b96dddf3f4afded9261
  analyzeAST_go1 ::
    [FrontEnd.AST.FuncF ()]
    -> Control.Monad.Trans.State.Lazy.StateT
         FrontEnd.SemanticAnalyzer.AnalysisState
         (Data.Either.Either GHC.Base.String)
         [FrontEnd.AST.FuncF ()]
  {- Arity: 1, Strictness: <S,1*U> -}
6c71564a821ec4caf9c0da56f086a1ff
  analyzeAST_go2 ::
    [FrontEnd.AST.StatF ()]
    -> Control.Monad.Trans.State.Lazy.StateT
         FrontEnd.SemanticAnalyzer.AnalysisState
         (Data.Either.Either GHC.Base.String)
         [FrontEnd.AST.StatF ()]
  {- Arity: 1, Strictness: <S,1*U> -}
7d12bcb82d10d1bb589145a4def789e2
  analyzeExprF ::
    FrontEnd.AST.ExprF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.ExprF ())
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U(U(U,U,U),A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.ExprF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww2 of ww3 { (,) ww4 ww5 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeExprF ww1 ww4 } }) -}
5349c8247274d3559b76dc331ce218f4
  analyzeFile ::
    GHC.Base.String -> GHC.Types.IO (FrontEnd.AST.ProgramF ())
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.analyzeFile1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <FrontEnd.AST.ProgramF ()>_R)) -}
2bdcae81d17bccac84bf356bb5d46461
  analyzeFile1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          FrontEnd.AST.ProgramF () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (file :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        file
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case (Text.Parsec.Prim.runPT
                         @ GHC.Base.String
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ (FrontEnd.AST.ProgramF ())
                         (FrontEnd.SemanticAnalyzer.$s$fStream[]mtok @ GHC.Types.Char)
                         FrontEnd.Parser.parseFile5
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <FrontEnd.AST.ProgramF ()>_R))
                         GHC.Tuple.()
                         (GHC.Types.[] @ GHC.Types.Char)
                         ipv3)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError
                              (FrontEnd.AST.ProgramF ())>_R) of wild {
                   Data.Either.Left e
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             FrontEnd.SemanticAnalyzer.analyzeFile4
                             GHC.Types.True
                             ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                      System.Exit.exitWith1
                        @ (FrontEnd.AST.ProgramF ())
                        FrontEnd.SemanticAnalyzer.analyzeFile2
                        ipv4 }
                   Data.Either.Right r
                   -> FrontEnd.SemanticAnalyzer.analyzeAST1 r ipv2 } } }) -}
a080523024ac1f70e0def261a31e44c1
  analyzeFile2 :: GHC.IO.Exception.ExitCode
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.IO.Exception.ExitFailure
                   FrontEnd.SemanticAnalyzer.analyzeFile3) -}
36ac42106276a18440878c6a2d19a3fb
  analyzeFile3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 100#) -}
8b95ce3e5617c7e6ed5e717b54090780
  analyzeFile4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#syntax_error#"#) -}
e211312deaa99b56b381ad182c792b31
  analyzeFuncAppF ::
    FrontEnd.AST.Ann (FrontEnd.AST.FuncApp ())
    -> Control.Monad.Trans.State.Lazy.StateT
         FrontEnd.SemanticAnalyzer.AnalysisState
         (Data.Either.Either GHC.Base.String)
         (FrontEnd.AST.Ann (FrontEnd.AST.FuncApp ()))
  {- Arity: 1,
     Strictness: <S(SS),1*U(1*U(A,U(U(U),U(U(U,U,U),U)),1*U),1*U(U(U,U,U),A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.Ann (FrontEnd.AST.FuncApp ())) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.FuncApp ww4 ww5 ww6 ->
                 case ww2 of ww7 { (,) ww8 ww9 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeFuncAppF ww5 ww6 ww8 } } }) -}
81d62237926df7a281967a6e3ed5d57b
  analyzeFuncF ::
    FrontEnd.AST.FuncF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.FuncF ())
  {- Arity: 1,
     Strictness: <S(SS),1*U(1*U(U,U,U,1*U(1*U(1*U),U)),1*U(U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.FuncF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Func ww4 ww5 ww6 ww7 ->
                 case ww2 of ww8 { (,) ww9 ww10 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeFuncF
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10 } } }) -}
1ebbc1c438ef7615897befc51da5ac25
  analyzeFuncF1 ::
    [FrontEnd.AST.Ann (FrontEnd.AST.Param ())]
    -> FrontEnd.SemanticAnalyzer.AnalysisState
    -> Data.Either.Either
         GHC.Base.String ([()], FrontEnd.SemanticAnalyzer.AnalysisState)
  {- Arity: 2, Strictness: <S,1*U><L,U(U(U,U),U)> -}
fb7290aef912d9438414ad21a434a284
  analyzeFuncF2 ::
    FrontEnd.AST.Ann (FrontEnd.AST.Param ()) -> FrontEnd.AST.Type
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,A),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: FrontEnd.AST.Ann (FrontEnd.AST.Param ())) ->
                 case ds of wild { FrontEnd.AST.Ann ds1 ds2 ->
                 case ds1 of wild1 { FrontEnd.AST.Param t ds3 -> t } }) -}
f374d6875e69bd88b2ad5c4f254597dc
  analyzeProgramF ::
    FrontEnd.AST.ProgramF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.ProgramF ())
  {- Arity: 1,
     Strictness: <S(SS),1*U(1*U(U,1*U(1*U(1*U),U)),1*U(U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.ProgramF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Program ww4 ww5 ->
                 case ww2 of ww6 { (,) ww7 ww8 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeProgramF
                   ww4
                   ww5
                   ww7
                   ww8 } } }) -}
682a49440689d47fad0de50d77c4f19e
  analyzeStatF ::
    FrontEnd.AST.StatF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.StatF ())
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,U(U(U,U,U),U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.StatF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeStatF ww1 ww2 }) -}
4f6f167d3b82a1352cb3abd0964e39cc
  analyzeStatListF ::
    FrontEnd.AST.StatListF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.StatListF ())
  {- Arity: 1, Strictness: <S(SL),1*U(1*U(1*U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.StatListF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.StatList ww4 ->
                 FrontEnd.SemanticAnalyzer.$wanalyzeStatListF ww4 ww2 } }) -}
df238580972b1520e1434c4f72ac45bb
  builtInPos :: Text.Parsec.Pos.SourcePos
  {- Strictness: m,
     Unfolding: (Text.Parsec.Pos.SourcePos
                   FrontEnd.SemanticAnalyzer.builtInPos1
                   0#
                   0#) -}
d536ca675ce6f3fc44e488468f464bbf
  builtInPos1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "builtIn"#) -}
139dacf00b5c35cf42791117f71e5a9e
  declaredError ::
    FrontEnd.AST.IdentF ()
    -> Text.Parsec.Pos.SourcePos
    -> Text.Parsec.Pos.SourcePos
    -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*U(1*U),A)><L,1*U(1*U,U,U)><L,1*U(1*U,U,U)>,
     Unfolding: (\ (symbol :: FrontEnd.AST.IdentF ())
                   (pos1 :: Text.Parsec.Pos.SourcePos)
                   (pos2 :: Text.Parsec.Pos.SourcePos) ->
                 GHC.CString.unpackAppendCString#
                   "Symbol "#
                   (case symbol of wild { FrontEnd.AST.Ann f1 ds1 ->
                    case f1 of wild1 { FrontEnd.AST.Ident s ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows6
                         (GHC.Show.showLitString
                            s
                            FrontEnd.SemanticAnalyzer.declaredError2))
                      (GHC.CString.unpackAppendCString#
                         " at "#
                         (case pos1 of ww { Text.Parsec.Pos.SourcePos ww1 ww2 ww3 ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            (Text.Parsec.Pos.$w$cshow ww1 ww2 ww3)
                            (GHC.CString.unpackAppendCString#
                               " already declared at "#
                               (case pos2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (Text.Parsec.Pos.$w$cshow ww5 ww6 ww7)
                                  FrontEnd.SemanticAnalyzer.declaredError1 })) })) } })) -}
350512d2697952d24ffbc6f75546174f
  declaredError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
3d9b8ebc21fc2ff6c02fd7b34d702d6b
  declaredError2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f96f0d4bb109b8542c12d332d33fa624
  functionType :: FrontEnd.AST.IdentF () -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SS),1*U(1*U(U),1*U(1*U(1*U,U,U),A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.IdentF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Ident ww4 ->
                 case ww2 of ww5 { (,) ww6 ww7 ->
                 FrontEnd.SemanticAnalyzer.$wfunctionType ww4 ww6 } } }) -}
8460d69b9b6dcc2cc74357a114424e71
  functionType1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\""#) -}
51dc9c490f75f9f4766c4fd386fd0d99
  functionType2 :: [[GHC.Types.Char]]
  {- Unfolding: (GHC.Base.map
                   @ (GHC.Base.String, FrontEnd.AST.Type)
                   @ [GHC.Types.Char]
                   (Data.Tuple.fst @ GHC.Base.String @ FrontEnd.AST.Type)
                   FrontEnd.AST.builtInFunc) -}
589b3f498449cbbfed4eac0232b934ef
  getAllFuncType ::
    FrontEnd.AST.FuncF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer (FrontEnd.AST.FuncF ())
  {- Arity: 1,
     Strictness: <S(SS),1*U(U(U,U(U(U),U),U,U),U(U(U,U,U),U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: FrontEnd.AST.FuncF ()) ->
                 case w of ww { FrontEnd.AST.Ann ww1 ww2 ->
                 case ww1 of ww3 { FrontEnd.AST.Func ww4 ww5 ww6 ww7 ->
                 case ww2 of ww8 { (,) ww9 ww10 ->
                 FrontEnd.SemanticAnalyzer.$wgetAllFuncType
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10 } } }) -}
e352115d9c492c02ad83ffc6dbc69cee
  getContext ::
    FrontEnd.SemanticAnalyzer.Analyzer
      FrontEnd.SemanticAnalyzer.Context
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.getContext1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <(([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)>_N
                          <Data.Either.Either GHC.Base.String>_R
                          <FrontEnd.SemanticAnalyzer.Context>_N)) -}
78255ab96b94f306dbad39e26a39b1df
  getContext1 ::
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      FrontEnd.SemanticAnalyzer.SymbolT),
     FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         (FrontEnd.SemanticAnalyzer.Context,
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case s1 of wild { (,) ds c ->
                 Data.Either.Right
                   @ [GHC.Types.Char]
                   @ (FrontEnd.SemanticAnalyzer.Context,
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (c, wild) }) -}
3359cd45cde9077ee86c515ac4c735cc
  getStats ::
    FrontEnd.AST.Ann (FrontEnd.AST.StatList t)
    -> [FrontEnd.AST.StatF t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S(S)L),1*U(1*U(1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: FrontEnd.AST.Ann (FrontEnd.AST.StatList t)) ->
                 case ds of wild { FrontEnd.AST.Ann ds1 ds2 ->
                 case ds1 of wild1 { FrontEnd.AST.StatList stats -> stats } }) -}
51b6b8aa595b6de29f226ddff69c91da
  getT :: FrontEnd.AST.Ann t -> FrontEnd.AST.Type
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*H)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: FrontEnd.AST.Ann t) ->
                 case ds of wild { FrontEnd.AST.Ann ds1 ds2 ->
                 case ds2 of wild1 { (,) pos t1 -> FrontEnd.AST.T } }) -}
0739d9c5a5d918a5c7baea6f1ceacdc0
  lookUpFunction ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(SL),1*U(U(U,U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.lookUpFunction1
                  `cast`
                (<FrontEnd.AST.IdentF ()>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <GHC.Base.Maybe
                                  (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_N)) -}
6bd3682e261780cbdb2b43a03cac3486
  lookUpFunction1 ::
    FrontEnd.AST.IdentF ()
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(SL),1*U(U(U,U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case FrontEnd.SemanticAnalyzer.$wlookUpFunction
                        w
                        ww4
                        ww5
                        ww2 of ww6 { Unit# ww7 ->
                 Data.Either.Right
                   @ GHC.Base.String
                   @ (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   ww7 } } }) -}
b295a8857ff920f638f5c2eaa6a40fa6
  lookUpSymbol ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(SL),1*U(U(U,U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.lookUpSymbol1
                  `cast`
                (<FrontEnd.AST.IdentF ()>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <GHC.Base.Maybe
                                  (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_N)) -}
d1829c54919f1e9f050f8cfd91f67c46
  lookUpSymbol1 ::
    FrontEnd.AST.IdentF ()
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(SL),1*U(U(U,U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case FrontEnd.SemanticAnalyzer.$wlookUpSymbol
                        w
                        ww4
                        ww5
                        ww2 of ww6 { Unit# ww7 ->
                 Data.Either.Right
                   @ GHC.Base.String
                   @ (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   ww7 } } }) -}
9b4f41027ab4b1e7d8fd5665b0ff7af3
  lookUpSymbolCurrScope ::
    FrontEnd.AST.IdentF ()
    -> FrontEnd.SemanticAnalyzer.Analyzer
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(S(SL)L),1*U(U(U,U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.lookUpSymbolCurrScope1
                  `cast`
                (<FrontEnd.AST.IdentF ()>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <GHC.Base.Maybe
                                  (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_N)) -}
dcde7050d40bf3fb9104e32782ecbeb2
  lookUpSymbolCurrScope1 ::
    FrontEnd.AST.IdentF ()
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U),A)><S(S(SL)L),1*U(U(U,U),U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrontEnd.AST.IdentF ())
                   (w1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case FrontEnd.SemanticAnalyzer.$wlookUpSymbolCurrScope
                        w
                        ww4
                        ww5
                        ww2 of ww6 { Unit# ww7 ->
                 Data.Either.Right
                   @ GHC.Base.String
                   @ (GHC.Base.Maybe (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   ww7 } } }) -}
254066929b685af1f734476dc6a8891a
  matchT ::
    GHC.Base.String
    -> FrontEnd.AST.Type
    -> [FrontEnd.AST.Type]
    -> Text.Parsec.Pos.SourcePos
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,1*U(1*U,U,U)>,
     Unfolding: (\ (msg :: GHC.Base.String)
                   (t :: FrontEnd.AST.Type)
                   (expectT :: [FrontEnd.AST.Type])
                   (pos :: Text.Parsec.Pos.SourcePos) ->
                 case GHC.List.elem
                        @ FrontEnd.AST.Type
                        FrontEnd.AST.$fEqType
                        t
                        expectT of wild {
                   GHC.Types.False
                   -> let {
                        eta :: [GHC.Types.Char]
                        = FrontEnd.SemanticAnalyzer.typeError msg pos expectT t
                      } in
                      let {
                        lvl24 :: Data.Either.Either
                                   [GHC.Types.Char]
                                   ((),
                                    (([FrontEnd.SemanticAnalyzer.SymbolT],
                                      FrontEnd.SemanticAnalyzer.SymbolT),
                                     FrontEnd.SemanticAnalyzer.Context))
                        = Data.Either.Left
                            @ [GHC.Types.Char]
                            @ ((),
                               (([FrontEnd.SemanticAnalyzer.SymbolT],
                                 FrontEnd.SemanticAnalyzer.SymbolT),
                                FrontEnd.SemanticAnalyzer.Context))
                            eta
                      } in
                      (\ (eta1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                                    FrontEnd.SemanticAnalyzer.SymbolT),
                                   FrontEnd.SemanticAnalyzer.Context)) ->
                       lvl24)
                        `cast`
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context)>_N
                                <Data.Either.Either GHC.Base.String>_R
                                <()>_N))
                   GHC.Types.True
                   -> FrontEnd.SemanticAnalyzer.matchT1
                        `cast`
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                   FrontEnd.SemanticAnalyzer.SymbolT),
                                  FrontEnd.SemanticAnalyzer.Context)>_N
                                <Data.Either.Either GHC.Base.String>_R
                                <()>_N)) }) -}
df77679f4b1787dc2c1547bdf485cfb9
  matchT1 ::
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      FrontEnd.SemanticAnalyzer.SymbolT),
     FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         [GHC.Types.Char]
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (eta1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                              FrontEnd.SemanticAnalyzer.SymbolT),
                             FrontEnd.SemanticAnalyzer.Context)) ->
                 Data.Either.Right
                   @ [GHC.Types.Char]
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (GHC.Tuple.(), eta1)) -}
a513274982ed3f22b649fd57d471081c
  notDeclaredError ::
    FrontEnd.AST.IdentF ()
    -> Text.Parsec.Pos.SourcePos -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*U(1*U),A)><L,1*U(1*U,U,U)>,
     Unfolding: (\ (symbol :: FrontEnd.AST.IdentF ())
                   (pos :: Text.Parsec.Pos.SourcePos) ->
                 GHC.CString.unpackAppendCString#
                   "Symbol "#
                   (case symbol of wild { FrontEnd.AST.Ann f1 ds1 ->
                    case f1 of wild1 { FrontEnd.AST.Ident s ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows6
                         (GHC.Show.showLitString
                            s
                            FrontEnd.SemanticAnalyzer.declaredError2))
                      (GHC.CString.unpackAppendCString#
                         " at "#
                         (case pos of ww { Text.Parsec.Pos.SourcePos ww1 ww2 ww3 ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            (Text.Parsec.Pos.$w$cshow ww1 ww2 ww3)
                            FrontEnd.SemanticAnalyzer.notDeclaredError1 })) } })) -}
8bfe8fb80352445d26fbade90055595b
  notDeclaredError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " not defined.\n"#) -}
88682d9ed451fd2c70cf8b56fcc5443d
  paramLenError ::
    FrontEnd.AST.IdentF ()
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*U(U),1*U(1*U(1*U,U,U),A))><L,1*U(U)><L,1*U(U)>,
     Unfolding: (\ (symbol :: FrontEnd.AST.IdentF ())
                   (paramLen :: GHC.Types.Int)
                   (exprLen :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   "For "#
                   (case symbol of ww { FrontEnd.AST.Ann ww1 ww2 ->
                    case ww1 of ww3 { FrontEnd.AST.Ident ww4 ->
                    case ww2 of ww5 { (,) ww6 ww7 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (FrontEnd.SemanticAnalyzer.$wfunctionType ww4 ww6)
                      (GHC.CString.unpackAppendCString#
                         ", require "#
                         (case paramLen of ww8 { GHC.Types.I# ww9 ->
                          case GHC.Show.$wshowSignedInt
                                 0#
                                 ww9
                                 (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            (GHC.Types.: @ GHC.Types.Char ww11 ww12)
                            (GHC.CString.unpackAppendCString#
                               " parameters, "#
                               (case exprLen of ww13 { GHC.Types.I# ww14 ->
                                case GHC.Show.$wshowSignedInt
                                       0#
                                       ww14
                                       (GHC.Types.[] @ GHC.Types.Char) of ww15 { (#,#) ww16 ww17 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.: @ GHC.Types.Char ww16 ww17)
                                  FrontEnd.SemanticAnalyzer.paramLenError1 } })) } })) } } })) -}
b2bb54734f1049f3a038b6ad480f6738
  paramLenError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " are given.\n"#) -}
a2a7f665319db119c5bfaddf2751d038
  popScope :: FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 1, Strictness: <S(SL),1*U(1*U(1*U,U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.popScope1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <(([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)>_N
                          <Data.Either.Either GHC.Base.String>_R
                          <()>_N)) -}
5b4c86e0a6898b7b03eab5bc3e6c34c9
  popScope1 ::
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      FrontEnd.SemanticAnalyzer.SymbolT),
     FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 1, Strictness: <S(SL),1*U(1*U(1*U,U),U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case s1 of wild { (,) ds context ->
                 case ds of wild1 { (,) tables fTable ->
                 Data.Either.Right
                   @ [GHC.Types.Char]
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (GHC.Tuple.(),
                    ((case tables of wild2 {
                        [] -> GHC.List.scanl2 @ FrontEnd.SemanticAnalyzer.SymbolT
                        : ds1 xs -> xs },
                      fTable),
                     context)) } }) -}
7a6247b54010d5853995004fdba6de64
  pushScope :: FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U),U)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.pushScope1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <(([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)>_N
                          <Data.Either.Either GHC.Base.String>_R
                          <()>_N)) -}
df8a3bafd3e11a4068efca87763d33e5
  pushScope1 ::
    (([FrontEnd.SemanticAnalyzer.SymbolT],
      FrontEnd.SemanticAnalyzer.SymbolT),
     FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U),U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                            FrontEnd.SemanticAnalyzer.SymbolT),
                           FrontEnd.SemanticAnalyzer.Context)) ->
                 case s1 of wild { (,) ds context ->
                 case ds of wild1 { (,) tables fTable ->
                 Data.Either.Right
                   @ [GHC.Types.Char]
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (GHC.Tuple.(),
                    ((GHC.Types.:
                        @ (Data.HashMap.Map
                             GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos))
                        (Data.IntMap.Base.Nil
                           @ (Data.HashMap.Some
                                GHC.Base.String (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)))
                          `cast`
                        (Sym (Data.HashMap.N:Map[0]
                                  <GHC.Base.String>_N
                                  <(FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)>_R))
                        tables,
                      fTable),
                     context)) } }) -}
2f73f91d8bfe97819938a10d63da5ea5
  setContext ::
    FrontEnd.SemanticAnalyzer.Context
    -> FrontEnd.SemanticAnalyzer.Analyzer ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m2,
     Unfolding: InlineRule (0, True, True)
                FrontEnd.SemanticAnalyzer.setContext1
                  `cast`
                (<FrontEnd.SemanticAnalyzer.Context>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <(([FrontEnd.SemanticAnalyzer.SymbolT],
                                  FrontEnd.SemanticAnalyzer.SymbolT),
                                 FrontEnd.SemanticAnalyzer.Context)>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <()>_N)) -}
9ef57e59642cdf95c6331ee4a8fe66eb
  setContext1 ::
    FrontEnd.SemanticAnalyzer.Context
    -> (([FrontEnd.SemanticAnalyzer.SymbolT],
         FrontEnd.SemanticAnalyzer.SymbolT),
        FrontEnd.SemanticAnalyzer.Context)
    -> Data.Either.Either
         GHC.Base.String
         ((),
          (([FrontEnd.SemanticAnalyzer.SymbolT],
            FrontEnd.SemanticAnalyzer.SymbolT),
           FrontEnd.SemanticAnalyzer.Context))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (c :: FrontEnd.SemanticAnalyzer.Context)
                   (eta :: (([FrontEnd.SemanticAnalyzer.SymbolT],
                             FrontEnd.SemanticAnalyzer.SymbolT),
                            FrontEnd.SemanticAnalyzer.Context)) ->
                 case eta of wild { (,) tables ds ->
                 Data.Either.Right
                   @ [GHC.Types.Char]
                   @ ((),
                      (([FrontEnd.SemanticAnalyzer.SymbolT],
                        FrontEnd.SemanticAnalyzer.SymbolT),
                       FrontEnd.SemanticAnalyzer.Context))
                   (GHC.Tuple.(), (tables, c)) }) -}
a4222ea5e9548bb0e63e84b2762d2152
  typeError ::
    GHC.Base.String
    -> Text.Parsec.Pos.SourcePos
    -> [FrontEnd.AST.Type]
    -> FrontEnd.AST.Type
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U,U,U)><L,1*U><L,1*U> -}
instance [safe] GHC.Classes.Eq [FrontEnd.SemanticAnalyzer.Context]
  = FrontEnd.SemanticAnalyzer.$fEqContext
instance [safe] FrontEnd.SemanticAnalyzer.Mappable [FrontEnd.AST.Type]
  = FrontEnd.SemanticAnalyzer.$fMappableType
instance [safe] FrontEnd.SemanticAnalyzer.Matchable [FrontEnd.AST.Expr]
  = FrontEnd.SemanticAnalyzer.$fMatchableExpr
instance [safe] FrontEnd.SemanticAnalyzer.Matchable [FrontEnd.AST.Stat]
  = FrontEnd.SemanticAnalyzer.$fMatchableStat
instance [safe] GHC.Show.Show [FrontEnd.SemanticAnalyzer.Context]
  = FrontEnd.SemanticAnalyzer.$fShowContext
"SPEC/FrontEnd.SemanticAnalyzer $fEq(,) @ Type @ SourcePos" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                        Text.Parsec.Pos.SourcePos)
                                                                            ($dEq :: GHC.Classes.Eq
                                                                                       FrontEnd.AST.Type)
  GHC.Classes.$fEq(,) @ FrontEnd.AST.Type
                      @ Text.Parsec.Pos.SourcePos
                      $dEq
                      $dEq1
  = FrontEnd.SemanticAnalyzer.$s$fEq(,)
"SPEC/FrontEnd.SemanticAnalyzer $fEqMap @ [Char] @ (Type, SourcePos)" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                                  (FrontEnd.AST.Type,
                                                                                                   Text.Parsec.Pos.SourcePos))
                                                                                      ($dEq :: GHC.Classes.Eq
                                                                                                 [GHC.Types.Char])
  Data.HashMap.$fEqMap @ [GHC.Types.Char]
                       @ (FrontEnd.AST.Type, Text.Parsec.Pos.SourcePos)
                       $dEq
                       $dEq1
  = FrontEnd.SemanticAnalyzer.$s$fEqMap
"SPEC/FrontEnd.SemanticAnalyzer $fError[]_$cnoMsg @ Char" [ALWAYS] forall ($dErrorList :: Control.Monad.Trans.Error.ErrorList
                                                                                            GHC.Types.Char)
  Control.Monad.Trans.Error.$fError[]_$cnoMsg @ GHC.Types.Char
                                              $dErrorList
  = FrontEnd.SemanticAnalyzer.$s$fAlternativeEither_$s$fError[]_$cnoMsg
"SPEC/FrontEnd.SemanticAnalyzer $fStream[]mtok @ Identity _" [ALWAYS] forall @ tok
                                                                             ($dMonad :: GHC.Base.Monad
                                                                                           Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok @ Data.Functor.Identity.Identity
                                  @ tok
                                  $dMonad
  = FrontEnd.SemanticAnalyzer.$s$fStream[]mtok @ tok
"SPEC/FrontEnd.SemanticAnalyzer $fStream[]mtok_$cp1Stream @ Identity _" [ALWAYS] forall @ tok
                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                      Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cp1Stream @ Data.Functor.Identity.Identity
                                             @ tok
                                             $dMonad
  = FrontEnd.SemanticAnalyzer.$s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream
      @ tok
"SPEC/FrontEnd.SemanticAnalyzer $fStream[]mtok_$cuncons @ Identity _" [ALWAYS] forall @ tok
                                                                                      ($dMonad :: GHC.Base.Monad
                                                                                                    Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cuncons @ Data.Functor.Identity.Identity
                                           @ tok
                                           $dMonad
  = FrontEnd.SemanticAnalyzer.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
      @ tok
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

